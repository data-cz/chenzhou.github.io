<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SVG 转地图json 数据</title>
      <link href="2020/12/30/svg-to-geojson/"/>
      <url>2020/12/30/svg-to-geojson/</url>
      
        <content type="html"><![CDATA[<h1 id="svg-yo-geojson"><a href="#svg-yo-geojson" class="headerlink" title="svg-yo-geojson"></a>svg-yo-geojson</h1><p> svg 转 json</p><h1 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h1><p><a href="https://github.com/data-cz/svg-to-geojson.git">DEMO_HERE</a></p>]]></content>
      
      
      <categories>
          
          <category> Map </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAvue-cli4+webpack%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
      <url>2020/12/29/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAvue-cli4+webpack%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是基于 vue-cli4 实现的移动端框架，其中包含项目常用的配置，组件封装及webpack优化方法，可供快速开发使用。</p><p>技术栈：vue-cli4 + webpack4 + vant + axios + less + postcss-px2rem</p><p>源码 <a href="https://github.com/Michael-lzg/vue-cli4-vant">https://github.com/Michael-lzg/vue-cli4-vant</a></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地启动</span></span><br><span class="line">npm run dev</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产打包</span></span><br><span class="line">npm run build</span><br></pre></td></tr></tbody></table></figure><p>在一两年前，vue-cli3已经声驾到3.0+版本，但是由于旧项目一致习惯于vue-cli2的脚手架的使用，之前也写过一篇 <a href="https://juejin.im/post/5db806b1f265da4d5133485a">搭建一个vue-cli的移动端H5开发模板</a> 简单总结了一点移动端的开发技巧。  </p><p>近日升级vue-cli脚手架才发现，这已经升级到4.0+版本了，觉得很多必要在新的项目中使用vue-cli4进行开发，加上近来对webpack有了进一步理解，所以结合了vue-cli4和webpack搭建了一个移动端框架，以便开箱即用。 主要包括如下技术点：</p><ul><li>vue-cli4脚手架</li><li>vant按需引入</li><li>移动端rem适配</li><li>axios拦截封装</li><li>util工具类函数封装</li><li>vue-router配置</li><li>登录权限校验</li><li>多环境变量配置</li><li>vue.config.js配置</li><li>toast组件封装</li><li>dialog组件封装</li><li>跨域代理设置</li><li>webpack打包可视化分析</li><li>CDN资源优化</li><li>gzip打包优化</li><li>首页添加骨架屏</li></ul><p>关于更多的webpack优化方法，可参考 <a href="https://github.com/Michael-lzg/webpack-vue-cli">https://github.com/Michael-lzg/webpack-vue-cli</a></p><h2 id="配置-vant"><a href="#配置-vant" class="headerlink" title="配置 vant"></a>配置 vant</h2><p>vant 是一套轻量、可靠的移动端 Vue 组件库，非常适合基于 vue 技术栈的移动端开发。在过去很长的一段时间内，本人用的移动端 UI 框架都是 vux。后来由于 vux 不支持 vue-cli3，就转用了 vant，不得不说，无论是在交互体验上，还是代码逻辑上，vant 都比 vux 好很多，而且 vant 的坑比较少。</p><p>对于第三方 UI 组件，如果是全部引入的话，比如会造成打包体积过大，加载首页白屏时间过长的问题，所以按需加载非常必要。vant 也提供了按需加载的方法。<code>babel-plugin-import</code> 是一款 babel 插件，它会在编译过程中将 import 的写法自动转换为按需引入的方式。</p><p>1、安装依赖</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-plugin-import -D</span><br></pre></td></tr></tbody></table></figure><p>2、配置 .babelrc 或者 babel.config.js 文件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在.babelrc 中添加配置</span></span><br><span class="line">{</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"import"</span>, {</span><br><span class="line">      <span class="string">"libraryName"</span>: <span class="string">"vant"</span>,</span><br><span class="line">      <span class="string">"libraryDirectory"</span>: <span class="string">"es"</span>,</span><br><span class="line">      <span class="string">"style"</span>: <span class="literal">true</span></span><br><span class="line">    }]</span><br><span class="line">  ]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于使用 babel7 的用户，可以在 babel.config.js 中配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  plugins: [</span><br><span class="line">    [<span class="string">'import'</span>, {</span><br><span class="line">      libraryName: <span class="string">'vant'</span>,</span><br><span class="line">      libraryDirectory: <span class="string">'es'</span>,</span><br><span class="line">      style: <span class="literal">true</span></span><br><span class="line">    }, <span class="string">'vant'</span>]</span><br><span class="line">  ]</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>3、按需引入</p><p>你可以在代码中直接引入 Vant 组件，插件会自动将代码转化为方式二中的按需引入形式</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> { Button } <span class="keyword">from</span> <span class="string">'vant'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Button)</span><br></pre></td></tr></tbody></table></figure><h2 id="rem-适配"><a href="#rem-适配" class="headerlink" title="rem 适配"></a>rem 适配</h2><p>移动端适配是开发过程中不得不面对的事情。在此，我们使用 postcss 中的 px2rem-loader，将我们项目中的 px 按一定比例转化 rem，这样我们就可以对着蓝湖上的标注写 px 了。</p><p>我们将 html 字跟字体设置为 100px，很多人选择设置为 375px，但是我觉得这样换算出来的 rem 不够精确，而且我们在控制台上调试代码的时候无法很快地口算得出它本来的 px 值。如果设置 1rem=100px，这样我们看到的 0.16rem，0.3rem 就很快得算出原来是 16px，30px 了。</p><p>具体步骤如下；</p><p>1、安装依赖</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install px2rem-loader --save-dev</span><br></pre></td></tr></tbody></table></figure><p>2、在 vue.config.js 进行如下配置</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">css: {</span><br><span class="line">  <span class="comment">// css预设器配置项</span></span><br><span class="line">  loaderOptions: {</span><br><span class="line">    postcss: {</span><br><span class="line">      plugins: [</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">'postcss-px2rem'</span>)({</span><br><span class="line">          remUnit: <span class="number">100</span></span><br><span class="line">        })</span><br><span class="line">      ]</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><p>3、在 main.js 设置 html 跟字体大小</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initRem</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> cale = <span class="built_in">window</span>.screen.availWidth &gt; <span class="number">750</span> ? <span class="number">2</span> : <span class="built_in">window</span>.screen.availWidth / <span class="number">375</span></span><br><span class="line">  <span class="built_in">window</span>.document.documentElement.style.fontSize = <span class="string">`<span class="subst">${<span class="number">100</span> * cale}</span>px`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  initRem()</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="axios-请求封装"><a href="#axios-请求封装" class="headerlink" title="axios 请求封装"></a>axios 请求封装</h2><p>1、设置请求拦截和响应拦截</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PRODUCT_URL = <span class="string">'https://xxxx.com'</span></span><br><span class="line"><span class="keyword">const</span> MOCK_URL = <span class="string">'http://xxxx.com'</span></span><br><span class="line"><span class="keyword">let</span> http = axios.create({</span><br><span class="line">  baseURL: process.env.NODE_ENV === <span class="string">'production'</span> ? PRODUCT_URL : MOCK_URL,</span><br><span class="line">})</span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">http.interceptors.request.use(</span><br><span class="line">  (config) =&gt; {</span><br><span class="line">    <span class="comment">// 设置token，Content-Type</span></span><br><span class="line">    <span class="keyword">var</span> token = sessionStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">    config.headers[<span class="string">'token'</span>] = token</span><br><span class="line">    config.headers[<span class="string">'Content-Type'</span>] = <span class="string">'application/json;charset=UTF-8'</span></span><br><span class="line">    <span class="comment">// 请求显示loading效果</span></span><br><span class="line">    <span class="keyword">if</span> (config.loading === <span class="literal">true</span>) {</span><br><span class="line">      vm.$loading.show()</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  },</span><br><span class="line">  (error) =&gt; {</span><br><span class="line">    vm.$loading.hide()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">  }</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">http.interceptors.response.use(</span><br><span class="line">  (res) =&gt; {</span><br><span class="line">    vm.$loading.hide()</span><br><span class="line">    <span class="comment">// token失效，重新登录</span></span><br><span class="line">    <span class="keyword">if</span> (res.data.code === <span class="number">401</span>) {</span><br><span class="line">      <span class="comment">//  重新登录</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  },</span><br><span class="line">  (error) =&gt; {</span><br><span class="line">    vm.$loading.hide()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">  }</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>2、封装 get 和 post 请求方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url, data, lodaing</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    http</span><br><span class="line">      .get(url)</span><br><span class="line">      .then(</span><br><span class="line">        (response) =&gt; {</span><br><span class="line">          resolve(response)</span><br><span class="line">        },</span><br><span class="line">        (err) =&gt; {</span><br><span class="line">          reject(err)</span><br><span class="line">        }</span><br><span class="line">      )</span><br><span class="line">      .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">        reject(error)</span><br><span class="line">      })</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params">url, data, loading</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    http</span><br><span class="line">      .post(url, data, { <span class="attr">loading</span>: loading })</span><br><span class="line">      .then(</span><br><span class="line">        (response) =&gt; {</span><br><span class="line">          resolve(response)</span><br><span class="line">        },</span><br><span class="line">        (err) =&gt; {</span><br><span class="line">          reject(err)</span><br><span class="line">        }</span><br><span class="line">      )</span><br><span class="line">      .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">        reject(error)</span><br><span class="line">      })</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> { get, post }</span><br></pre></td></tr></tbody></table></figure><p>3、把 get，post 方法挂载到 vue 实例上。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> { get, post } <span class="keyword">from</span> <span class="string">'./js/ajax'</span></span><br><span class="line">Vue.prototype.$http = { get, post }</span><br></pre></td></tr></tbody></table></figure><h2 id="工具类函数封装"><a href="#工具类函数封装" class="headerlink" title="工具类函数封装"></a>工具类函数封装</h2><p>1、添加方法到 vue 实例的原型链上</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  install (Vue, options) {</span><br><span class="line">    Vue.prototype.util = {</span><br><span class="line">      <span class="function"><span class="title">method1</span>(<span class="params">val</span>)</span> {</span><br><span class="line">        ...</span><br><span class="line">      },</span><br><span class="line">      method2 (val) {</span><br><span class="line">       ...</span><br><span class="line">      },</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、在 main.js 通过 vue.use()注册</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'./js/utils'</span></span><br><span class="line">Vue.use(utils)</span><br></pre></td></tr></tbody></table></figure><h2 id="vue-router-配置"><a href="#vue-router-配置" class="headerlink" title="vue-router 配置"></a>vue-router 配置</h2><p>平时很多人对 vue-router 的配置可配置了 path 和 component，实现了路由跳转即可。其实 vue-router 可做的事情还有很多，比如</p><ul><li>路由懒加载配置</li><li>改变单页面应用的 title</li><li>登录权限校验</li><li>页面缓存配置</li></ul><h4 id="路由懒加载配置"><a href="#路由懒加载配置" class="headerlink" title="路由懒加载配置"></a>路由懒加载配置</h4><p>Vue 项目中实现路由按需加载（路由懒加载）的 3 中方式：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、Vue异步组件技术：</span></span><br><span class="line">{</span><br><span class="line">  path: <span class="string">'/home'</span>,</span><br><span class="line">  name: <span class="string">'Home'</span>,</span><br><span class="line">  component: <span class="function"><span class="params">resolve</span> =&gt;</span> reqire([<span class="string">'../views/Home.vue'</span>], resolve)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、es6提案的import()</span></span><br><span class="line">{</span><br><span class="line">  path: <span class="string">'/'</span>,</span><br><span class="line">  name: <span class="string">'home'</span>,</span><br><span class="line">  component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Home.vue'</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、webpack提供的require.ensure()</span></span><br><span class="line">{</span><br><span class="line">  path: <span class="string">'/home'</span>,</span><br><span class="line">  name: <span class="string">'Home'</span>,</span><br><span class="line">  component: <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([],<span class="function">() =&gt;</span>  r(<span class="built_in">require</span>(<span class="string">'../views/Home.vue'</span>)), <span class="string">'home'</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>本项目采用的是第二种方式，为了后续 webpack 打包优化。</p><h4 id="改变单页面应用的-title"><a href="#改变单页面应用的-title" class="headerlink" title="改变单页面应用的 title"></a>改变单页面应用的 title</h4><p>由于单页面应用只有一个 html，所有页面的 title 默认是不会改变的，但是我们可以才路由配置中加入相关属性，再在路由守卫中通过 js 改变页面的 title</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> {</span><br><span class="line">  <span class="built_in">document</span>.title = to.meta.title</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="登录权限校验"><a href="#登录权限校验" class="headerlink" title="登录权限校验"></a>登录权限校验</h4><p>在应用中，通常会有以下的场景，比如商城：有些页面是不需要登录即可访问的，如首页，商品详情页等，都是用户在任何情况都能看到的；但是也有是需要登录后才能访问的，如个人中心，购物车等。此时就需要对页面访问进行控制了。</p><p>此外，像一些需要记录用户信息和登录状态的项目，也是需要做登录权限校验的，以防别有用心的人通过直接访问页面的 url 打开页面。</p><p>此时。路由守卫可以帮助我们做登录校验。具体如下：</p><p>1、配置路由的 meta 对象的 auth 属性</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  {</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Home.vue'</span>),</span><br><span class="line">    meta: { <span class="attr">title</span>: <span class="string">'首页'</span>, <span class="attr">keepAlive</span>: <span class="literal">false</span>, <span class="attr">auth</span>: <span class="literal">false</span> },</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    path: <span class="string">'/mine'</span>,</span><br><span class="line">    name: <span class="string">'mine'</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/mine.vue'</span>),</span><br><span class="line">    meta: { <span class="attr">title</span>: <span class="string">'我的'</span>, <span class="attr">keepAlive</span>: <span class="literal">false</span>, <span class="attr">auth</span>: <span class="literal">true</span> },</span><br><span class="line">  },</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>2、在路由首页进行判断。当<code>to.meta.auth</code>为<code>true</code>(需要登录)，且不存在登录信息缓存时，需要重定向去登录页面</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> {</span><br><span class="line">  <span class="built_in">document</span>.title = to.meta.title</span><br><span class="line">  <span class="keyword">const</span> userInfo = sessionStorage.getItem(<span class="string">'userInfo'</span>) || <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (!userInfo &amp;&amp; to.meta.auth) {</span><br><span class="line">    next(<span class="string">'/login'</span>)</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    next()</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="页面缓存配置"><a href="#页面缓存配置" class="headerlink" title="页面缓存配置"></a>页面缓存配置</h4><p>项目中，总有一些页面我们是希望加载一次就缓存下来的，此时就用到 keep-alive 了。keep-alive 是 Vue 提供的一个抽象组件，用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在 v 页面渲染完毕后不会被渲染成一个 DOM 元素。</p><p>1、通过配置路由的 meta 对象的 keepAlive 属性值来区分页面是否需要缓存</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  {</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Home.vue'</span>),</span><br><span class="line">    meta: { <span class="attr">title</span>: <span class="string">'首页'</span>, <span class="attr">keepAlive</span>: <span class="literal">false</span>, <span class="attr">auth</span>: <span class="literal">false</span> },</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    path: <span class="string">'/list'</span>,</span><br><span class="line">    name: <span class="string">'list'</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/list.vue'</span>),</span><br><span class="line">    meta: { <span class="attr">title</span>: <span class="string">'列表页'</span>, <span class="attr">keepAlive</span>: <span class="literal">true</span>, <span class="attr">auth</span>: <span class="literal">false</span> },</span><br><span class="line">  },</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>2、在 app.vue 做缓存判断</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">"!$route.meta.keepAlive"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">"$route.meta.keepAlive"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="多环境变量配置"><a href="#多环境变量配置" class="headerlink" title="多环境变量配置"></a>多环境变量配置</h2><p>首先我们先来了解一下环境变量，一般情况下我们的项目会有三个环境，本地环境(development)，测试环境(test)，生产环境(production)，我们可以在项目根目录下建三个配置环境变量的文件<code>.env.development</code>，<code>.env.test</code>，<code>.env.production</code></p><p>环境变量文件中只包含环境变量的“键=值”对：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV = <span class="string">'production'</span></span><br><span class="line">VUE_APP_ENV = <span class="string">'production'</span> <span class="comment">// 只有VUE_APP开头的环境变量可以在项目代码中直接使用</span></span><br></pre></td></tr></tbody></table></figure><p>除了自定义的 VUE<em>APP</em>*变量之外，还有两个可用的变量：</p><ul><li>NODE_ENV : “development”、”production” 或 “test”中的一个。具体的值取决于应用运行的模式。</li><li>BASE_URL : 和 vue.config.js 中的 publicPath 选项相符，即你的应用会部署到的基础路径。</li></ul><p>下面开始配置我们的环境变量</p><p>1、在项目根目录中新建.env.*</p><ul><li>.env.development 本地开发环境配置</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV='development'</span><br><span class="line">VUE_APP_ENV = 'development'</span><br></pre></td></tr></tbody></table></figure><ul><li>env.staging 测试环境配置</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV='production'</span><br><span class="line">VUE_APP_ENV = 'staging'</span><br></pre></td></tr></tbody></table></figure><ul><li>env.production 正式环境配置</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV='production'</span><br><span class="line">VUE_APP_ENV = 'production'</span><br></pre></td></tr></tbody></table></figure><p>为了在不同环境配置更多的变量，我们在 src 文件下新建一个 config/index</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据环境引入不同配置 process.env.NODE_ENV</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./env.'</span> + process.env.VUE_APP_ENV)</span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></tbody></table></figure><p>在同级目录下新建 <code>env.development.js</code>，<code>env.test.js</code>，<code>env.production.js</code>，在里面配置需要的变量。<br>以 env.development.js 为例</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  baseUrl: <span class="string">'http://localhost:8089'</span>, <span class="comment">// 项目地址</span></span><br><span class="line">  baseApi: <span class="string">'https://www.mock.com/api'</span>, <span class="comment">// 本地api请求地址</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、配置打包命令</p><p>package.json 里的 scripts 不同环境的打包命令</p><ul><li>通过 npm run serve 启动本地</li><li>通过 npm run test 打包测试</li><li>通过 npm run build 打包正式</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: {</span><br><span class="line">  <span class="string">"dev"</span>: <span class="string">"vue-cli-service serve"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"vue-cli-service build"</span>,</span><br><span class="line">  <span class="string">"test"</span>: <span class="string">"vue-cli-service build --mode test"</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="vue-config-js-配置"><a href="#vue-config-js-配置" class="headerlink" title="vue.config.js 配置"></a>vue.config.js 配置</h2><p>vue-cli3 开始，新建的脚手架都需要我们在 vue.config.js 配置我们项目的东西。主要包括</p><ul><li>打包后文件输出位置</li><li>关闭生产环境 sourcemap</li><li>配置 rem 转化 px</li><li>配置 alias 别名</li><li>去除生产环境 console</li><li>跨域代理设置</li></ul><p>此外，还有很多属于优化打包的配置，后面会一一道来。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  publicPath: <span class="string">'./'</span>, <span class="comment">// 默认为'/'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将构建好的文件输出到哪里，本司要求</span></span><br><span class="line">  outputDir: <span class="string">'dist/static'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 放置生成的静态资源(js、css、img、fonts)的目录。</span></span><br><span class="line">  assetsDir: <span class="string">'static'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定生成的 index.html 的输出路径</span></span><br><span class="line">  indexPath: <span class="string">'index.html'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否使用包含运行时编译器的 Vue 构建版本。</span></span><br><span class="line">  runtimeCompiler: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  transpileDependencies: [],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果你不需要生产环境的 source map</span></span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置css</span></span><br><span class="line">  css: {</span><br><span class="line">    <span class="comment">// 是否使用css分离插件 ExtractTextPlugin</span></span><br><span class="line">    extract: <span class="literal">true</span>,</span><br><span class="line">    sourceMap: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// css预设器配置项</span></span><br><span class="line">    loaderOptions: {</span><br><span class="line">      postcss: {</span><br><span class="line">        plugins: [</span><br><span class="line">          <span class="built_in">require</span>(<span class="string">'postcss-px2rem'</span>)({</span><br><span class="line">            remUnit: <span class="number">100</span>,</span><br><span class="line">          }),</span><br><span class="line">        ],</span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">    <span class="comment">// 启用 CSS modules for all css / pre-processor files.</span></span><br><span class="line">    modules: <span class="literal">false</span>,</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是一个函数，允许对内部的 webpack 配置进行更细粒度的修改。</span></span><br><span class="line">  chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">// 配置别名</span></span><br><span class="line">    config.resolve.alias</span><br><span class="line">      .set(<span class="string">'@'</span>, resolve(<span class="string">'src'</span>))</span><br><span class="line">      .set(<span class="string">'assets'</span>, resolve(<span class="string">'src/assets'</span>))</span><br><span class="line">      .set(<span class="string">'components'</span>, resolve(<span class="string">'src/components'</span>))</span><br><span class="line">      .set(<span class="string">'views'</span>, resolve(<span class="string">'src/views'</span>))</span><br><span class="line"></span><br><span class="line">    config.optimization.minimizer(<span class="string">'terser'</span>).tap(<span class="function">(<span class="params">args</span>) =&gt;</span> {</span><br><span class="line">      <span class="comment">// 去除生产环境console</span></span><br><span class="line">      args[<span class="number">0</span>].terserOptions.compress.drop_console = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span> args</span><br><span class="line">    })</span><br><span class="line">  },</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。</span></span><br><span class="line">  parallel: <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length &gt; <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  devServer: {</span><br><span class="line">    host: <span class="string">'0.0.0.0'</span>,</span><br><span class="line">    port: <span class="number">8088</span>, <span class="comment">// 端口号</span></span><br><span class="line">    https: <span class="literal">false</span>, <span class="comment">// https:{type:Boolean}</span></span><br><span class="line">    open: <span class="literal">false</span>, <span class="comment">// 配置自动启动浏览器  open: 'Google Chrome'-默认启动谷歌</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置多个代理</span></span><br><span class="line">    proxy: {</span><br><span class="line">      <span class="string">'/api'</span>: {</span><br><span class="line">        target: <span class="string">'https://www.mock.com'</span>,</span><br><span class="line">        ws: <span class="literal">true</span>, <span class="comment">// 代理的WebSockets</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>, <span class="comment">// 允许websockets跨域</span></span><br><span class="line">        pathRewrite: {</span><br><span class="line">          <span class="string">'^/api'</span>: <span class="string">''</span>,</span><br><span class="line">        },</span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">  },</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="基础组件封装"><a href="#基础组件封装" class="headerlink" title="基础组件封装"></a>基础组件封装</h2><p>在开发项目过程中，通常会用到很多功能和设计相类似的组件，toast 和 dialog 组件基本是每一个移动端项目都会用到的。为了更好匹配自己公司的 UI 设计风格，我们没有直接用 vant 的 toast 和 dialog 组件，而是自己封装了类似的组件，可供直接调用，如：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$toast({ <span class="attr">msg</span>: <span class="string">'手机号码不能为空'</span> })</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$toast({</span><br><span class="line">  msg: <span class="string">'成功提示'</span>,</span><br><span class="line">  type: <span class="string">'success'</span>,</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$dialog({</span><br><span class="line">  title: <span class="string">'删除提示'</span>,</span><br><span class="line">  text: <span class="string">'是否确定删除此标签？'</span>,</span><br><span class="line">  showCancelBtn: <span class="literal">true</span>,</span><br><span class="line">  confirmText: <span class="string">'确认'</span>,</span><br><span class="line">  <span class="function"><span class="title">confirm</span>(<span class="params">content</span>)</span> {</span><br><span class="line">    alert(<span class="string">'删除成功'</span>)</span><br><span class="line">  },</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>效果图如下</p><p><img src="https://user-gold-cdn.xitu.io/2020/5/10/171fc7862c4a065f?w=1032&amp;h=523&amp;f=png&amp;s=70452"></p><h4 id="toast-传入参数"><a href="#toast-传入参数" class="headerlink" title="toast 传入参数"></a>toast 传入参数</h4><p><strong>Props</strong></p><table><thead><tr><th>name</th><th>type</th><th>default</th><th>description</th></tr></thead><tbody><tr><td>msg</td><td>String</td><td>‘’</td><td>弹窗提示语</td></tr><tr><td>type</td><td>String</td><td>‘’</td><td>弹窗类型：success(成功提示),fail(失败提示),warning(警告),loading(加载)</td></tr></tbody></table><h4 id="dialog-传入参数"><a href="#dialog-传入参数" class="headerlink" title="dialog 传入参数"></a>dialog 传入参数</h4><p><strong>Props</strong></p><table><thead><tr><th>name</th><th>type</th><th>default</th><th>description</th></tr></thead><tbody><tr><td>title</td><td>String</td><td>‘’</td><td>标题</td></tr><tr><td>text</td><td>String</td><td>‘’</td><td>文本内容</td></tr><tr><td>type</td><td>String</td><td>‘’</td><td>默认纯文本，input(输入框)</td></tr><tr><td>maxlength</td><td>Number</td><td>20</td><td>输入的最多字数</td></tr><tr><td>confirmText</td><td>String</td><td>确定</td><td>右边按钮</td></tr><tr><td>cancelText</td><td>String</td><td>取消</td><td>左边按钮</td></tr></tbody></table><p><strong>Events</strong></p><table><thead><tr><th>name</th><th>params</th><th>description</th></tr></thead><tbody><tr><td>confirm</td><td>null</td><td>选择后的回调</td></tr><tr><td>cancel</td><td>ull</td><td>取消后的回调</td></tr></tbody></table><h2 id="webpack-可视化分析"><a href="#webpack-可视化分析" class="headerlink" title="webpack 可视化分析"></a>webpack 可视化分析</h2><p>从这里开始，我们开始进行 webpack 优化打包。首先我们来分析一下 webpack 打包性能瓶颈，找出问题所在，然后才能对症下药。此时就用到 webpack-bundle-analyzer 了。<br>1、安装依赖</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-bundle-analyzer -D</span><br></pre></td></tr></tbody></table></figure><p>2、在 vue.config.js 配置</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> { BundleAnalyzerPlugin } = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>)</span><br><span class="line">configureWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) {</span><br><span class="line">    config.plugins.push(<span class="keyword">new</span> BundleAnalyzerPlugin())</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>打包后，我们可以看到这样一份依赖图</p><p><img src="https://user-gold-cdn.xitu.io/2020/5/10/171fc78ad5a37759?w=1909&amp;h=931&amp;f=png&amp;s=235323"></p><p>从以上的界面中，我们可以得到以下信息：</p><ul><li>打包出的文件中都包含了什么，以及模块之间的依赖关系</li><li>每个文件的大小在总体中的占比，找出较大的文件，思考是否有替换方案，是否使用了它包含了不必要的依赖？</li><li>是否有重复的依赖项，对此可以如何优化？</li><li>每个文件的压缩后的大小。</li></ul><h2 id="CDN-资源优化"><a href="#CDN-资源优化" class="headerlink" title="CDN 资源优化"></a>CDN 资源优化</h2><p>CDN 的全称是 <code>Content Delivery Network</code>，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。</p><p>随着项目越做越大，依赖的第三方 npm 包越来越多，构建之后的文件也会越来越大。再加上又是单页应用，这就会导致在网速较慢或者服务器带宽有限的情况出现长时间的白屏。此时我们可以使用 CDN 的方法，优化网络加载速度。</p><p>1、将 <code>vue、vue-router、vuex、axios</code> 这些 vue 全家桶的资源，全部改为通过 CDN 链接获取，在 <code>index.html</code> 里插入 相应链接。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.10/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vuex/3.1.0/vuex.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue-router/3.0.2/vue-router.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/element-ui/2.6.1/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>2、在 <code>vue.config.js</code> 配置 externals 属性</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line"> ···</span><br><span class="line">    externals: {</span><br><span class="line">      <span class="string">'vue'</span>: <span class="string">'Vue'</span>,</span><br><span class="line">      <span class="string">'vuex'</span>: <span class="string">'Vuex'</span>,</span><br><span class="line">      <span class="string">'vue-router'</span>: <span class="string">'VueRouter'</span>,</span><br><span class="line">      <span class="string">'axios'</span>:<span class="string">'axios'</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>3、卸载相关依赖的 npm 包</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall  vue vue-router vuex axios</span><br></pre></td></tr></tbody></table></figure><p>此时启动项目运行就可以了。我们在控制台就能发现项目加载了以上四个 CDN 资源。</p><p>不过现在有不少声音说，vue 全家桶加载 CDN 资源其实作用并不大，而且公共的 CDN 资源也没有 npm 包那么稳定，这个就见仁见智了。所以我在源码时新建的分支做这个优化。当项目较小的就不考虑 CDN 优化了。</p><p>当然，当引入其他较大第三方资源，比如 echarts，AMAP(高德地图)，采用 CDN 资源还是很有必要的。</p><h2 id="gZip-加速优化"><a href="#gZip-加速优化" class="headerlink" title="gZip 加速优化"></a>gZip 加速优化</h2><p>所有现代浏览器都支持 gzip 压缩，启用 gzip 压缩可大幅缩减传输资源大小，从而缩短资源下载时间，减少首次白屏时间，提升用户体验。</p><p>gzip 对基于文本格式文件的压缩效果最好（如：CSS、JavaScript 和 HTML），在压缩较大文件时往往可实现高达 70-90% 的压缩率，对已经压缩过的资源（如：图片）进行 gzip 压缩处理，效果很不好。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line">configureWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) {</span><br><span class="line">    config.plugins.push(</span><br><span class="line">      <span class="keyword">new</span> CompressionPlugin({</span><br><span class="line">        <span class="comment">// gzip压缩配置</span></span><br><span class="line">        test: <span class="regexp">/\.js$|\.html$|\.css/</span>, <span class="comment">// 匹配文件名</span></span><br><span class="line">        threshold: <span class="number">10240</span>, <span class="comment">// 对超过10kb的数据进行压缩</span></span><br><span class="line">        deleteOriginalAssets: <span class="literal">false</span>, <span class="comment">// 是否删除原文件</span></span><br><span class="line">      })</span><br><span class="line">    )</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="首页添加骨架屏"><a href="#首页添加骨架屏" class="headerlink" title="首页添加骨架屏"></a>首页添加骨架屏</h2><p>随着 SPA 在前端界的逐渐流行，单页面应用不可避免地给首页加载带来压力，此时良好的首页用户体验至关重要。很多 APP 采用了“骨架屏”的方式去展示未加载内容，给予了用户焕然一新的体验。</p><p>所谓的骨架屏，就是在页面内容未加载完成的时候，先使用一些图形进行占位，待内容加载完成之后再把它替换掉。在这个过程中用户会感知到内容正在逐渐加载并即将呈现，降低了“白屏”的不良体验。</p><p>本文采用vue-skeleton-webpack-plugin插件为单页面应用注入骨架屏。  </p><p>1、在src的common文件夹下面创建了Skeleton1.vue，Skeleton2.vue，具体的结构和样式自行设计，此处省略一万字。。。。</p><p>2、在同级目录下新建entry-skeleton.js</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Skeleton1 <span class="keyword">from</span> <span class="string">'./Skeleton1'</span></span><br><span class="line"><span class="keyword">import</span> Skeleton2 <span class="keyword">from</span> <span class="string">'./Skeleton2'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue({</span><br><span class="line">  components: {</span><br><span class="line">    Skeleton1,</span><br><span class="line">    Skeleton2</span><br><span class="line">  },</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;skeleton1 id="skeleton1" style="display:none"/&gt;</span></span><br><span class="line"><span class="string">      &lt;skeleton2 id="skeleton2" style="display:none"/&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>在vue.config.js下配置插件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SkeletonWebpackPlugin = <span class="built_in">require</span>(<span class="string">'vue-skeleton-webpack-plugin'</span>)</span><br><span class="line">configureWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> {</span><br><span class="line">  config.plugins.push(</span><br><span class="line">    <span class="keyword">new</span> SkeletonWebpackPlugin({</span><br><span class="line">      webpackConfig: {</span><br><span class="line">        entry: {</span><br><span class="line">          app: path.join(__dirname, <span class="string">'./src/common/entry-skeleton.js'</span>),</span><br><span class="line">        },</span><br><span class="line">      },</span><br><span class="line">      minimize: <span class="literal">true</span>,</span><br><span class="line">      quiet: <span class="literal">true</span>,</span><br><span class="line">      router: {</span><br><span class="line">        mode: <span class="string">'hash'</span>,</span><br><span class="line">        routes: [</span><br><span class="line">          { <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">skeletonId</span>: <span class="string">'skeleton1'</span> },</span><br><span class="line">          { <span class="attr">path</span>: <span class="string">'/about'</span>, <span class="attr">skeletonId</span>: <span class="string">'skeleton2'</span> },</span><br><span class="line">        ],</span><br><span class="line">      },</span><br><span class="line">    })</span><br><span class="line">  )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时重新加载页面就可以看到我们的骨架屏了。<strong>注意：一定要配置样式分离extract: true</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E6%80%BB%E7%BB%9318%E4%B8%AAwebpack%E6%8F%92%E4%BB%B6/"/>
      <url>2020/12/29/%E6%80%BB%E7%BB%9318%E4%B8%AAwebpack%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h1><p>何为插件(Plugin)？专注处理 webpack 在编译过程中的某个特定的任务的功能模块，可以称为插件。plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。</p><p>Plugin 的特点</p><ul><li>是一个独立的模块</li><li>模块对外暴露一个 js 函数</li><li>函数的原型 <code>(prototype)</code> 上定义了一个注入 <code>compiler</code> 对象的 <code>apply</code>方法 <code>apply</code> 函数中需要有通过 <code>compiler</code> 对象挂载的 <code>webpack</code> 事件钩子，钩子的回调中能拿到当前编译的 <code>compilation</code> 对象，如果是异步编译插件的话可以拿到回调 <code>callback</code></li><li>完成自定义子编译流程并处理 <code>complition</code> 对象的内部数据</li><li>如果异步编译插件的话，数据处理完成后执行 <code>callback</code> 回调。</li></ul><p>下面介绍 18 个常用的 webpack 插件</p><h2 id="HotModuleReplacementPlugin"><a href="#HotModuleReplacementPlugin" class="headerlink" title="HotModuleReplacementPlugin"></a>HotModuleReplacementPlugin</h2><p>模块热更新插件。<code>Hot-Module-Replacement</code> 的热更新是依赖于 <code>webpack-dev-server</code>，后者是在打包文件改变时更新打包文件或者 reload 刷新整个页面，<code>HRM</code> 是只更新修改的部分。</p><p><code>HotModuleReplacementPlugin</code>是<code>webpack</code>模块自带的，所以引入<code>webpack</code>后，在<code>plugins</code>配置项中直接使用即可。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">// 热更新插件</span></span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h2 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h2><p>生成 html 文件。将 webpack 中<code>entry</code>配置的相关入口 <code>chunk</code> 和 <code>extract-text-webpack-plugin</code>抽取的 css 样式 插入到该插件提供的<code>template</code>或者<code>templateContent</code>配置项指定的内容基础上生成一个 html 文件，具体插入方式是将样式<code>link</code>插入到<code>head</code>元素中，<code>script</code>插入到<code>head</code>或者<code>body</code>中。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin({</span><br><span class="line">    filename: <span class="string">'index.html'</span>,</span><br><span class="line">    template: path.join(__dirname, <span class="string">'/index.html'</span>),</span><br><span class="line">    minify: {</span><br><span class="line">      <span class="comment">// 压缩HTML文件</span></span><br><span class="line">      removeComments: <span class="literal">true</span>, <span class="comment">// 移除HTML中的注释</span></span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>, <span class="comment">// 删除空白符与换行符</span></span><br><span class="line">      minifyCSS: <span class="literal">true</span>, <span class="comment">// 压缩内联css</span></span><br><span class="line">    },</span><br><span class="line">    inject: <span class="literal">true</span>,</span><br><span class="line">  }),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>inject 有四个选项值</p><ul><li>true：默认值，<code>script</code> 标签位于 <code>html</code> 文件的 <code>body</code> 底部</li><li>body：<code>script</code> 标签位于 <code>html</code> 文件的 <code>body</code> 底部（同 true）</li><li>head：<code>script</code> 标签位于 <code>head</code> 标签内</li><li>false：不插入生成的 js 文件，只是单纯的生成一个 <code>html</code> 文件</li></ul><p>多页应用打包</p><p>有时，我们的应用不一定是一个单页应用，而是一个多页应用，那么如何使用 webpack 进行打包呢。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  entry: {</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    login: <span class="string">'./src/login.js'</span>,</span><br><span class="line">  },</span><br><span class="line">  output: {</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[hash:6].js'</span>,</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin({</span><br><span class="line">      template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">    }),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin({</span><br><span class="line">      template: <span class="string">'./public/login.html'</span>,</span><br><span class="line">      filename: <span class="string">'login.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">    }),</span><br><span class="line">  ],</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果需要配置多个 <code>HtmlWebpackPlugin</code>，那么 <code>filename</code> 字段不可缺省，否则默认生成的都是 <code>index.html</code>。</p><p>但是有个问题，<code>index.html</code> 和 <code>login.html</code> 会发现，都同时引入了 <code>index.f7d21a.js</code> 和 <code>login.f7d21a.js</code>，通常这不是我们想要的，我们希望 <code>index.html</code> 中只引入 <code>index.f7d21a.js</code>，<code>login.html</code> 只引入 <code>login.f7d21a.js</code>。</p><p><code>HtmlWebpackPlugin</code> 提供了一个 <code>chunks</code> 的参数，可以接受一个数组，配置此参数仅会将数组中指定的 js 引入到 html 文件中</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin({</span><br><span class="line">      template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">      chunks: [<span class="string">'index'</span>],</span><br><span class="line">    }),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin({</span><br><span class="line">      template: <span class="string">'./public/login.html'</span>,</span><br><span class="line">      filename: <span class="string">'login.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">      chunks: [<span class="string">'login'</span>],</span><br><span class="line">    }),</span><br><span class="line">  ],</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样执行 <code>npm run build</code>，可以看到 <code>index.html</code> 中仅引入了 index 的 js 文件，而 <code>login.html</code> 中也仅引入了 login 的 js 文件。</p><h2 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h2><p><code>clean-webpack-plugin</code> 用于在打包前清理上一次项目生成的 bundle 文件，它会根据 <code>output.path</code> 自动清理文件夹；这个插件在生产环境用的频率非常高，因为生产环境经常会通过 hash 生成很多 bundle 文件，如果不进行清理的话每次都会生成新的，导致文件夹非常庞大。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> { CleanWebpackPlugin } = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin({</span><br><span class="line">    template: path.join(__dirname, <span class="string">'/index.html'</span>),</span><br><span class="line">  }),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">// 所要清理的文件夹名称</span></span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h2 id="extract-text-webpack-plugin"><a href="#extract-text-webpack-plugin" class="headerlink" title="extract-text-webpack-plugin"></a>extract-text-webpack-plugin</h2><p>将 css 成生文件，而非内联 。该插件的主要是为了抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="comment">// 将css分离到/dist文件夹下的css文件夹中的index.css</span></span><br><span class="line">  <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'css/index.css'</span>),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h2 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h2><p>将 CSS 提取为独立的文件的插件，对每个包含 css 的 js 文件都会创建一个 CSS 文件，支持按需加载 css 和 <code>sourceMap</code>。只能用在 webpack4 中，对比另一个插件 extract-text-webpack-plugin 有以下特点:</p><ul><li>异步加载</li><li>不重复编译，性能更好</li><li>更容易使用</li><li>只针对 CSS</li></ul><p>这个插件应该只用在生产环境配置，并且在 <code>loaders</code> 链中不使用 <code>style-loader</code>, 而且这个插件暂时不支持 HMR</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  <span class="built_in">module</span>: {</span><br><span class="line">    rules: [</span><br><span class="line">      {</span><br><span class="line">        test: <span class="regexp">/\.(le|c)ss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          {</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: {</span><br><span class="line">              publicPath: <span class="string">'../'</span>,</span><br><span class="line">            },</span><br><span class="line">          },</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span>,</span><br><span class="line">          <span class="string">'less-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      },</span><br><span class="line">    ],</span><br><span class="line">  },</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin({</span><br><span class="line">      filename: <span class="string">'css/[name].[contenthash:8].css'</span>,</span><br><span class="line">      chunkFilename: <span class="string">'css/[id].[contenthash:8].css'</span>,</span><br><span class="line">    }),</span><br><span class="line">  ],</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="purifycss-webpack"><a href="#purifycss-webpack" class="headerlink" title="purifycss-webpack"></a>purifycss-webpack</h2><p>有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> PurifyCssWebpack = <span class="built_in">require</span>(<span class="string">'purifycss-webpack'</span>) <span class="comment">// 引入PurifyCssWebpack插件</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>) <span class="comment">// 引入glob模块,用于扫描全部html文件中所引用的css</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, {</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> PurifyCssWebpack({</span><br><span class="line">      paths: glob.sync(path.join(__dirname, <span class="string">'src/*.html'</span>)),</span><br><span class="line">    }),</span><br><span class="line">  ],</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="optimize-css-assets-webpack-plugin"><a href="#optimize-css-assets-webpack-plugin" class="headerlink" title="optimize-css-assets-webpack-plugin"></a>optimize-css-assets-webpack-plugin</h2><p>我们希望减小 css 打包后的体积，可以用到 <code>optimize-css-assets-webpack-plugin</code>。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">"optimize-css-assets-webpack-plugin"</span>) <span class="comment">// 压缩css代码</span></span><br><span class="line"></span><br><span class="line">optimization: {</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="comment">// 压缩css</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCSSAssetsPlugin({})</span><br><span class="line">  ]</span><br></pre></td></tr></tbody></table></figure><h2 id="UglifyJsPlugin"><a href="#UglifyJsPlugin" class="headerlink" title="UglifyJsPlugin"></a>UglifyJsPlugin</h2><p><code>uglifyJsPlugin</code> 是 <code>vue-cli</code> 默认使用的压缩代码方式，用来对 js 文件进行压缩，从而减小 js 文件的大小，加速 load 速度。它使用的是单线程压缩代码，打包时间较慢，所以可以在开发环境将其关闭，生产环境部署时再把它打开。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> UglifyJsPlugin({</span><br><span class="line">    uglifyOptions: {</span><br><span class="line">      compress: {</span><br><span class="line">        warnings: <span class="literal">false</span></span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line">    sourceMap: <span class="literal">true</span>,  <span class="comment">//是否启用文件缓存</span></span><br><span class="line">    parallel: <span class="literal">true</span>   <span class="comment">//使用多进程并行运行来提高构建速度</span></span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure><h2 id="ParallelUglifyPlugin"><a href="#ParallelUglifyPlugin" class="headerlink" title="ParallelUglifyPlugin"></a>ParallelUglifyPlugin</h2><p>开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，每个子进程其实还是通过 <code>UglifyJS</code> 去压缩代码，但是变成了并行执行。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ParallelUglifyPlugin = <span class="built_in">require</span>(<span class="string">'webpack-parallel-uglify-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> ParallelUglifyPlugin({</span><br><span class="line">    <span class="comment">//cacheDir 用于配置缓存存放的目录路径。</span></span><br><span class="line">    cacheDir: <span class="string">'.cache/'</span>,</span><br><span class="line">    sourceMap: <span class="literal">true</span>,</span><br><span class="line">    uglifyJS: {</span><br><span class="line">      output: {</span><br><span class="line">        comments: <span class="literal">false</span>,</span><br><span class="line">      },</span><br><span class="line">      compress: {</span><br><span class="line">        warnings: <span class="literal">false</span>,</span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">  }),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h2 id="terser-webpack-plugin"><a href="#terser-webpack-plugin" class="headerlink" title="terser-webpack-plugin"></a>terser-webpack-plugin</h2><p>Webpack4.0 默认是使用 <code>terser-webpack-plugin</code> 这个压缩插件，在此之前是使用 <code>uglifyjs-webpack-plugin</code>，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 <code>parallel</code> 参数，使用多进程压缩，加快压缩。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>) <span class="comment">// 压缩js代码</span></span><br><span class="line"></span><br><span class="line">optimization: {</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="keyword">new</span> TerserPlugin({</span><br><span class="line">      parallel: <span class="number">4</span>, <span class="comment">// 开启几个进程来处理压缩，默认是 os.cpus().length - 1</span></span><br><span class="line">      cache: <span class="literal">true</span>, <span class="comment">// 是否缓存</span></span><br><span class="line">      sourceMap: <span class="literal">false</span>,</span><br><span class="line">    }),</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="NoErrorsPlugin"><a href="#NoErrorsPlugin" class="headerlink" title="NoErrorsPlugin"></a>NoErrorsPlugin</h2><p>报错但不退出 webpack 进程。编译出现错误时，使用 <code>NoEmitOnErrorsPlugin</code> 来跳过输出阶段。这样可以确保输出资源不会包含错误。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins: [<span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin()]</span><br></pre></td></tr></tbody></table></figure><h2 id="compression-webpack-plugin"><a href="#compression-webpack-plugin" class="headerlink" title="compression-webpack-plugin"></a>compression-webpack-plugin</h2><p>所有现代浏览器都支持 <code>gzip</code> 压缩，启用 <code>gzip</code> 压缩可大幅缩减传输资源大小，从而缩短资源下载时间，减少首次白屏时间，提升用户体验。</p><p>gzip 对基于文本格式文件的压缩效果最好（如：CSS、JavaScript 和 HTML），在压缩较大文件时往往可实现高达 70-90% 的压缩率，对已经压缩过的资源（如：图片）进行 gzip 压缩处理，效果很不好。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> CompressionPlugin({</span><br><span class="line">    <span class="comment">// gzip压缩配置</span></span><br><span class="line">    test: <span class="regexp">/\.js$|\.html$|\.css/</span>, <span class="comment">// 匹配文件名</span></span><br><span class="line">    threshold: <span class="number">10240</span>, <span class="comment">// 对超过10kb的数据进行压缩</span></span><br><span class="line">    deleteOriginalAssets: <span class="literal">false</span>, <span class="comment">// 是否删除原文件</span></span><br><span class="line">  }),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>当然，这个方法还需要后端配置支持。</p><h2 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h2><p>我们可以通过 <code>DefinePlugin</code> 可以定义一些全局的变量，我们可以在模块当中直接使用这些变量，无需作任何声明，<code>DefinePlugin</code> 是 <code>webpack</code> 自带的插件。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.DefinePlugin({</span><br><span class="line">    DESCRIPTION: <span class="string">'This Is The Test Text.'</span>,</span><br><span class="line">  }),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接引用</span></span><br><span class="line"><span class="built_in">console</span>.log(DESCRIPTION)</span><br></pre></td></tr></tbody></table></figure><h2 id="ProvidePlugin"><a href="#ProvidePlugin" class="headerlink" title="ProvidePlugin"></a>ProvidePlugin</h2><p>自动加载模块。 任何时候，当 <code>identifier</code> 被当作未赋值的变量时， module 就会自动被加载，并且 <code>identifier</code> 会被这个 module 输出的内容所赋值。这是 webpack 自带的插件。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  resolve: {</span><br><span class="line">    alias: {</span><br><span class="line">      jquery: <span class="string">'./lib/jquery'</span>,</span><br><span class="line">    },</span><br><span class="line">  },</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">//提供全局的变量，在模块中使用无需用require引入</span></span><br><span class="line">    <span class="keyword">new</span> webpack.ProvidePlugin({</span><br><span class="line">      $: <span class="string">'jquery'</span>,</span><br><span class="line">      React: <span class="string">'react'</span>,</span><br><span class="line">    }),</span><br><span class="line">  ],</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="DLLPlugin"><a href="#DLLPlugin" class="headerlink" title="DLLPlugin"></a>DLLPlugin</h2><p>这是在一个额外的独立的 webpack 设置中创建一个只有 dll 的 <code>bundle(dll-only-bundle)</code>。 这个插件会生成一个名为 <code>manifest.json</code> 的文件，这个文件是用来让 <code>DLLReferencePlugin</code> 映射到相关的依赖上去的。</p><p><strong>使用步骤如下</strong></p><p>1、在 build 下创建 <code>webpack.dll.config.js</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  entry: {</span><br><span class="line">    vendor: [</span><br><span class="line">      <span class="string">'vue-router'</span>,</span><br><span class="line">      <span class="string">'vuex'</span>,</span><br><span class="line">      <span class="string">'vue/dist/vue.common.js'</span>,</span><br><span class="line">      <span class="string">'vue/dist/vue.js'</span>,</span><br><span class="line">      <span class="string">'vue-loader/lib/component-normalizer.js'</span>,</span><br><span class="line">      <span class="string">'vue'</span>,</span><br><span class="line">      <span class="string">'axios'</span>,</span><br><span class="line">      <span class="string">'echarts'</span>,</span><br><span class="line">    ],</span><br><span class="line">  },</span><br><span class="line">  output: {</span><br><span class="line">    path: path.resolve(<span class="string">'./dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">    library: <span class="string">'[name]_library'</span>,</span><br><span class="line">  },</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin({</span><br><span class="line">      path: path.resolve(<span class="string">'./dist'</span>, <span class="string">'[name]-manifest.json'</span>),</span><br><span class="line">      name: <span class="string">'[name]_library'</span>,</span><br><span class="line">    }),</span><br><span class="line">    <span class="comment">// 建议加上代码压缩插件，否则dll包会比较大。</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin({</span><br><span class="line">      compress: {</span><br><span class="line">        warnings: <span class="literal">false</span>,</span><br><span class="line">      },</span><br><span class="line">    }),</span><br><span class="line">  ],</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、在 <code>webpack.prod.conf.js</code> 的 plugin 后面加入配置</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DllReferencePlugin({</span><br><span class="line">  manifest: <span class="built_in">require</span>(<span class="string">'../dist/vendor-manifest.json'</span>),</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>3、<code>package.json</code>文件中添加快捷命令<code>(build:dll)</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: {</span><br><span class="line">  <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js"</span>,</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"npm run dev"</span>,</span><br><span class="line">  <span class="string">"lint"</span>: <span class="string">"eslint --ext .js,.vue src"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"node build/build.js"</span>,</span><br><span class="line">  <span class="string">"build:dll"</span>: <span class="string">"webpack --config build/webpack.dll.conf.js"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>生产环境打包的时候先<code>npm run build:dll</code>命令会在打包目录下生成 <code>vendor-manifest.json</code> 文件与 vendor.dll.js 文件。然后<code>npm run build</code>生产其他文件。</p><p>4、根目录下的入口 <code>index.html</code> 加入引用</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./vendor.dll.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h2><p><code>HappyPack</code> 能让 webpack 把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。要注意的是 <code>HappyPack</code> 对 <code>file-loader</code>、<code>url-loader</code> 支持的不友好，所以不建议对该 loader 使用。</p><p>1、HappyPack 插件安装</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D happypack</span><br></pre></td></tr></tbody></table></figure><p>2、<code>webpack.base.conf.js</code> 文件对 module.rules 进行配置</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: {</span><br><span class="line">  rules: [</span><br><span class="line">    {</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: [<span class="string">'happypack/loader?id=babel'</span>],</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>), resolve(<span class="string">'test'</span>)],</span><br><span class="line">      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>),</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">      test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">      use: [<span class="string">'happypack/loader?id=vue'</span>],</span><br><span class="line">    },</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3、在生产环境 <code>webpack.prod.conf.js</code> 文件进行配置</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>)</span><br><span class="line"><span class="comment">// 构造出共享进程池，在进程池中包含5个子进程</span></span><br><span class="line"><span class="keyword">const</span> HappyPackThreadPool = HappyPack.ThreadPool({ <span class="attr">size</span>: <span class="number">5</span> })</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HappyPack({</span><br><span class="line">    <span class="comment">// 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件</span></span><br><span class="line">    id: <span class="string">'babel'</span>,</span><br><span class="line">    <span class="comment">// 如何处理.js文件，用法和Loader配置中一样</span></span><br><span class="line">    loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">    threadPool: HappyPackThreadPool,</span><br><span class="line">  }),</span><br><span class="line">  <span class="keyword">new</span> HappyPack({</span><br><span class="line">    id: <span class="string">'vue'</span>, <span class="comment">// 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件</span></span><br><span class="line">    loaders: [</span><br><span class="line">      {</span><br><span class="line">        loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">        options: vueLoaderConfig,</span><br><span class="line">      },</span><br><span class="line">    ],</span><br><span class="line">    threadPool: HappyPackThreadPool,</span><br><span class="line">  }),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p><strong>注意，当项目较小时，多线程打包反而会使打包速度变慢。</strong></p><h2 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h2><p>我们在 <code>public/index.html</code> 中引入了静态资源，但是打包的时候 webpack 并不会帮我们拷贝到 dist 目录，因此 <code>copy-webpack-plugin</code> 就可以很好地帮我做拷贝的工作了。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin({</span><br><span class="line">      patterns: [</span><br><span class="line">        {</span><br><span class="line">          <span class="keyword">from</span>: <span class="string">'public/js/*.js'</span>,</span><br><span class="line">          to: path.resolve(__dirname, <span class="string">'dist'</span>, <span class="string">'js'</span>),</span><br><span class="line">          flatten: <span class="literal">true</span>,</span><br><span class="line">        },</span><br><span class="line">      ],</span><br><span class="line">    }),</span><br><span class="line">  ],</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="IgnorePlugin"><a href="#IgnorePlugin" class="headerlink" title="IgnorePlugin"></a>IgnorePlugin</h2><p>这是 webpack 内置插件，它的作用是：忽略第三方包指定目录，让这些指定目录不要被打包进去。</p><p>比如我们要使用 <code>moment</code> 这个第三方依赖库，该库主要是对时间进行格式化，并且支持多个国家语言。虽然我设置了语言为中文，但是在打包的时候，是会将所有语言都打包进去的。这样就导致包很大，打包速度又慢。对此，我们可以用 <code>IgnorePlugin</code> 使得指定目录被忽略，从而使得打包变快，文件变小。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="comment">//moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去</span></span><br><span class="line">  <span class="keyword">new</span> Webpack.IgnorePlugin(<span class="regexp">/\.\/locale/</span>, <span class="regexp">/moment/</span>),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>我们虽然按照上面的方法忽略了包含<code>’./locale/'</code>该字段路径的文件目录，但是也使得我们使用的时候不能显示中文语言了，所以这个时候可以手动引入中文语言的目录。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//手动引入所需要的语言包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'moment/locale/zh-cn'</span></span><br><span class="line"></span><br><span class="line">moment.locale(<span class="string">'zh-cn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = moment().endOf(<span class="string">'day'</span>).fromNow()</span><br><span class="line"><span class="built_in">console</span>.log(r)</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E5%88%B0%E4%BC%98%E5%8C%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BCvue-cli%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
      <url>2020/12/29/%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E5%88%B0%E4%BC%98%E5%8C%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BCvue-cli%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想必大多数人在开发 vue 等 SPA 项目都时候都会直接用 <code>vue-cli</code> 等脚手架开发，一是方便省去了好多配置上的功夫，二是 <code>vue-cli</code> 毕竟是久经考验较为成熟的东西，遇到问题也能在网上找到相应解决方案。</p><p>但是，如果我们要更好地理解脚手架的配置及其构建打包的机制，我们就有必要从零开始，依葫芦画瓢自己配置一个类似于 vue-cli 这样的项目了。在此，我做了以下简单配置，请各位大佬批评指正，并诚心希望能得到大佬的指点，解决文章最后关于 <code>Tree Shaking</code> 导致打包缺失 css 的问题。</p><p>本文主要包括如下配置：</p><ul><li>区分环境变量及合并配置</li><li><code>webpack-dev-server</code> 本地服务器 </li><li><code>HtmlWebpackPlugin</code> 生成 html</li><li><code>CleanWebpackPlugin</code> 清理文件夹</li><li><code>loader</code> 及 <code>babel</code> 配置</li><li><code>HotModuleReplacementPlugin</code> 热更新</li><li><code>postcss-loader</code> 增加 css 前缀</li><li><code>vue SPA</code> 引入及解析</li><li><code>vue-router</code> 安装与使用</li><li><code>mini-css-extract-plugin</code> 分离 css</li><li><code>purifycss-webpack purify-css</code> 消除冗余 css</li><li><code>optimize-css-assets-webpack-plugin</code> 压缩 css</li><li><code>terser-webpack-plugin</code> 压缩 js</li><li><code>splitChunks</code> 提取公共代码</li><li><code>image-webpack-loader</code> 图片压缩</li><li><code>gZip</code> 加速优化</li></ul><p>项目源码：<a href="https://github.com/Michael-lzg/webpack-vue-cli">https://github.com/Michael-lzg/webpack-vue-cli</a></p><p>如果对 webpack 基本配置还不了解的小伙伴，可查看以下文章<br><a href="https://juejin.im/post/5db0fd1bf265da4d4216a9c5">从零开始构建一个 webpack 项目</a><br><a href="https://juejin.im/post/5eb766296fb9a0432f0ff8c7#heading-19">搭建一个 vue-cli4+webpack 移动端框架（开箱即用）</a></p><p>废话不多说，老司机带你立刻上路。</p><h3 id="搭建-webpack-项目框架"><a href="#搭建-webpack-项目框架" class="headerlink" title="搭建 webpack 项目框架"></a>搭建 webpack 项目框架</h3><h4 id="构建项目结构"><a href="#构建项目结构" class="headerlink" title="构建项目结构"></a>构建项目结构</h4><ol><li><p>创建 <code>webpack-vue-cli</code> 文件夹，<code>npm-init-y</code> 初始化项目</p></li><li><p>安装 webpack 相关依赖</p></li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli webpack-dev-server webpack-merge --save-dev</span><br></pre></td></tr></tbody></table></figure><p>如果 <code>webpack</code> 和 <code>webpack-cli</code> 没有全局安装的话，要先全局安装</p><ol start="3"><li>建立项目文件夹</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── src   <span class="comment">// webpack配置文件</span></span><br><span class="line">    |——main.js  <span class="comment">// 入口文件</span></span><br><span class="line">├── <span class="keyword">static</span>   <span class="comment">// 项目打包路径</span></span><br><span class="line">├── index.html   <span class="comment">// 模板html</span></span><br><span class="line">├── webpack.base.js   <span class="comment">// 打包基本配置</span></span><br><span class="line">├── webpack.dev.js   <span class="comment">// 本地环境配置</span></span><br><span class="line">├── webpack.prod.js   <span class="comment">// 生产环境配置</span></span><br></pre></td></tr></tbody></table></figure><p><code>index.html</code> 和 <code>main.js</code> 的代码不多说，直接进入 webpack 配置环节。</p><h4 id="区分环境"><a href="#区分环境" class="headerlink" title="区分环境"></a>区分环境</h4><p>为了更好的优化打包，我们将 webpack 的配置分开开发环境和生产环境。</p><ul><li>webpack.base.js 公共配置文件</li><li>webpack.dev.js 开发环境的配置文件</li><li>webpack.prod.js 生产环境的配置文件</li></ul><p>在 <code>webpack.dev.js</code> 和 <code>webpack.prod.js</code>，我们可以利用 <code>webpack-merge</code> 进行配置的合并。</p><p>然后，我们在 package.json 定义不同环境的打包命令</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: {</span><br><span class="line">  <span class="string">"dev"</span>: <span class="string">"webpack-dev-server  --config webpack.dev.js --mode development"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"webpack --config webpack.prod.js"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="公共配置"><a href="#公共配置" class="headerlink" title="公共配置"></a>公共配置</h4><p>我们先来看一下 <code>webpack.base.js</code> 的公共配置，定义好入口文件和出口文件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  entry: {</span><br><span class="line">    index: path.join(__dirname, <span class="string">'/src/main.js'</span>),</span><br><span class="line">  },</span><br><span class="line">  output: {</span><br><span class="line">    path: path.join(__dirname, <span class="string">'/dist'</span>), <span class="comment">//打包后的文件存放的地方</span></span><br><span class="line">    filename: <span class="string">'js/[name].[hash].js'</span>, <span class="comment">// 每次保存 hash 都变化</span></span><br><span class="line">  },</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>webpack 提供了一个可选的本地开发服务器，这个本地服务器基于 <code>node.js</code> 构建，所以在 <code>webpack.dev.js</code> 进行配置</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>) <span class="comment">// 引入webpack-merge功能模块</span></span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">'./webpack.base.js'</span>) <span class="comment">// 引入webpack.common.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, {</span><br><span class="line">  <span class="comment">// 将webpack.common.js合并到当前文件</span></span><br><span class="line">  devServer: {</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>, <span class="comment">// 本地服务器所加载文件的目录</span></span><br><span class="line">    port: <span class="string">'8899'</span>, <span class="comment">// 设置端口号为8088</span></span><br><span class="line">    inline: <span class="literal">true</span>, <span class="comment">// 文件修改后实时刷新</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>, <span class="comment">//不跳转</span></span><br><span class="line">    hot: <span class="literal">true</span>, <span class="comment">// 热更新</span></span><br><span class="line">  },</span><br><span class="line">  mode: <span class="string">'development'</span>, <span class="comment">// 设置mode</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h4><p><code>HtmlWebpackPlugin</code> 简化了 HTML 文件的创建，它可以根据 html 模板在打包后自动为你生产打包后的 html 文件。这对于在文件名中包含每次会随着编译而发生变化哈希的<code>bundle</code>。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin({</span><br><span class="line">    template: path.join(__dirname, <span class="string">'/index.html'</span>), <span class="comment">// new一个这个插件的实例，并传入相关的参数</span></span><br><span class="line">  }),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>至此就搭建好一个乞丐版的 <code>webpack</code> 项目了，你可以随意编写代码，分别在开发环境和生产环境执行命令查看效果。</p><h4 id="loader-配置"><a href="#loader-配置" class="headerlink" title="loader 配置"></a>loader 配置</h4><p><code>loader</code> 可以让 <code>webpack</code> 能够去处理那些非 <code>javaScript</code> 文件（<code>webpack</code> 自身只理解 <code>javaScript</code>）。<code>loader</code> 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p><p>对于 <code>loader</code> 的科普和配置，在这里不做一一说明，直接奉上代码，分别是处理样式，<code>js</code> 和文件的 <code>loader</code>。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: {</span><br><span class="line">  rules: [</span><br><span class="line">    {</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则匹配以.css结尾的文件</span></span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">      test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>],</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">      test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: {</span><br><span class="line">        limit: <span class="number">10000</span>,</span><br><span class="line">        name: utils.assetsPath(<span class="string">'img/[name].[hash:7].[ext]'</span>),</span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了更方便的配置和优化 <code>babel-loader</code>，我们可以将其提取出来，在根目录下新建 <code>.babelrc</code> 文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  "presets": ["env"]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="CleanWebpackPlugin"><a href="#CleanWebpackPlugin" class="headerlink" title="CleanWebpackPlugin"></a>CleanWebpackPlugin</h4><p>在每次构建前清理/dist 文件夹，生产最新的打包文件，这时候就用到 <code>CleanWebpackPlugin</code> 插件了。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin({</span><br><span class="line">    template: path.join(__dirname, <span class="string">'/index.html'</span>), <span class="comment">// new一个这个插件的实例，并传入相关的参数</span></span><br><span class="line">  }),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">// 所要清理的文件夹名称</span></span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h4 id="HotModuleReplacementPlugin"><a href="#HotModuleReplacementPlugin" class="headerlink" title="HotModuleReplacementPlugin"></a>HotModuleReplacementPlugin</h4><p><code>HotModuleReplacementPlugin</code>（HMR）是一个很实用的插件，可以在我们修改代码后自动刷新预览效果，在开发环境使用。</p><ol><li><p><code>devServer</code> 配置项中设置 <code>hot: true</code></p></li><li><p><code>HotModuleReplacementPlugin</code> 是 webpack 模块自带的，所以引入 webpack 后，在 <code>plugins</code> 配置项中直接使用即可。</p></li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">// 热更新插件</span></span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h4 id="增加-css-前缀"><a href="#增加-css-前缀" class="headerlink" title="增加 css 前缀"></a>增加 css 前缀</h4><p>平时我们写 css 时，一些属性需要手动加上前缀，比如<code>-webkit-border-radius: 10px;</code>，在 webpack 中我们可以让他自动加上</p><ol><li>安装依赖</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i postcss-loader autoprefixer -D</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>在项目根目录下新建 <code>postcss.config.js</code> 文件</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>), <span class="comment">// 引用autoprefixer模块</span></span><br><span class="line">  ],</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>修改样式 loader</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  {</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则匹配以.css结尾的文件</span></span><br><span class="line">    use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>],</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>, <span class="string">'less-loader'</span>],</span><br><span class="line">  },</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>至此，一个 webpack 项目基本搭建而成，下面介绍 vue 的引用和项目优化。</p><h3 id="搭建-vue-SPA-模板"><a href="#搭建-vue-SPA-模板" class="headerlink" title="搭建 vue SPA 模板"></a>搭建 vue SPA 模板</h3><h4 id="vue-SPA"><a href="#vue-SPA" class="headerlink" title="vue SPA"></a>vue SPA</h4><p>1、搭建一个类似于 <code>vue-cli</code> 的脚手架，首先我们来依葫芦画瓢，在 <code>main.js</code> 写上一下代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">new</span> Vue({</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>2、然后在 src 文件夹下新建 <code>APP.vue</code></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>SPA项目<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>3、安装相关依赖</p><p>到这里，我们 <code>npm run dev</code> 试一下就报错了。因为我们没有安装相关依赖，下面我们下来安装一下依赖</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue vue-loader vue-template-compiler -D</span><br></pre></td></tr></tbody></table></figure><ul><li>vue: vue 的源码</li><li>vue-loader：解析.vue 文件</li><li>vue-template-compiler： 编译 vue</li></ul><p>4、在 webpack 配置 vue-loader</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  <span class="built_in">module</span>: {</span><br><span class="line">    rules: [</span><br><span class="line">      {</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">      },</span><br><span class="line">    ],</span><br><span class="line">  },</span><br><span class="line">  plugins: [<span class="keyword">new</span> VueLoaderPlugin()],</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h4><p>1、安装依赖</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router -D</span><br></pre></td></tr></tbody></table></figure><p>2、在 src 文件夹下新建 router/index</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router({</span><br><span class="line">  routes: [</span><br><span class="line">    {</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Home.vue'</span>),</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">      path: <span class="string">'/admin'</span>,</span><br><span class="line">      component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/admin.vue'</span>),</span><br><span class="line">    },</span><br><span class="line">  ],</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></tbody></table></figure><p>3、在 main.js 引用</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue({</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>就这样，一个类似于 <code>vue-cli</code> 的脚手架就搭建好了，你可以愉快地写 <code>.vue</code> 文件进行 SPA 开发。</p><h3 id="webpack-优化打包"><a href="#webpack-优化打包" class="headerlink" title="webpack 优化打包"></a>webpack 优化打包</h3><h4 id="分离-css"><a href="#分离-css" class="headerlink" title="分离 css"></a>分离 css</h4><p>虽然 webpack 的理念是把 css、js 全都打包到一个文件里，但要是我们想把 css 分离出来，这里我们用到 <code>mini-css-extract-plugin</code>。对比另一个插件 <code>extract-text-webpack-plugin</code>，它有以下优点:</p><ul><li>异步加载</li><li>不重复编译，性能更好</li><li>更容易使用</li><li>只针对 CSS</li></ul><p>但是<code>mini-css-extract-plugin</code> 不支持 <code>HMR</code>，所以我们只能在生产环境使用它。</p><p>1、安装依赖</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mini-css-extract-plugin -D</span><br></pre></td></tr></tbody></table></figure><p>2、在<code>webpack.prod.js</code> 配置 <code>loader</code> 和 <code>plugin</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: {</span><br><span class="line">  rules: [</span><br><span class="line">    {</span><br><span class="line">      test: <span class="regexp">/\.(le|c)ss$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        {</span><br><span class="line">          loader: MiniCssExtractPlugin.loader,</span><br><span class="line">          options: {</span><br><span class="line">            publicPath: <span class="string">'../'</span></span><br><span class="line">          },</span><br><span class="line">        },</span><br><span class="line">        <span class="string">'css-loader'</span>,</span><br><span class="line">        <span class="string">'postcss-loader'</span>,</span><br><span class="line">        <span class="string">'less-loader'</span>,</span><br><span class="line">      ]</span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">},</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> MiniCssExtractPlugin({</span><br><span class="line">    filename: <span class="string">"css/[name].[contenthash:8].css"</span>,</span><br><span class="line">    chunkFilename: <span class="string">'css/[id].[contenthash:8].css'</span></span><br><span class="line">  })</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>分离 css 需要将 <code>css loader</code> 中的 <code>style-loader</code> 替换为 <code>MiniCssExtractPlugin</code></p><h4 id="消除冗余-css"><a href="#消除冗余-css" class="headerlink" title="消除冗余 css"></a>消除冗余 css</h4><p>有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。</p><p>1、安装依赖</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i purifycss-webpack purify-css glob -D</span><br></pre></td></tr></tbody></table></figure><p>2、webpack.prod.js 配置</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> PurifyCssWebpack = <span class="built_in">require</span>(<span class="string">'purifycss-webpack'</span>) <span class="comment">// 引入PurifyCssWebpack插件</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>) <span class="comment">// 引入glob模块,用于扫描全部html文件中所引用的css</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, {</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> PurifyCssWebpack({</span><br><span class="line">      paths: glob.sync(path.join(__dirname, <span class="string">'src/*.html'</span>)),</span><br><span class="line">    }),</span><br><span class="line">  ],</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="压缩-css"><a href="#压缩-css" class="headerlink" title="压缩 css"></a>压缩 css</h4><p>我们希望减小 css 打包后的体积，可以用到 <code>optimize-css-assets-webpack-plugin</code>。<br>1、安装依赖</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install optimize-css-assets-webpack-plugin -D</span><br></pre></td></tr></tbody></table></figure><p>2、webpack.prod.js 配置</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">"optimize-css-assets-webpack-plugin"</span>) <span class="comment">// 压缩css代码</span></span><br><span class="line"></span><br><span class="line">optimization: {</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="comment">// 压缩css</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCSSAssetsPlugin({})</span><br><span class="line">  ]</span><br></pre></td></tr></tbody></table></figure><h4 id="压缩-js"><a href="#压缩-js" class="headerlink" title="压缩 js"></a>压缩 js</h4><p>Webpack4.0 默认是使用 <code>terser-webpack-plugin</code> 这个压缩插件，在此之前是使用 <code>uglifyjs-webpack-plugin</code>，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 <code>parallel</code> 参数，使用多进程压缩，加快压缩。</p><p>1、安装依赖</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install terser-webpack-plugin -D</span><br></pre></td></tr></tbody></table></figure><p>2、webpack.prod.js 配置</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>) <span class="comment">// 压缩js代码</span></span><br><span class="line"></span><br><span class="line">optimization: {</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="keyword">new</span> TerserPlugin({</span><br><span class="line">      parallel: <span class="number">4</span>, <span class="comment">// 开启几个进程来处理压缩，默认是 os.cpus().length - 1</span></span><br><span class="line">      cache: <span class="literal">true</span>, <span class="comment">// 是否缓存</span></span><br><span class="line">      sourceMap: <span class="literal">false</span>,</span><br><span class="line">    }),</span><br><span class="line">    <span class="comment">// 压缩css</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCSSAssetsPlugin({}),</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="提取公共代码"><a href="#提取公共代码" class="headerlink" title="提取公共代码"></a>提取公共代码</h4><p>在用 webpack 打包的时候，对于一些不经常更新的第三方库，比如 vue 全家桶的一些东西， 我们希望能和自己的代码分离开。webpack4 使用 <code>splitChunks</code> 的方法进行配置。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">optimization: {</span><br><span class="line">  <span class="comment">// 分离chunks</span></span><br><span class="line">  splitChunks: {</span><br><span class="line">    chunks: <span class="string">'all'</span>,</span><br><span class="line">    cacheGroups: {</span><br><span class="line">      vendor: {</span><br><span class="line">        name: <span class="string">"vendor"</span>,</span><br><span class="line">        test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">        priority: <span class="number">10</span>,</span><br><span class="line">        chunks: <span class="string">"initial"</span> <span class="comment">// 只打包初始时依赖的第三方</span></span><br><span class="line">      },</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h4><p>在项目中有些图片太大影响加载，我们用 <code>image-webpack-loader</code> 进行压缩。</p><p>1、安装依赖</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install image-webpack-loader -D</span><br></pre></td></tr></tbody></table></figure><p>2、配置 loader</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  test: <span class="regexp">/\.(png|jpg|svg|gif)$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    {</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: {</span><br><span class="line">        esModule: <span class="literal">false</span>,</span><br><span class="line">        limit: <span class="number">1000</span>,  <span class="comment">// 限制只有小于1kb的图片才转为base64</span></span><br><span class="line">        outputPath: <span class="string">'images'</span>, <span class="comment">// 设置打包后图片存放的文件夹名称</span></span><br><span class="line">        name: <span class="string">'[name][hash:8].[ext]'</span></span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">      loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">      options: {</span><br><span class="line">        <span class="comment">// 压缩 jpeg 的配置</span></span><br><span class="line">        mozjpeg: {</span><br><span class="line">          progressive: <span class="literal">true</span>,</span><br><span class="line">          quality: <span class="number">65</span></span><br><span class="line">        },</span><br><span class="line">        <span class="comment">// 使用 imagemin**-optipng 压缩 png，enable: false 为关闭</span></span><br><span class="line">        optipng: {</span><br><span class="line">          enabled: <span class="literal">false</span>,</span><br><span class="line">        },</span><br><span class="line">        <span class="comment">// // 使用 imagemin-pngquant 压缩 png</span></span><br><span class="line">        pngquant: {</span><br><span class="line">          quality: [<span class="number">0.65</span>, <span class="number">0.90</span>],</span><br><span class="line">          speed: <span class="number">4</span></span><br><span class="line">        },</span><br><span class="line">        <span class="comment">// 压缩 gif 的配置</span></span><br><span class="line">        gifsicle: {</span><br><span class="line">          interlaced: <span class="literal">false</span>,</span><br><span class="line">        },</span><br><span class="line">        <span class="comment">// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span></span><br><span class="line">        webp: {</span><br><span class="line">          quality: <span class="number">75</span></span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="gZip-加速优化"><a href="#gZip-加速优化" class="headerlink" title="gZip 加速优化"></a>gZip 加速优化</h4><p>所有现代浏览器都支持 <code>gzip</code> 压缩，启用 <code>gzip</code> 压缩可大幅缩减传输资源大小，从而缩短资源下载时间，减少首次白屏时间，提升用户体验。</p><p>gzip 对基于文本格式文件的压缩效果最好（如：CSS、JavaScript 和 HTML），在压缩较大文件时往往可实现高达 70-90% 的压缩率，对已经压缩过的资源（如：图片）进行 gzip 压缩处理，效果很不好。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line">configureWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) {</span><br><span class="line">    config.plugins.push(</span><br><span class="line">      <span class="keyword">new</span> CompressionPlugin({</span><br><span class="line">        <span class="comment">// gzip压缩配置</span></span><br><span class="line">        test: <span class="regexp">/\.js$|\.html$|\.css/</span>, <span class="comment">// 匹配文件名</span></span><br><span class="line">        threshold: <span class="number">10240</span>, <span class="comment">// 对超过10kb的数据进行压缩</span></span><br><span class="line">        deleteOriginalAssets: <span class="literal">false</span>, <span class="comment">// 是否删除原文件</span></span><br><span class="line">      })</span><br><span class="line">    )</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="tree-shaking（求助，生产环境打包生成不了样式）"><a href="#tree-shaking（求助，生产环境打包生成不了样式）" class="headerlink" title="tree-shaking（求助，生产环境打包生成不了样式）"></a>tree-shaking（求助，生产环境打包生成不了样式）</h3><p>按以上的方式构建项目，在开发环境一直都是顺顺利利的，然而一执行 <code>npm run build</code>，打开页面，发现样式全都缺失了。打开 <code>dist/css</code> 文件夹，发现三个 css 文件，只有 <code>index.css</code> 有部分文件（是 main.js 引入额初始化样式，但也是不全的），另外两个 css 文件则是空空如也，也就是.vue 里面的样式全都缺失了。</p><p>查看资源，初步判断为 webpack4 默认使用 <code>tree-shaking</code>，会把 <strong>在模块的层面上做到打包后的代码只包含被引用并被执行的模块，而不被引用或不被执行的模块被删除掉，以起到减包的效果</strong>。但是我已经按相关资源在 <code>package.json</code> 配置了 <code>sideEffects</code> 了，但是还是没用，实在苦恼！！！</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"sideEffects"</span>: [</span><br><span class="line">    <span class="string">"*.less"</span>,</span><br><span class="line">    <span class="string">"*.css"</span>,</span><br><span class="line">    <span class="string">"*.vue"</span></span><br><span class="line">  ]</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAwbpack%E9%A1%B9%E7%9B%AE/"/>
      <url>2020/12/29/%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAwbpack%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="从零构建一个wbpack项目"><a href="#从零构建一个wbpack项目" class="headerlink" title="从零构建一个wbpack项目"></a>从零构建一个wbpack项目</h1><h3 id="1、新建项目"><a href="#1、新建项目" class="headerlink" title="1、新建项目"></a>1、新建项目</h3><p>新建一个空文件夹，用于创建项目，使用 npm init 命令创建一个 package.json 文件。<br>输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，也可以使用 npm init -y 这个命令来一次生成 package.json 文件，这样终端不会询问你问题。</p><h3 id="2、安装-webpack"><a href="#2、安装-webpack" class="headerlink" title="2、安装 webpack"></a>2、安装 webpack</h3><p>安装 webapck 时把 webpack-cli 也装上是因为在 webpack4.x 版本后 webpack 模块把一些功能分到了 webpack-cli 模块，所以两者都需要安装，安装方法如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --<span class="built_in">global</span>    <span class="comment">//这是安装全局webpack及webpack-cli模块</span></span><br><span class="line">npm install webpack webpack-cli --save-dev  <span class="comment">//这是安装本地项目模块</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3、新建文件"><a href="#3、新建文件" class="headerlink" title="3、新建文件"></a>3、新建文件</h3><p>在根目录件夹中新建两个文件夹，分别为 src 文件夹和 dist 文件夹，接下来再创建三个文件:此时，项目结构如下</p><ul><li>index.html –放在 dist 文件夹中；</li><li>hello.js –放在 src 文件夹中；</li><li>index.js –放在 src 文件夹中；</li></ul><h4 id="3-1、-index-html-中写下-html-代码，它的作用是为了引入我们打包后的-js-文件："><a href="#3-1、-index-html-中写下-html-代码，它的作用是为了引入我们打包后的-js-文件：" class="headerlink" title="3.1、 index.html 中写下 html 代码，它的作用是为了引入我们打包后的 js 文件："></a>3.1、 index.html 中写下 html 代码，它的作用是为了引入我们打包后的 js 文件：</h4><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack Project<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这是打包之后的js文件，我们暂时命名为bundle.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="3-2、在-hello-js-中导出一个模块："><a href="#3-2、在-hello-js-中导出一个模块：" class="headerlink" title="3.2、在 hello.js 中导出一个模块："></a>3.2、在 hello.js 中导出一个模块：</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">  hello.innerHTML = <span class="string">'welcome to China!'</span></span><br><span class="line">  <span class="keyword">return</span> hello</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3、在-index-js-中引入这个模块（hello-js）"><a href="#3-3、在-index-js-中引入这个模块（hello-js）" class="headerlink" title="3.3、在 index.js 中引入这个模块（hello.js）:"></a>3.3、在 index.js 中引入这个模块（hello.js）:</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">const</span> hello = <span class="built_in">require</span>(<span class="string">'./hello.js'</span>)</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>).appendChild(hello())</span><br></pre></td></tr></tbody></table></figure><p>上述操作就相当于我们把 hello.js 模块合并到了 index.js 模块，之后我们打包时就只需把 index.js 模块打包成 bundle.js 即可。</p><h4 id="3-4、进行最简单的-webpack-打包"><a href="#3-4、进行最简单的-webpack-打包" class="headerlink" title="3.4、进行最简单的 webpack 打包"></a>3.4、进行最简单的 webpack 打包</h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在终端中使用如下命令进行打包：</span></span><br><span class="line">webpack src/index.js --output dist/bundle.js</span><br></pre></td></tr></tbody></table></figure><p>上述就相当于把 src 文件夹下的 index.js 文件打包到 dist 文件下的 bundle.js，这时就生成了 bundle.js 供 index.html 文件引用。现在打开 index.html 就可以看到我们的页面了。</p><h3 id="4、配置-webpack-config-js"><a href="#4、配置-webpack-config-js" class="headerlink" title="4、配置 webpack.config.js"></a>4、配置 webpack.config.js</h3><p>上述打包方式太 low 了，我们可以在当前项目的根目录下新建一个配置文件 webpack.config.js 用来配置打包方式。<br>webpack.config.js 配置如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>) <span class="comment">// 处理绝对路径</span></span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  entry: path.join(__dirname, <span class="string">'/src/index.js'</span>), <span class="comment">// 入口文件</span></span><br><span class="line">  output: {</span><br><span class="line">    path: path.join(__dirname, <span class="string">'/dist'</span>), <span class="comment">//打包后的文件存放的地方</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span> <span class="comment">//打包后输出文件的文件名</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有了这个配置文件，我们只需在终端中运行 webpack 命令就可进行打包，这条命令会自动引用 webpack.config.js 文件中的配置选项。</p><h3 id="5、构建本地服务器"><a href="#5、构建本地服务器" class="headerlink" title="5、构建本地服务器"></a>5、构建本地服务器</h3><p>现在我们是通过打开本地文件来查看页面的，感觉还是有点 low。例如 vue, react 等脚手架都是在本地服务器运行的。所以我们再做进一步优化。</p><h4 id="5-1-webpack-dev-server-配置本地服务器"><a href="#5-1-webpack-dev-server-配置本地服务器" class="headerlink" title="5.1 webpack-dev-server 配置本地服务器"></a>5.1 webpack-dev-server 配置本地服务器</h4><p>Webpack 提供了一个可选的本地开发服务器，这个本地服务器基于 node.js 构建，它是一个单独的组件，在 webpack 中进行配置之前需要单独安装它作为项目依赖：npm i webpack-dev-server -D</p><p>以下是devServer 的一些配置选项:</p><ul><li>contentBase ：设置服务器所读取文件的目录，当前我们设置为”./dist”</li><li>port ：设置端口号，如果省略，默认为 8080</li><li>inline ：设置为 true，当源文件改变时会自动刷新页面</li><li>historyApiFallback ：设置为 true，所有的跳转将指向 index.html</li></ul><p>现在我们把这些配置加到 webpack.config.js 文件上，如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  entry: path.join(__dirname, <span class="string">'/src/index.js'</span>), <span class="comment">// 入口文件</span></span><br><span class="line">  output: {</span><br><span class="line">    path: path.join(__dirname, <span class="string">'/dist'</span>), <span class="comment">//打包后的文件存放的地方</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span> <span class="comment">//打包后输出文件的文件名</span></span><br><span class="line">  },</span><br><span class="line">  devServer: {</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>, <span class="comment">// 本地服务器所加载文件的目录</span></span><br><span class="line">    port: <span class="string">'8088'</span>, <span class="comment">// 设置端口号为8088</span></span><br><span class="line">    inline: <span class="literal">true</span>, <span class="comment">// 文件修改后实时刷新</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span> <span class="comment">//不跳转</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="5-2、package-json-文件中添加启动和打包命令"><a href="#5-2、package-json-文件中添加启动和打包命令" class="headerlink" title="5.2、package.json 文件中添加启动和打包命令"></a>5.2、package.json 文件中添加启动和打包命令</h4><p>package.json 文件修改如下</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"webpack-project"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: {</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack"</span>,</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open"</span></span><br><span class="line">  },</span><br><span class="line">  <span class="string">"keywords"</span>: [],</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: {</span><br><span class="line">    <span class="string">"webpack"</span>: <span class="string">"^4.23.1"</span>,</span><br><span class="line">    <span class="string">"webpack-cli"</span>: <span class="string">"^3.1.2"</span>,</span><br><span class="line">    <span class="string">"webpack-dev-server"</span>: <span class="string">"^3.1.10"</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样我们就可以用以下命令进行本地运行或者打包文件了</p><ul><li>npm run dev 启动本地服务器，webpack-dev-server 就是启动服务器的命令，–open 是用于启动完服务器后自动打开浏览器。</li><li>npm run build 执行打包命令</li></ul><p>此时，我们只要输入 npm run dev 就可以在<a href="http://localhost:8088/%E4%B8%AD%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2%E4%BA%86%E3%80%82">http://localhost:8088/中查看页面了。</a></p><h3 id="6、配置常用-loader"><a href="#6、配置常用-loader" class="headerlink" title="6、配置常用 loader"></a>6、配置常用 loader</h3><p>loader 可以让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p><p>Loaders 的配置包括以下几方面：</p><ul><li>test：一个用以匹配 loaders 所处理文件的拓展名的正则表达式（必须）</li><li>loader：loader 的名称（必须）</li><li>include/exclude：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；</li><li>options：为 loaders 提供额外的设置选项（可选）</li></ul><h4 id="配置-css-loader-和-sass-loader"><a href="#配置-css-loader-和-sass-loader" class="headerlink" title="配置 css-loader 和 sass-loader"></a>配置 css-loader 和 sass-loader</h4><p>如果我们要加载一个 css 文件，需要安装配置 style-loader 和 css-loader。<br>如果我们要使用 sass，就要配置 sass-loader 和 node-sass。</p><ul><li>css-loader：加载.css 文件</li><li>style-loader：使用 style 标签将 css-loader 内部样式注入到我们的 HTML 页面</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  entry: path.join(__dirname, <span class="string">'/src/index.js'</span>), <span class="comment">// 入口文件</span></span><br><span class="line">  output: {</span><br><span class="line">    path: path.join(__dirname, <span class="string">'/dist'</span>), <span class="comment">//打包后的文件存放的地方</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span> <span class="comment">//打包后输出文件的文件名</span></span><br><span class="line">  },</span><br><span class="line">  devServer: {</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>, <span class="comment">// 本地服务器所加载文件的目录</span></span><br><span class="line">    port: <span class="string">'8088'</span>, <span class="comment">// 设置端口号为8088</span></span><br><span class="line">    inline: <span class="literal">true</span>, <span class="comment">// 文件修改后实时刷新</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span> <span class="comment">//不跳转</span></span><br><span class="line">  },</span><br><span class="line">  <span class="built_in">module</span>: {</span><br><span class="line">    rules: [</span><br><span class="line">      {</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则匹配以.css结尾的文件</span></span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      {</span><br><span class="line">        test: <span class="regexp">/\.(scss|sass)$/</span>, <span class="comment">// 正则匹配以.scss和.sass结尾的文件</span></span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">      }</span><br><span class="line">    ]</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="配置-Babel-loader"><a href="#配置-Babel-loader" class="headerlink" title="配置 Babel-loader"></a>配置 Babel-loader</h4><p>Babel 其实是一个编译 JavaScript 的平台，它可以编译代码帮你达到以下目的：</p><ul><li>让你能使用最新的 JavaScript 代码（ES6，ES7…）；</li><li>让你能使用基于 JavaScript 进行了拓展的语言，比如 React 的 JSX；</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: {</span><br><span class="line">  ...</span><br><span class="line">  rules: [</span><br><span class="line">    {</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>)]</span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="处理图片"><a href="#处理图片" class="headerlink" title="处理图片"></a>处理图片</h4><p>处理图片资源时，我们常用的两种 loader 是 file-loader 或者 url-loader。<br>当使用 url-loader 加载图片，图片小于上限值，则将图片转 base64 字符串，否则使用 file-loader 加载图片。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: {</span><br><span class="line">  ...</span><br><span class="line">  rules: [</span><br><span class="line">    {</span><br><span class="line">      test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: {</span><br><span class="line">        limit: <span class="number">10000</span>,</span><br><span class="line">        name: utils.assetsPath(<span class="string">'img/[name].[hash:7].[ext]'</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="7、配置常用插件"><a href="#7、配置常用插件" class="headerlink" title="7、配置常用插件"></a>7、配置常用插件</h3><p>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。</p><h4 id="7-1、自动生成-html-文件-HtmlWebpackPlugin"><a href="#7-1、自动生成-html-文件-HtmlWebpackPlugin" class="headerlink" title="7.1、自动生成 html 文件(HtmlWebpackPlugin)"></a>7.1、自动生成 html 文件(HtmlWebpackPlugin)</h4><p>现在我们都是使用一开始建好的 index.html 文件，然后手动引入 bundle.js，如果以后我们引入不止一个 js 文件，那就得更改 index.html 中的 js 文件名，所以能不能自动生成 index.html 且自动引用打包后的 js 呢？<br>HtmlWebpackPlugin 插件就是用来解决这个问题的：</p><ol><li>安装插件 npm i html-webpack-plugin -D</li><li>把 dist 文件夹清空</li><li>在根目录新建 index.html,内容和原来的 html 一致，只是不引入 js 文件。</li><li>webpack.config.js 中我们引入了 HtmlWebpackPlugin 插件</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin({</span><br><span class="line">    filename: <span class="string">'index.html'</span>,</span><br><span class="line">    template: <span class="string">'index.html'</span>,</span><br><span class="line">    inject: <span class="literal">true</span>,</span><br><span class="line">    minify: {</span><br><span class="line">      removeComments: <span class="literal">true</span>,</span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">      removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>此时我们使用 npm run build 进行打包，你会发现，dist 文件夹和 html 文件都会自动生成。</p><h4 id="7-2、清理-dist-文件夹-CleanWebpackPlugin"><a href="#7-2、清理-dist-文件夹-CleanWebpackPlugin" class="headerlink" title="7.2、清理/dist 文件夹(CleanWebpackPlugin)"></a>7.2、清理/dist 文件夹(CleanWebpackPlugin)</h4><p>在每次构建前清理/dist 文件夹，生产最新的打包文件，这时候就用到 CleanWebpackPlugin 插件了。</p><ol><li>安装 npm i clean-webpack-plugin -D</li><li>配置 webpack.config.js</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin({</span><br><span class="line">    filename: <span class="string">'index.html'</span>,</span><br><span class="line">    template: <span class="string">'index.html'</span>,</span><br><span class="line">    inject: <span class="literal">true</span>,</span><br><span class="line">    minify: {</span><br><span class="line">      removeComments: <span class="literal">true</span>,</span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">      removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">  }),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'dist'</span>])</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h4 id="7-3、热更新-HotModuleReplacementPlugin"><a href="#7-3、热更新-HotModuleReplacementPlugin" class="headerlink" title="7.3、热更新(HotModuleReplacementPlugin)"></a>7.3、热更新(HotModuleReplacementPlugin)</h4><p>我们要在修改代码后自动更新页面，这就需要 HotModuleReplacementPlugin（HMR）插件</p><ol><li>devServer 配置项中添加 hot: true 参数。</li><li>因为 HotModuleReplacementPlugin 是 webpack 模块自带的，所以引入 webpack 后，在 plugins 配置项中直接使用即可。</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin({</span><br><span class="line">    filename: <span class="string">'index.html'</span>,</span><br><span class="line">    template: <span class="string">'index.html'</span>,</span><br><span class="line">    inject: <span class="literal">true</span>,</span><br><span class="line">    minify: {</span><br><span class="line">      removeComments: <span class="literal">true</span>,</span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">      removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">  }),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'dist'</span>])</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h4 id="7-4、增加-css-前缀"><a href="#7-4、增加-css-前缀" class="headerlink" title="7.4、增加 css 前缀"></a>7.4、增加 css 前缀</h4><p>平时我们写 css 时，一些属性需要手动加上前缀，比如-webkit-border-radius: 10px;，在 webpack 中我们可以让他自动加上</p><ol><li>安装 npm i postcss-loader autoprefixer -D</li><li>在项目根目录下新建 postcss.config.js 文件</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>) <span class="comment">// 引用autoprefixer模块</span></span><br><span class="line">  ]</span><br><span class="line">}</span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">   ...</span><br><span class="line">  <span class="built_in">module</span>: {</span><br><span class="line">    rules: [</span><br><span class="line">      {</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则匹配以.css结尾的文件</span></span><br><span class="line">        use: [</span><br><span class="line">          { <span class="attr">loader</span>: <span class="string">'style-loader'</span> }, <span class="comment">// 这里采用的是对象配置loader的写法</span></span><br><span class="line">          { <span class="attr">loader</span>: <span class="string">'css-loader'</span> },</span><br><span class="line">          { <span class="attr">loader</span>: <span class="string">'postcss-loader'</span> } <span class="comment">// 使用postcss-loader</span></span><br><span class="line">        ]</span><br><span class="line">      }</span><br><span class="line">       ...</span><br><span class="line">    ]</span><br><span class="line">  }</span><br><span class="line">   ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="7-5、css-分离-ExtractTextPlugin"><a href="#7-5、css-分离-ExtractTextPlugin" class="headerlink" title="7.5、css 分离 ExtractTextPlugin"></a>7.5、css 分离 ExtractTextPlugin</h4><p>将 css 成生文件，而非内联。该插件的主要是为了抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象。</p><ol><li>安装 npm i extract-text-webpack-plugin@next -D</li><li>在 webpack.common.js 文件中引入并使用该插件：</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>) <span class="comment">//引入分离插件</span></span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  <span class="built_in">module</span>: {</span><br><span class="line">    rules: [</span><br><span class="line">      {</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则匹配以.css结尾的文件</span></span><br><span class="line">        use: ExtractTextPlugin.extract({</span><br><span class="line">          <span class="comment">// 相当于回滚，经postcss-loader和css-loader处理过的css最终再经过style-loader处理</span></span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: [<span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">        })</span><br><span class="line">      }</span><br><span class="line">    ]</span><br><span class="line">  },</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'css/index.css'</span>) <span class="comment">// 将css分离到/dist文件夹下的css文件夹中的index.css</span></span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时运行 npm run build 后会发现/dist 文件夹内多出了/css 文件夹及 index.css 文件。</p><h4 id="7-6、消除冗余-css"><a href="#7-6、消除冗余-css" class="headerlink" title="7.6、消除冗余 css"></a>7.6、消除冗余 css</h4><p>有时候我们 css 写得多了，可能会不自觉的写重复了一些样式，这就造成了多余的代码，以下方法可以优化</p><ol><li>安装 npm i purifycss-webpack purify-css glob -D</li><li>引入 clean-webpack-plugin 及 glob 插件并使用</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PurifyCssWebpack = <span class="built_in">require</span>(<span class="string">'purifycss-webpack'</span>) <span class="comment">// 引入PurifyCssWebpack插件</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>) <span class="comment">// 引入glob模块,用于扫描全部html文件中所引用的css</span></span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> PurifyCssWebpack({</span><br><span class="line">    paths: glob.sync(path.join(__dirname, <span class="string">'src/*.html'</span>)) <span class="comment">// 同步扫描所有html文件中所引用的css</span></span><br><span class="line">  })</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h4 id="至此，一些常用的配置以及弄好了，现在就开始愉快地写代码了。"><a href="#至此，一些常用的配置以及弄好了，现在就开始愉快地写代码了。" class="headerlink" title="至此，一些常用的配置以及弄好了，现在就开始愉快地写代码了。"></a>至此，一些常用的配置以及弄好了，现在就开始愉快地写代码了。</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/webpack%E7%9A%84%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%88%86%E5%8C%85%E7%AD%96%E7%95%A5/"/>
      <url>2020/12/29/webpack%E7%9A%84%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%88%86%E5%8C%85%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack-异步加载原理"><a href="#webpack-异步加载原理" class="headerlink" title="webpack 异步加载原理"></a>webpack 异步加载原理</h2><p><code>webpack ensure</code> 有人称它为异步加载，也有人称为代码切割，他其实就是将 js 模块给独立导出一个.js 文件，然后使用这个模块的时候，再创建一个 <code>script</code> 对象，加入到 <code>document.head</code> 对象中，浏览器会自动帮我们发起请求，去请求这个 js 文件，然后写个回调函数，让请求到的 js 文件做一些业务操作。</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>需求：<code>main.js</code> 依赖两个 js 文件：<code>A.js</code> 是点击 aBtn 按钮后，才执行的逻辑，<code>B.js</code> 是点击 bBtn 按钮后，才执行的逻辑。</p><p><code>webpack.config.js</code>，我们先来写一下 <code>webpack</code> 打包的配置的代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>) <span class="comment">// 路径处理模块</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> { CleanWebpackPlugin } = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>) <span class="comment">// 引入CleanWebpackPlugin插件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  entry: {</span><br><span class="line">    index: path.join(__dirname, <span class="string">'/src/main.js'</span>),</span><br><span class="line">  },</span><br><span class="line">  output: {</span><br><span class="line">    path: path.join(__dirname, <span class="string">'/dist'</span>),</span><br><span class="line">    filename: <span class="string">'index.js'</span>,</span><br><span class="line">  },</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin({</span><br><span class="line">      template: path.join(__dirname, <span class="string">'/index.html'</span>),</span><br><span class="line">    }),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">// 所要清理的文件夹名称</span></span><br><span class="line">  ],</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>index.html</code> 代码如下</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"aBtn"</span>&gt;</span>按钮A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"bBtn"</span>&gt;</span>按钮B<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>入口文件 <code>main.js</code> 如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> A <span class="keyword">from</span> <span class="string">'./A'</span></span><br><span class="line"><span class="keyword">import</span> B <span class="keyword">from</span> <span class="string">'./B'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'aBtn'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  alert(A)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'bBtn'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  alert(B)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>A.js</code> 和 <code>B.js</code> 的代码分别如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.js</span></span><br><span class="line"><span class="keyword">const</span> A = <span class="string">'hello A'</span></span><br><span class="line"><span class="built_in">module</span>.exports = A</span><br><span class="line"></span><br><span class="line"><span class="comment">// B.js</span></span><br><span class="line"><span class="keyword">const</span> B = <span class="string">'hello B'</span></span><br><span class="line"><span class="built_in">module</span>.exports = B</span><br></pre></td></tr></tbody></table></figure><p>此时，我们对项目进行 <code>npm run build</code>， 打包出来的只有两个文件</p><ul><li>index.html</li><li>index.js</li></ul><p>由此可见，此时 <code>webpack</code> 把 <code>main.js</code> 依赖的两个文件都同时打包到同一个 js 文件，并在 index.html 中引入。但是 <code>A.js</code> 和 <code>B.js</code> 都是点击相应按钮才会执行的逻辑，如果用户并没有点击相应按钮，而且这两个文件又是比较大的话，这样是不是就导致首页默认加载的 js 文件太大，从而导致首页渲染较慢呢？那么有能否实现当用户点击按钮的时候再加载相应的依赖文件呢？</p><p><code>webpack.ensure</code> 就解决了这个问题。</p><h3 id="require-ensure-异步加载"><a href="#require-ensure-异步加载" class="headerlink" title="require.ensure 异步加载"></a>require.ensure 异步加载</h3><p>下面我们将 <code>main.js</code> 改成异步加载的方式</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'aBtn'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="comment">//异步加载A</span></span><br><span class="line">  <span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> A = <span class="built_in">require</span>(<span class="string">'./A.js'</span>)</span><br><span class="line">    alert(A)</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'bBtn'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="comment">//异步加载b</span></span><br><span class="line">  <span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> B = <span class="built_in">require</span>(<span class="string">'./B.js'</span>)</span><br><span class="line">    alert(B)</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时，我们再进行一下打包，发现多了 <code>1.index.js</code> 和 <code>2.index.js</code> 两个文件。而我们打开页面时只引入了 <code>index.js</code> 一个文件，当点击按钮 A 的时候才引入 <code>1.index.js</code> 文件，点击按钮 B 的时候才引入 <code>2.index.js</code> 文件。这样就满足了我们按需加载的需求。</p><p><code>require.ensure</code> 这个函数是一个代码分离的分割线，表示回调里面的 <code>require</code> 是我们想要进行分割出去的，即 <code>require('./A.js')</code>，把 A.js 分割出去，形成一个 <code>webpack</code> 打包的单独 js 文件。它的语法如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure(dependencies: <span class="built_in">String</span>[], <span class="attr">callback</span>: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span></span>), <span class="title">chunkName</span>: <span class="title">String</span>)</span></span><br></pre></td></tr></tbody></table></figure><p>我们打开 <code>1.index.js</code> 文件，发现它的代码如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="built_in">window</span>.webpackJsonp = <span class="built_in">window</span>.webpackJsonp || []).push([</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [</span><br><span class="line">    ,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">o, n</span>) </span>{</span><br><span class="line">      o.exports = <span class="string">'hello A'</span></span><br><span class="line">    },</span><br><span class="line">  ],</span><br><span class="line">])</span><br></pre></td></tr></tbody></table></figure><p>由上面的代码可以看出：</p><ol><li>异步加载的代码，会保存在一个全局的 <code>webpackJsonp</code> 中。</li><li><code>webpackJsonp.push</code> 的的值，两个参数分别为异步加载的文件中存放的需要安装的模块对应的 id 和异步加载的文件中存放的需要安装的模块列表。</li><li>在满足某种情况下，会执行具体模块中的代码。</li></ol><h3 id="import-按需加载"><a href="#import-按需加载" class="headerlink" title="import() 按需加载"></a>import() 按需加载</h3><p>webpack4 官方文档提供了模块按需切割加载，配合 es6 的按需加载 <code>import()</code> 方法，可以做到减少首页包体积，加快首页的请求速度，只有其他模块，只有当需要的时候才会加载对应 js。</p><p><code>import()</code>的语法十分简单。该函数只接受一个参数，就是引用包的地址，并且使用了 <code>promise</code> 式的回调，获取加载的包。在代码中所有被 <code>import()</code>的模块，都将打成一个单独的包，放在 <code>chunk</code> 存储的目录下。在浏览器运行到这一行代码时，就会自动请求这个资源，实现异步加载。</p><p>下面我们将上述代码改成 <code>import()</code>方式。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'aBtn'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="comment">//异步加载A</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./A'</span>).then(<span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">    alert(data.A)</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'bBtn'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="comment">//异步加载b</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./B'</span>).then(<span class="function">(<span class="params">data</span>) =&gt;</span> {</span><br><span class="line">    alert(data.B)</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时打包出来的文件和 <code>webpack.ensure</code> 方法是一样的。</p><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>为什么需要懒加载？</p><p>像 vue 这种单页面应用，如果没有路由懒加载，运用 webpack 打包后的文件将会很大，造成进入首页时，需要加载的内容过多，出现较长时间的白屏，运用路由懒加载则可以将页面进行划分，需要的时候才加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时。</p><p>vue 路由懒加载有以下三种方式</p><ul><li>vue 异步组件</li><li>ES6 的 <code>import()</code></li><li>webpack 的 <code>require.ensure()</code></li></ul><h3 id="vue-异步组件"><a href="#vue-异步组件" class="headerlink" title="vue 异步组件"></a>vue 异步组件</h3><p>这种方法主要是使用了 <code>resolve</code> 的异步机制，用 <code>require</code> 代替了 <code>import</code> 实现按需加载</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router({</span><br><span class="line">  routes: [</span><br><span class="line">    {</span><br><span class="line">      path: <span class="string">'/home'</span>,<span class="string">',</span></span><br><span class="line"><span class="string">      component: (resolve) =&gt; require(['</span>@/components/home<span class="string">'], resolve),</span></span><br><span class="line"><span class="string">    },</span></span><br><span class="line"><span class="string">    {</span></span><br><span class="line"><span class="string">      path: '</span>/about<span class="string">','</span>,</span><br><span class="line">      component: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>([<span class="string">'@/components/about'</span>], resolve),</span><br><span class="line">    },</span><br><span class="line">  ],</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="require-ensure"><a href="#require-ensure" class="headerlink" title="require.ensure"></a>require.ensure</h3><p>这种模式可以通过参数中的 <code>webpackChunkName</code> 将 js 分开打包。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router({</span><br><span class="line">  routes: [</span><br><span class="line">    {</span><br><span class="line">      path: <span class="string">'/home'</span>,</span><br><span class="line">      component: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>.ensure([], <span class="function">() =&gt;</span> resolve(<span class="built_in">require</span>(<span class="string">'@/components/home'</span>)), <span class="string">'home'</span>),</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">      path: <span class="string">'/about'</span>,</span><br><span class="line">      component: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>.ensure([], <span class="function">() =&gt;</span> resolve(<span class="built_in">require</span>(<span class="string">'@/components/about'</span>)), <span class="string">'about'</span>),</span><br><span class="line">    },</span><br><span class="line">  ],</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="ES6-的-import"><a href="#ES6-的-import" class="headerlink" title="ES6 的 import()"></a>ES6 的 import()</h3><p><code>vue-router</code> 在官网提供了一种方法，可以理解也是为通过 <code>Promise</code> 的 <code>resolve</code> 机制。因为 <code>Promise</code> 函数返回的 <code>Promise</code> 为 <code>resolve</code> 组件本身，而我们又可以使用 <code>import</code> 来导入组件。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router({</span><br><span class="line">  routes: [</span><br><span class="line">    {</span><br><span class="line">      path: <span class="string">'/home'</span>,</span><br><span class="line">      component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/components/home'</span>),</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">      path: <span class="string">'/about'</span>,</span><br><span class="line">      component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/components/home'</span>),</span><br><span class="line">    },</span><br><span class="line">  ],</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="webpack-分包策略"><a href="#webpack-分包策略" class="headerlink" title="webpack 分包策略"></a>webpack 分包策略</h2><p>在 webpack 打包过程中，经常出现 <code>vendor.js</code>， <code>app.js</code> 单个文件较大的情况，这偏偏又是网页最先加载的文件，这就会使得加载时间过长，从而使得白屏时间过长，影响用户体验。所以我们需要有合理的分包策略。</p><h3 id="CommonsChunkPlugin"><a href="#CommonsChunkPlugin" class="headerlink" title="CommonsChunkPlugin"></a>CommonsChunkPlugin</h3><p>在 Webapck4.x 版本之前，我们都是使用 <code>CommonsChunkPlugin</code> 去做分离</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin({</span><br><span class="line">    name: <span class="string">'vendor'</span>,</span><br><span class="line">    minChunks: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, count</span>) </span>{</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="built_in">module</span>.resource &amp;&amp;</span><br><span class="line">        /\.js$/.test(<span class="built_in">module</span>.resource) &amp;&amp;</span><br><span class="line">        <span class="built_in">module</span>.resource.indexOf(path.join(__dirname, <span class="string">'./node_modules'</span>)) === <span class="number">0</span></span><br><span class="line">      )</span><br><span class="line">    },</span><br><span class="line">  }),</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin({</span><br><span class="line">    name: <span class="string">'common'</span>,</span><br><span class="line">    chunks: <span class="string">'initial'</span>,</span><br><span class="line">    minChunks: <span class="number">2</span>,</span><br><span class="line">  }),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>我们把以下文件单独抽离出来打包</p><ul><li><code>node_modules</code> 文件夹下的，模块</li><li>被 3 个 入口 <code>chunk</code> 共享的模块</li></ul><h3 id="optimization-splitChunks"><a href="#optimization-splitChunks" class="headerlink" title="optimization.splitChunks"></a>optimization.splitChunks</h3><p>webpack 4 最大的改动就是废除了 <code>CommonsChunkPlugin</code> 引入了 <code>optimization.splitChunks</code>。如果你的 <code>mode</code> 是 <code>production</code>，那么 webpack4 就会自动开启 <code>Code Splitting</code>。</p><p>它内置的代码分割策略是这样的：</p><ul><li>新的 chunk 是否被共享或者是来自 <code>node_modules</code> 的模块</li><li>新的 chunk 体积在压缩之前是否大于 30kb</li><li>按需加载 chunk 的并发请求数量小于等于 5 个</li><li>页面初始加载时的并发请求数量小于等于 3 个</li></ul><p>虽然在 webpack4 会自动开启 <code>Code Splitting</code>，但是随着项目工程的最大，这往往不能满足我们的需求，我们需要再进行个性化的优化。</p><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>我们先找到一个优化空间较大的项目来进行操作。这是一个后台管理系统项目，大部分内容由 3-4 个前端开发，平时开发周期较短，且大部分人没有优化意识，只是写好业务代码完成需求，日子一长，造成打包出来的文件较大，大大影响性能。</p><p>我们先用 <code>webpack-bundle-analyzer</code> 分析打包后的模块依赖及文件大小，确定优化的方向在哪。</p><img src="../img/21.png"><p>然后我们再看下打包出来的 js 文件</p><img src="../img/31.png"><p>看到这两张图的时候，我内心是崩溃的，槽点如下</p><ul><li>打包后生成多个将近 1M 的 js 文件，其中不乏 <code>vendor.js</code> 首页必须加载的大文件</li><li><code>xlsx.js</code> 这样的插件没必要使用，导出 excel 更好的方法应该是后端返回文件流格式给前端处理</li><li><code>echart</code> 和 <code>iview</code> 文件太大，应该使用 cdn 引入的方法</li></ul><p>吐槽完之后我们就要开始做正事了。正是因为有这么多槽点，我们才更好用来验证我们优化方法的可行性。</p><h4 id="抽离-echart-和-iview"><a href="#抽离-echart-和-iview" class="headerlink" title="抽离 echart 和 iview"></a>抽离 echart 和 iview</h4><p>由上面分析可知，<code>echart</code> 和 <code>iview</code> 文件太大，此时我们就用到 webpack4 的 <code>optimization.splitChunks</code> 进行代码分割了，把他们单独抽离打包成文件。(为了更好地呈现优化效果，我们先把 xlsx.js 去掉)</p><p><code>vue.config.js</code> 修改如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> {</span><br><span class="line">    config.optimization.splitChunks({</span><br><span class="line">      chunks: <span class="string">'all'</span>,</span><br><span class="line">      cacheGroups: {</span><br><span class="line">        vendors: {</span><br><span class="line">          name: <span class="string">'chunk-vendors'</span>,</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">10</span>,</span><br><span class="line">          chunks: <span class="string">'initial'</span></span><br><span class="line">        },</span><br><span class="line">        iview: {</span><br><span class="line">          name: <span class="string">'chunk-iview'</span>,</span><br><span class="line">          priority: <span class="number">20</span>,</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]_?iview(.*)/</span></span><br><span class="line">        },</span><br><span class="line">        echarts: {</span><br><span class="line">          name: <span class="string">'chunk-echarts'</span>,</span><br><span class="line">          priority: <span class="number">20</span>,</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]_?echarts(.*)/</span></span><br><span class="line">        },</span><br><span class="line">        commons: {</span><br><span class="line">          name: <span class="string">'chunk-commons'</span>,</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">5</span>,</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    })</span><br><span class="line">  },</span><br></pre></td></tr></tbody></table></figure><p>此时我们再用 <code>webpack-bundle-analyzer</code> 分析一下</p><img src="../img/23.png"><p>打包出来的 js 文件</p><img src="../img/33.png"><p>从这里可以看出我们已经成功把 <code>echart</code> 和 <code>iview</code> 单独抽离出来了，同时 <code>vendor.js</code> 也相应地减小了体积。此外，我们还可以继续抽离其他更多的第三方模块。</p><h4 id="CDN-方式"><a href="#CDN-方式" class="headerlink" title="CDN 方式"></a>CDN 方式</h4><p>虽然第三方模块是单独抽离出来了，但是在首页或者相应路由加载时还是要加载这样一个几百 kb 的文件，还是不利于性能优化的。这时，我们可以用 CDN 的方式引入这样插件或者 UI 组件库。</p><ol><li>在 <code>index.html</code> 引入相应 cdn 链接</li></ol><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.bootcdn.net/ajax/libs/iview/3.5.4/styles/iview.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.8/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcdn.net/ajax/libs/iview/3.5.4/iview.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcdn.net/ajax/libs/xlsx/0.16.8/xlsx.mini.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcdn.net/ajax/libs/xlsx/0.16.8/cpexcel.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><code>vue.config.js</code> 配置 <code>externals</code></li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">configureWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> {</span><br><span class="line">  config.externals = {</span><br><span class="line">    vue: <span class="string">'Vue'</span>,</span><br><span class="line">    xlsx: <span class="string">'XLSX'</span>,</span><br><span class="line">    iview: <span class="string">'iView'</span>,</span><br><span class="line">    iView: <span class="string">'ViewUI'</span>,</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>删除之前的引入方式并卸载相应 npm 依赖包</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall vue iview echarts xlsx --save</span><br></pre></td></tr></tbody></table></figure><p>此时我们在来看一下打包后的情况</p><img src="../img/25.png"><p>打包出来的 js 文件</p><img src="../img/35.png"><p>well done ! 这时基本没有打包出大文件了，首页加载需要的 <code>vendor.js</code> 也只有几十 kb，而且我们还可以进一步优化，就是把 vue 全家桶的一些模块再通过 cdn 的方法引入，比如 <code>vue-router</code>，<code>vuex</code>，<code>axios</code> 等。这时页面特别是首页加载的性能就得到大大地优化了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/webpack%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>2020/12/29/webpack%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack-插件原理"><a href="#webpack-插件原理" class="headerlink" title="webpack 插件原理"></a>webpack 插件原理</h1><p>在 webpack 中，专注于处理 webpack 在编译过程中的某个特定的任务的功能模块，可以称为插件。它和 <code>loader</code> 有以下区别：</p><ol><li><p><code>loader</code> 是一个转换器，将 A 文件进行编译成 B 文件，比如：将 <code>A.less</code> 转换为 <code>A.css</code>，单纯的文件转换过程。webpack 自身只支持 js 和 json 这两种格式的文件，对于其他文件需要通过 <code>loader</code> 将其转换为 commonJS 规范的文件后，webpack 才能解析到。</p></li><li><p><code>plugin</code> 是一个扩展器，它丰富了 webpack 本身，针对是 <code>loader</code> 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。</p></li></ol><h3 id="plugin-的特征"><a href="#plugin-的特征" class="headerlink" title="plugin 的特征"></a>plugin 的特征</h3><p>webpack 插件有以下特征</p><ul><li>是一个独立的模块。</li><li>模块对外暴露一个 js 函数。</li><li>函数的原型 <code>(prototype)</code> 上定义了一个注入 <code>compiler</code> 对象的 <code>apply</code> 方法。</li><li><code>apply</code> 函数中需要有通过 <code>compiler</code> 对象挂载的 webpack 事件钩子，钩子的回调中能拿到当前编译的 <code>compilation</code> 对象，如果是异步编译插件的话可以拿到回调 callback。</li><li>完成自定义子编译流程并处理 <code>complition</code> 对象的内部数据。</li><li>如果异步编译插件的话，数据处理完成后执行 callback 回调。</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloPlugin</span> </span>{</span><br><span class="line">  <span class="comment">// 在构造函数中获取用户给该插件传入的配置</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> {}</span><br><span class="line">  <span class="comment">// Webpack 会调用 HelloPlugin 实例的 apply 方法给插件实例传入 compiler 对象</span></span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> {</span><br><span class="line">    <span class="comment">// 在emit阶段插入钩子函数，用于特定时机处理额外的逻辑；</span></span><br><span class="line">    compiler.hooks.emit.tap(<span class="string">'HelloPlugin'</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> {</span><br><span class="line">      <span class="comment">// 在功能流程完成后可以调用 webpack 提供的回调函数；</span></span><br><span class="line">    })</span><br><span class="line">    <span class="comment">// 如果事件是异步的，会带两个参数，第二个参数为回调函数，</span></span><br><span class="line">    compiler.plugin(<span class="string">'emit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">compilation, callback</span>) </span>{</span><br><span class="line">      <span class="comment">// 处理完毕后执行 callback 以通知 Webpack</span></span><br><span class="line">      <span class="comment">// 如果不执行 callback，运行流程将会一直卡在这不往下执行</span></span><br><span class="line">      callback()</span><br><span class="line">    })</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = HelloPlugin</span><br></pre></td></tr></tbody></table></figure><ol><li>webpack 读取配置的过程中会先执行 <code>new HelloPlugin(options)</code> 初始化一个 <code>HelloPlugin</code> 获得其实例。</li><li>初始化 <code>compiler</code> 对象后调用 <code>HelloPlugin.apply(compiler)</code> 给插件实例传入 compiler 对象。</li><li>插件实例在获取到 <code>compiler</code> 对象后，就可以通过 <code>compiler.plugin</code> (事件名称, 回调函数) 监听到 Webpack 广播出来的事件。 并且可以通过 <code>compiler</code> 对象去操作 Webpack。</li></ol><h3 id="事件流机制"><a href="#事件流机制" class="headerlink" title="事件流机制"></a>事件流机制</h3><p>webpack 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 <code>Tapable</code>。</p><p>Webpack 的 <code>Tapable</code> 事件流机制保证了插件的有序性，将各个插件串联起来， Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条 webapck 机制中，去改变 webapck 的运作，使得整个系统扩展性良好。</p><p><code>Tapable</code> 也是一个小型的 library，是 Webpack 的一个核心工具。类似于 node 中的 events 库，核心原理就是一个<code>订阅发布模式</code>。作用是提供类似的插件接口。方法如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  广播事件</span></span><br><span class="line">compiler.apply(<span class="string">'event-name'</span>, params)</span><br><span class="line">compilation.apply(<span class="string">'event-name'</span>, params)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听事件</span></span><br><span class="line">compiler.plugin(<span class="string">'event-name'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>{})</span><br><span class="line">compilation.plugin(<span class="string">'event-name'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>{})</span><br></pre></td></tr></tbody></table></figure><p>我们来看下 Tapable</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tapable</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">this</span>._plugins = {}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//发布name消息</span></span><br><span class="line">Tapable.prototype.applyPlugins = <span class="function"><span class="keyword">function</span> <span class="title">applyPlugins</span>(<span class="params">name</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>._plugins[name]) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">var</span> plugins = <span class="built_in">this</span>._plugins[name]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; plugins.length; i++) {</span><br><span class="line">    plugins[i].apply(<span class="built_in">this</span>, args)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// fn订阅name消息</span></span><br><span class="line">Tapable.prototype.plugin = <span class="function"><span class="keyword">function</span> <span class="title">plugin</span>(<span class="params">name, fn</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>._plugins[name]) {</span><br><span class="line">    <span class="built_in">this</span>._plugins[name] = [fn]</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">this</span>._plugins[name].push(fn)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//给定一个插件数组，对其中的每一个插件调用插件自身的apply方法注册插件</span></span><br><span class="line">Tapable.prototype.apply = <span class="function"><span class="keyword">function</span> <span class="title">apply</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) {</span><br><span class="line">    <span class="built_in">arguments</span>[i].apply(<span class="built_in">this</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>Tapable</code> 为 webpack 提供了统一的插件接口（钩子）类型定义，它是 webpack 的核心功能库。webpack 中目前有十种 hooks，在 Tapable 源码中可以看到，他们是：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.SyncHook = <span class="built_in">require</span>(<span class="string">'./SyncHook'</span>)</span><br><span class="line"><span class="built_in">exports</span>.SyncBailHook = <span class="built_in">require</span>(<span class="string">'./SyncBailHook'</span>)</span><br><span class="line"><span class="built_in">exports</span>.SyncWaterfallHook = <span class="built_in">require</span>(<span class="string">'./SyncWaterfallHook'</span>)</span><br><span class="line"><span class="built_in">exports</span>.SyncLoopHook = <span class="built_in">require</span>(<span class="string">'./SyncLoopHook'</span>)</span><br><span class="line"><span class="built_in">exports</span>.AsyncParallelHook = <span class="built_in">require</span>(<span class="string">'./AsyncParallelHook'</span>)</span><br><span class="line"><span class="built_in">exports</span>.AsyncParallelBailHook = <span class="built_in">require</span>(<span class="string">'./AsyncParallelBailHook'</span>)</span><br><span class="line"><span class="built_in">exports</span>.AsyncSeriesHook = <span class="built_in">require</span>(<span class="string">'./AsyncSeriesHook'</span>)</span><br><span class="line"><span class="built_in">exports</span>.AsyncSeriesBailHook = <span class="built_in">require</span>(<span class="string">'./AsyncSeriesBailHook'</span>)</span><br><span class="line"><span class="built_in">exports</span>.AsyncSeriesLoopHook = <span class="built_in">require</span>(<span class="string">'./AsyncSeriesLoopHook'</span>)</span><br><span class="line"><span class="built_in">exports</span>.AsyncSeriesWaterfallHook = <span class="built_in">require</span>(<span class="string">'./AsyncSeriesWaterfallHook'</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>Tapable</code> 还统一暴露了三个方法给插件，用于注入不同类型的自定义构建行为：</p><ul><li>tap：可以注册同步钩子和异步钩子。</li><li>tapAsync：回调方式注册异步钩子。</li><li>tapPromise：Promise 方式注册异步钩子。</li></ul><p>webpack 里的几个非常重要的对象，<code>Compiler</code>, <code>Compilation</code> 和 <code>JavascriptParser</code> 都继承了 <code>Tapable</code> 类，它们身上挂着丰富的钩子。</p><h3 id="编写一个插件"><a href="#编写一个插件" class="headerlink" title="编写一个插件"></a>编写一个插件</h3><p>一个 webpack 插件由以下组成：</p><ul><li>一个 JavaScript 命名函数。</li><li>在插件函数的 prototype 上定义一个 apply 方法。</li><li>指定一个绑定到 webpack 自身的事件钩子。</li><li>处理 webpack 内部实例的特定数据。</li><li>功能完成后调用 webpack 提供的回调。</li></ul><p>下面实现一个最简单的插件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebpackPlugin1</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.options = options</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> {</span><br><span class="line">    compiler.hooks.done.tap(<span class="string">'MYWebpackPlugin'</span>, <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.options)</span><br><span class="line">    })</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = WebpackPlugin1</span><br></pre></td></tr></tbody></table></figure><p>然后在 webpack 的配置中注册使用就行，只需要在 <code>webpack.config.js</code> 里引入并实例化就可以了：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebpackPlugin1 = <span class="built_in">require</span>(<span class="string">'./src/plugin/plugin1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  entry: {</span><br><span class="line">    index: path.join(__dirname, <span class="string">'/src/main.js'</span>),</span><br><span class="line">  },</span><br><span class="line">  output: {</span><br><span class="line">    path: path.join(__dirname, <span class="string">'/dist'</span>),</span><br><span class="line">    filename: <span class="string">'index.js'</span>,</span><br><span class="line">  },</span><br><span class="line">  plugins: [<span class="keyword">new</span> WebpackPlugin1({ <span class="attr">msg</span>: <span class="string">'hello world'</span> })],</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时我们执行一下 <code>npm run build</code> 就能看到效果了</p><img src="../img/plugin1.png"><h3 id="Compiler-对象-（负责编译）"><a href="#Compiler-对象-（负责编译）" class="headerlink" title="Compiler 对象 （负责编译）"></a>Compiler 对象 （负责编译）</h3><p><code>Compiler</code> 对象包含了当前运行 Webpack 的配置，包括 <code>entry</code>、<code>output</code>、<code>loaders</code> 等配置，这个对象在启动 Webpack 时被实例化，而且是全局唯一的。<code>Plugin</code> 可以通过该对象获取到 Webpack 的配置信息进行处理。</p><p>compiler 上暴露的一些常用的钩子：</p><img src="../img/compiler.png"><p>下面来举个例子</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebpackPlugin2</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.options = options</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> {</span><br><span class="line">    compiler.hooks.run.tap(<span class="string">'run'</span>, <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'开始编译...'</span>)</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    compiler.hooks.compile.tap(<span class="string">'compile'</span>, <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'compile'</span>)</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    compiler.hooks.done.tap(<span class="string">'compilation'</span>, <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'compilation'</span>)</span><br><span class="line">    })</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = WebpackPlugin2</span><br></pre></td></tr></tbody></table></figure><p>此时我们执行一下 <code>npm run build</code> 就能看到效果了</p><img src="../img/plugin2.png"><p>有一些编译插件中的步骤是异步的，这样就需要额外传入一个 callback 回调函数，并且在插件运行结束时执行这个回调函数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebpackPlugin2</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.options = options</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> {</span><br><span class="line">    compiler.hooks.beforeCompile.tapAsync(<span class="string">'compilation'</span>, <span class="function">(<span class="params">compilation, cb</span>) =&gt;</span> {</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'编译中...'</span>)</span><br><span class="line">        cb()</span><br><span class="line">      }, <span class="number">1000</span>)</span><br><span class="line">    })</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = WebpackPlugin2</span><br></pre></td></tr></tbody></table></figure><h3 id="Compilation-对象"><a href="#Compilation-对象" class="headerlink" title="Compilation 对象"></a>Compilation 对象</h3><p><code>Compilation</code> 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 <code>compilation</code>，从而生成一组新的编译资源。一个 <code>Compilation</code> 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息，简单来讲就是把本次打包编译的内容存到内存里。<code>Compilation</code> 对象也提供了插件需要自定义功能的回调，以供插件做自定义处理时选择使用拓展。</p><p>简单来说，<code>Compilation</code> 的职责就是构建模块和 Chunk，并利用插件优化构建过程。</p><p><code>Compiler</code> 代表了整个 Webpack 从启动到关闭的生命周期，而 <code>Compilation</code> 只是代表了一次新的编译，只要文件有改动，<code>compilation</code> 就会被重新创建。</p><p><code>Compilation</code> 上暴露的一些常用的钩子：<br><img src="../img/compilation.png"></p><p><code>Compiler</code> 和 <code>Compilation</code> 的区别</p><ul><li><code>Compiler</code> 代表了整个 Webpack 从启动到关闭的生命周期</li><li><code>Compilation</code> 只是代表了一次新的编译，只要文件有改动，<code>compilation</code> 就会被重新创建。</li></ul><h3 id="手写插件-1：文件清单"><a href="#手写插件-1：文件清单" class="headerlink" title="手写插件 1：文件清单"></a>手写插件 1：文件清单</h3><p>在每次 webpack 打包之后，自动产生一个一个 markdown 文件清单，记录打包之后的文件夹 dist 里所有的文件的一些信息。</p><p>思路：</p><ol><li>通过 <code>compiler.hooks.emit.tapAsync()</code> 来触发生成资源到 output 目录之前的钩子</li><li>通过 <code>compilation.assets</code> 获取文件数量</li><li>定义 markdown 文件的内容，将文件信息写入 markdown 文件内</li><li>给 dist 文件夹里添加一个资源名称为 fileListName 的变量</li><li>写入资源的内容和文件大小</li><li>执行回调，让 webpack 继续执行</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileListPlugin</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> {</span><br><span class="line">    <span class="comment">// 获取插件配置项</span></span><br><span class="line">    <span class="built_in">this</span>.filename = options &amp;&amp; options.filename ? options.filename : <span class="string">'FILELIST.md'</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> {</span><br><span class="line">    <span class="comment">// 注册 compiler 上的 emit 钩子</span></span><br><span class="line">    compiler.hooks.emit.tapAsync(<span class="string">'FileListPlugin'</span>, <span class="function">(<span class="params">compilation, cb</span>) =&gt;</span> {</span><br><span class="line">      <span class="comment">// 通过 compilation.assets 获取文件数量</span></span><br><span class="line">      <span class="keyword">let</span> len = <span class="built_in">Object</span>.keys(compilation.assets).length</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 添加统计信息</span></span><br><span class="line">      <span class="keyword">let</span> content = <span class="string">`# <span class="subst">${len}</span> file<span class="subst">${len &gt; <span class="number">1</span> ? <span class="string">'s'</span> : <span class="string">''</span>}</span> emitted by webpack\n\n`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过 compilation.assets 获取文件名列表</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> filename <span class="keyword">in</span> compilation.assets) {</span><br><span class="line">        content += <span class="string">`- <span class="subst">${filename}</span>\n`</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 往 compilation.assets 中添加清单文件</span></span><br><span class="line">      compilation.assets[<span class="built_in">this</span>.filename] = {</span><br><span class="line">        <span class="comment">// 写入新文件的内容</span></span><br><span class="line">        source: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">          <span class="keyword">return</span> content</span><br><span class="line">        },</span><br><span class="line">        <span class="comment">// 新文件大小（给 webapck 输出展示用）</span></span><br><span class="line">        size: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">          <span class="keyword">return</span> content.length</span><br><span class="line">        },</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行回调，让 webpack 继续执行</span></span><br><span class="line">      cb()</span><br><span class="line">    })</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = FileListPlugin</span><br></pre></td></tr></tbody></table></figure><h3 id="手写插件-2：去除注释"><a href="#手写插件-2：去除注释" class="headerlink" title="手写插件 2：去除注释"></a>手写插件 2：去除注释</h3><p>开发一个插件能够去除打包后代码的注释，这样我们的 <code>bundle.js</code> 将更容易阅读</p><p>思路：</p><ol><li>通过 <code>compiler.hooks.emit.tap()</code> 来触发生成文件后的钩子</li><li>通过 <code>compilation.assets</code> 拿到生产后的文件，然后去遍历各个文件</li><li>通过 <code>.source()</code> 获取构建产物的文本，然后用正则去 replace 调注释的代码</li><li>更新构建产物对象</li><li>执行回调，让 webpack 继续执行</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoveCommentPlugin</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.options = options</span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> {</span><br><span class="line">    <span class="comment">// 去除注释正则</span></span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/("([^\\\"]*(\\.)?)*")|('([^\\\']*(\\.)?)*')|(\/{2,}.*?(\r|\n))|(\/\*(\n|.)*?\*\/)|(\/\*\*\*\*\*\*\/)/g</span></span><br><span class="line"></span><br><span class="line">    compiler.hooks.emit.tap(<span class="string">'RemoveComment'</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> {</span><br><span class="line">      <span class="comment">// 遍历构建产物，.assets中包含构建产物的文件名</span></span><br><span class="line">      <span class="built_in">Object</span>.keys(compilation.assets).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> {</span><br><span class="line">        <span class="comment">// .source()是获取构建产物的文本</span></span><br><span class="line">        <span class="keyword">let</span> content = compilation.assets[item].source()</span><br><span class="line">        content = content.replace(reg, <span class="function"><span class="keyword">function</span> (<span class="params">word</span>) </span>{</span><br><span class="line">          <span class="comment">// 去除注释后的文本</span></span><br><span class="line">          <span class="keyword">return</span> <span class="regexp">/^\/{2,}/</span>.test(word) || <span class="regexp">/^\/\*!/</span>.test(word) || <span class="regexp">/^\/\*{3,}\//</span>.test(word) ? <span class="string">''</span> : word</span><br><span class="line">        })</span><br><span class="line">        <span class="comment">// 更新构建产物对象</span></span><br><span class="line">        compilation.assets[item] = {</span><br><span class="line">          source: <span class="function">() =&gt;</span> content,</span><br><span class="line">          size: <span class="function">() =&gt;</span> content.length,</span><br><span class="line">        }</span><br><span class="line">      })</span><br><span class="line">    })</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = RemoveCommentPlugin</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/webpack%E4%BC%98%E5%8C%96%E6%89%93%E5%8C%85%E5%A4%A7%E5%85%A8/"/>
      <url>2020/12/29/webpack%E4%BC%98%E5%8C%96%E6%89%93%E5%8C%85%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack-优化打包大全"><a href="#webpack-优化打包大全" class="headerlink" title="webpack 优化打包大全"></a>webpack 优化打包大全</h1><p>随着我们的项目项目越做越大，引入的第三方库会越来越多，打包的依赖也越来越多，每次 build 的时间越来越长，打包出来的文件会越来越大。最糟糕的是单页面应用首页白屏时间长，用户体验差。</p><p>此时优化 webpack 打包方法不可回避。下面我们来整理一下常用的 webpack 打包优化方法。</p><p><strong>我们的目的</strong></p><ul><li>减小打包后的文件大小</li><li>首页按需引入文件，减少白屏时间</li><li>优化 webpack 打包时间</li></ul><h2 id="分析-webpack-打包性能瓶颈"><a href="#分析-webpack-打包性能瓶颈" class="headerlink" title="分析 webpack 打包性能瓶颈"></a>分析 webpack 打包性能瓶颈</h2><p>首先我们来分析一下 webpack 打包性能瓶颈，找出问题所在，然后才能对症下药。</p><h4 id="1、webpack-bundle-analyzer-分析体积"><a href="#1、webpack-bundle-analyzer-分析体积" class="headerlink" title="1、webpack-bundle-analyzer 分析体积"></a>1、webpack-bundle-analyzer 分析体积</h4><ul><li>vue-cli3 需要安装依赖 <code>webpack-bundle-analyzer</code></li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-bundle-analyzer -D</span><br><span class="line"><span class="keyword">const</span> { BundleAnalyzerPlugin } = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>);</span><br><span class="line">plugins:[</span><br><span class="line">  <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><ul><li>vue-cli2 直接在命令行输入 <code>npm run build --report</code>, 构建完成后会在 8888 端口展示大小</li></ul><img src="../img/webpack2.png"><h4 id="2、测量构建时间"><a href="#2、测量构建时间" class="headerlink" title="2、测量构建时间"></a>2、测量构建时间</h4><p>我们可以通过 <code>speed-measure-webpack-plugin</code> 测量你的 webpack 构建期间各个阶段花费的时间。</p><ol><li>步骤一：安装依赖包</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install speed-measure-webpack-plugin --save-dev</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>配置 vue.config.js</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分析打包时间</span></span><br><span class="line"><span class="keyword">const</span> SpeedMeasurePlugin = <span class="built_in">require</span>(<span class="string">'speed-measure-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> SpeedMeasurePlugin()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  configureWebpack: smp.wrap({</span><br><span class="line">    plugins: [<span class="keyword">new</span> BundleAnalyzerPlugin()],</span><br><span class="line">  }),</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>打包构建后会看到以下输出<br><img src="../img/webpack1.png"></p><p><strong>找出问题所在后我们开始来总结一下优化方法。</strong></p><h2 id="1、-按需加载"><a href="#1、-按需加载" class="headerlink" title="1、 按需加载"></a>1、 按需加载</h2><p>1.1 路由组件按需加载</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = [</span><br><span class="line">  {</span><br><span class="line">    path: <span class="string">'/index'</span>,</span><br><span class="line">    component: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>.ensure([], <span class="function">() =&gt;</span> resolve(<span class="built_in">require</span>(<span class="string">'@/components/index'</span>))),</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    path: <span class="string">'/about'</span>,</span><br><span class="line">    component: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>.ensure([], <span class="function">() =&gt;</span> resolve(<span class="built_in">require</span>(<span class="string">'@/components/about'</span>))),</span><br><span class="line">  },</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>1.2 第三方组件和插件。按需加载需引入第三方组件</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入全部组件</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span></span><br><span class="line">Vue.use(ElementUI)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按需引入组件</span></span><br><span class="line"><span class="keyword">import</span> { Button } <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line">Vue.component(Button.name, Button)</span><br></pre></td></tr></tbody></table></figure><p>1.3 对于一些插件，如果只是在个别组件中用的到，也可以不要在 main.js 里面引入，而是在组件中按需引入</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在main.js引入</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> vue</span><br><span class="line"><span class="keyword">import</span> Vuelidate <span class="keyword">from</span> <span class="string">'vuelidate'</span></span><br><span class="line">Vue.use(Vuelidate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按组件按需引入</span></span><br><span class="line"><span class="keyword">import</span> { Vuelidate } <span class="keyword">from</span> <span class="string">'vuelidate'</span></span><br></pre></td></tr></tbody></table></figure><p>1.4 去除打包后文件的预加载 prefetch/preload</p><p>vuecli 3 默认开启 prefetch(预先加载模块)，提前获取用户未来可能会访问的内容，在首屏会把这十几个路由文件，都一口气下载了。所以我们要关闭这个功能</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//细节配置修改</span></span><br><span class="line">chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 移除 prefetch 插件</span></span><br><span class="line">  config.plugins.delete(<span class="string">'prefetch-index'</span>)</span><br><span class="line">  <span class="comment">// 移除 preload 插件</span></span><br><span class="line">  config.plugins.delete(<span class="string">'preload-index'</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>preload 是告诉浏览器页面必定需要的资源，浏览器一定会加载这些资源</li><li>prefetch 是告诉浏览器页面可能需要的资源，浏览器不一定会加载这些资源</li></ul><p>当 prefetch 插件被禁用时，你可以通过 webpack 的内联注释手动选定要提前获取的代码区块：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPrefetch: true */</span> <span class="string">'./someAsyncComponent.vue'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="2、缩小构建目标"><a href="#2、缩小构建目标" class="headerlink" title="2、缩小构建目标"></a>2、缩小构建目标</h2><h4 id="优化-loader-配置"><a href="#优化-loader-配置" class="headerlink" title="优化 loader 配置"></a>优化 loader 配置</h4><p>排除 Webpack 不需要解析的模块，即使用 loader 的时候，在尽量少的模块中去使用。</p><ul><li>优化正则匹配</li><li>通过 <code>cacheDirectory</code> 选项开启缓存</li><li>通过 <code>include、exclude</code> 来减少被处理的文件。</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: {</span><br><span class="line">  rules: [</span><br><span class="line">    {</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader?cacheDirectory'</span>,</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">    },</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 loader 使用此 loader。</p><h4 id="合理使用-resolve-extensions"><a href="#合理使用-resolve-extensions" class="headerlink" title="合理使用 resolve.extensions"></a>合理使用 resolve.extensions</h4><p>在导入语句没带文件后缀时，Webpack 会自动带上后缀后去尝试询问文件是否存在，查询的顺序是按照我们配置 的 resolve.extensions 顺序从前到后查找，Webpack 默认支持的后缀是 js 与 json。</p><h4 id="配置别名-alias"><a href="#配置别名-alias" class="headerlink" title="配置别名 alias"></a>配置别名 alias</h4><p>alias 的意思为 别名，能把原导入路径映射成一个新的导入路径，我们可以使用 alias 配置来减少查找过程。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resolve: {</span><br><span class="line">  extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>],</span><br><span class="line">  alias: {</span><br><span class="line">    <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span>,</span><br><span class="line">    <span class="string">'@'</span>: resolve(<span class="string">'src'</span>),</span><br><span class="line">  }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-module-noParse"><a href="#使用-module-noParse" class="headerlink" title="使用 module.noParse:"></a>使用 module.noParse:</h4><p>让 webpack 忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能。 因为如 <code>jQuery</code> 、<code>echart</code> 等库庞大又没有采用模块化标准，让 webpack 去解析这些文件耗时又没有意义。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:{</span><br><span class="line">noParse:<span class="regexp">/jquery/</span>,<span class="comment">//不去解析jquery中的依赖库</span></span><br><span class="line">  ...</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><h2 id="4、生产环境关闭-sourceMap"><a href="#4、生产环境关闭-sourceMap" class="headerlink" title="4、生产环境关闭 sourceMap"></a>4、生产环境关闭 sourceMap</h2><p><code>sourceMap</code> 本质上是一种映射关系，打包出来的 js 文件中的代码可以映射到代码文件的具体位置,这种映射关系会帮助我们直接找到在源代码中的错误。<br>在生产环境，打包速度减慢，生产文件变大，所以开发环境使用 <code>sourceMap</code>，生产环境则关闭。</p><p>sourceMap 的种类</p><ul><li>source-map: 会生成 map 格式的文件，里面包含映射关系的代码</li><li>inline-source-map: 不会生成 map 格式的文件，包含映射关系的代码会放在打包后生成的代码中</li><li>inline-cheap-source-map: 一是将错误只定位到行，不定位到列。二是映射业务代码，不映射 loader 和第三方库等。会提升打包构建的速度。</li><li>inline-cheap-module-source-map: module 会映射 loader 和第三方库</li><li>eval: 用 eval 的方式生成映射关系代码，效率和性能最佳。但是当代码复杂时，提示信息可能不精确。</li></ul><h2 id="5、代码压缩"><a href="#5、代码压缩" class="headerlink" title="5、代码压缩"></a>5、代码压缩</h2><h4 id="UglifyJS"><a href="#UglifyJS" class="headerlink" title="UglifyJS"></a>UglifyJS</h4><p><code>UglifyJS</code> 是 vue-cli 默认使用的压缩代码方式，它使用的是单线程压缩代码，打包时间较慢。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> UglifyJsPlugin({</span><br><span class="line">    uglifyOptions: {</span><br><span class="line">      compress: {</span><br><span class="line">        warnings: <span class="literal">false</span></span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line">    sourceMap: <span class="literal">true</span>,</span><br><span class="line">    parallel: <span class="literal">true</span></span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure><h4 id="ParallelUglifyPlugin"><a href="#ParallelUglifyPlugin" class="headerlink" title="ParallelUglifyPlugin"></a>ParallelUglifyPlugin</h4><p><code>ParallelUglifyPlugin</code> 开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，每个子进程其实还是通过 <code>UglifyJS</code> 去压缩代码，但是变成了并行执行。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> ParallelUglifyPlugin({</span><br><span class="line">    <span class="comment">//缓存压缩后的结果，下次遇到一样的输入时直接从缓存中获取压缩后的结果并返回，</span></span><br><span class="line">    <span class="comment">//cacheDir 用于配置缓存存放的目录路径。</span></span><br><span class="line">    cacheDir: <span class="string">'.cache/'</span>,</span><br><span class="line">    sourceMap: <span class="literal">true</span>,</span><br><span class="line">    uglifyJS: {</span><br><span class="line">      output: {</span><br><span class="line">        comments: <span class="literal">false</span>,</span><br><span class="line">      },</span><br><span class="line">      compress: {</span><br><span class="line">        warnings: <span class="literal">false</span>,</span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">  }),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>打包速度和打包后的文件大小啊对比<br>| 方法 | 文件大小 | 打包速度 |<br>| —————— | :——- | :——- |<br>| 不用插件 | 14.6M | 32s |<br>| UglifyJsPlugin | 12.9M | 33s |<br>| ParallelUglifyPlugi | 7.98M | 17s |</p><h4 id="terser-webpack-plugin"><a href="#terser-webpack-plugin" class="headerlink" title="terser-webpack-plugin"></a>terser-webpack-plugin</h4><p>Webpack4.0 默认是使用 <code>terser-webpack-plugin</code> 这个压缩插件，在此之前是使用 <code>uglifyjs-webpack-plugin</code>，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 <code>parallel</code> 参数，使用多进程压缩，加快压缩。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>) <span class="comment">// 压缩js代码</span></span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>) <span class="comment">// 压缩css代码</span></span><br><span class="line"></span><br><span class="line">optimization: {</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="keyword">new</span> TerserPlugin({</span><br><span class="line">      parallel: <span class="number">4</span>, <span class="comment">// 开启几个进程来处理压缩，默认是 os.cpus().length - 1</span></span><br><span class="line">      cache: <span class="literal">true</span>, <span class="comment">// 是否缓存</span></span><br><span class="line">      sourceMap: <span class="literal">false</span>,</span><br><span class="line">    }),</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="CSS-压缩"><a href="#CSS-压缩" class="headerlink" title="CSS 压缩"></a>CSS 压缩</h4><p>我们可以借助 optimize-css-assets-webpack-plugin 插件来压缩 css，其默认使用的压缩引擎是 cssnano</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>) <span class="comment">// 压缩css代码</span></span><br><span class="line"></span><br><span class="line">optimization: {</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="comment">// 压缩css</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCSSAssetsPlugin({}),</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="6、提取公共代码"><a href="#6、提取公共代码" class="headerlink" title="6、提取公共代码"></a>6、提取公共代码</h2><p>在用 webpack 打包的时候，对于一些不经常更新的第三方库，比如 <code>react，lodash，vue</code> 我们希望能和自己的代码分离开，webpack 社区有以下两种方案：</p><h4 id="CommonsChunkPlugin-及-splitChunks"><a href="#CommonsChunkPlugin-及-splitChunks" class="headerlink" title="CommonsChunkPlugin 及 splitChunks"></a>CommonsChunkPlugin 及 splitChunks</h4><p>通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。</p><p>webpack3 使用 <code>CommonsChunkPlugin</code> 的实现：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin({</span><br><span class="line">    name: <span class="string">'vendor'</span>,</span><br><span class="line">    minChunks: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, count</span>) </span>{</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">module</span>.resource, <span class="string">`引用次数<span class="subst">${count}</span>`</span>)</span><br><span class="line">      <span class="comment">//"有正在处理文件" + "这个文件是 .js 后缀" + "这个文件是在 node_modules 中"</span></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="built_in">module</span>.resource &amp;&amp;</span><br><span class="line">        /\.js$/.test(<span class="built_in">module</span>.resource) &amp;&amp;</span><br><span class="line">        <span class="built_in">module</span>.resource.indexOf(path.join(__dirname, <span class="string">'./node_modules'</span>)) === <span class="number">0</span></span><br><span class="line">      )</span><br><span class="line">    },</span><br><span class="line">  }),</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin({</span><br><span class="line">    name: <span class="string">'common'</span>,</span><br><span class="line">    chunks: <span class="string">'initial'</span>,</span><br><span class="line">    minChunks: <span class="number">2</span>,</span><br><span class="line">  }),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>webpack4 使用 <code>splitChunks</code> 的实现：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  optimization: {</span><br><span class="line">    splitChunks: {</span><br><span class="line">      cacheGroups: {</span><br><span class="line">        vendor: {</span><br><span class="line">          priority: <span class="number">1</span>, <span class="comment">//添加权重</span></span><br><span class="line">          test: <span class="regexp">/node_modules/</span>, <span class="comment">//把这个目录下符合下面几个条件的库抽离出来</span></span><br><span class="line">          chunks: <span class="string">'initial'</span>, <span class="comment">//刚开始就要抽离</span></span><br><span class="line">          minChunks: <span class="number">2</span>, <span class="comment">//重复2次使用的时候需要抽离出来</span></span><br><span class="line">        },</span><br><span class="line">        common: {</span><br><span class="line">          <span class="comment">//公共的模块</span></span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">        },</span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">  },</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="DLLPlugin"><a href="#DLLPlugin" class="headerlink" title="DLLPlugin"></a>DLLPlugin</h4><p>webpack.DllPlugin 就是来解决这个问题的插件，使用它可以在第一次编译打包后就生成一份不变的代码供其他模块引用，这样下一次构建的时候就可以节省开发时编译打包的时间。</p><p>1、在 build 下创建 <code>webpack.dll.config.js</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  entry: {</span><br><span class="line">    vendor: [</span><br><span class="line">      <span class="string">'vue-router'</span>,</span><br><span class="line">      <span class="string">'vuex'</span>,</span><br><span class="line">      <span class="string">'vue/dist/vue.common.js'</span>,</span><br><span class="line">      <span class="string">'vue/dist/vue.js'</span>,</span><br><span class="line">      <span class="string">'vue-loader/lib/component-normalizer.js'</span>,</span><br><span class="line">      <span class="string">'vue'</span>,</span><br><span class="line">      <span class="string">'axios'</span>,</span><br><span class="line">      <span class="string">'echarts'</span>,</span><br><span class="line">    ],</span><br><span class="line">  },</span><br><span class="line">  output: {</span><br><span class="line">    path: path.resolve(<span class="string">'./dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">    library: <span class="string">'[name]_library'</span>,</span><br><span class="line">  },</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin({</span><br><span class="line">      path: path.resolve(<span class="string">'./dist'</span>, <span class="string">'[name]-manifest.json'</span>),</span><br><span class="line">      name: <span class="string">'[name]_library'</span>,</span><br><span class="line">    }),</span><br><span class="line">    <span class="comment">// 建议加上代码压缩插件，否则dll包会比较大。</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin({</span><br><span class="line">      compress: {</span><br><span class="line">        warnings: <span class="literal">false</span>,</span><br><span class="line">      },</span><br><span class="line">    }),</span><br><span class="line">  ],</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><code>library</code> 的意思其实就是将 dll 文件以一个全局变量的形式导出出去，便于接下来引用。</li><li><code>mainfest.json</code> 文件是一个映射关系，它的作用就是帮助 webpack 使用我们之前打包好的 <code>***.dll.js</code> 文件，而不是重新再去 <code>node_modules</code> 中去寻找。</li></ul><p>2、在 <code>webpack.prod.conf.js</code> 的 plugin 后面加入配置</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DllReferencePlugin({</span><br><span class="line">  manifest: <span class="built_in">require</span>(<span class="string">'../dist/vendor-manifest.json'</span>),</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>3、<code>package.json</code>文件中添加快捷命令<code>(build:dll)</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: {</span><br><span class="line">  <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js"</span>,</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"npm run dev"</span>,</span><br><span class="line">  <span class="string">"lint"</span>: <span class="string">"eslint --ext .js,.vue src"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"node build/build.js"</span>,</span><br><span class="line">  <span class="string">"build:dll"</span>: <span class="string">"webpack --config build/webpack.dll.conf.js"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>生产环境打包的时候先<code>npm run build:dll</code>命令会在打包目录下生成 <code>vendor-manifest.json</code> 文件与 vendor.dll.js 文件。然后<code>npm run build</code>生产其他文件。</p><p>4、根目录下的入口 <code>index.html</code> 加入引用</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./vendor.dll.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="7、CDN-优化"><a href="#7、CDN-优化" class="headerlink" title="7、CDN 优化"></a>7、CDN 优化</h2><ul><li>随着项目越做越大，依赖的第三方 npm 包越来越多，构建之后的文件也会越来越大。</li><li>再加上又是单页应用，这就会导致在网速较慢或者服务器带宽有限的情况出现长时间的白屏。</li></ul><p>1、将 <code>vue、vue-router、vuex、element-ui 和 axios</code> 这五个库，全部改为通过 CDN 链接获取，在 <code>index.html</code> 里插入 相应链接。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.bootcss.com/element-ui/2.0.7/theme-chalk/index.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.10/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vuex/3.1.0/vuex.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue-router/3.0.2/vue-router.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/element-ui/2.6.1/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>2、在 <code>webpack.config.js</code> 配置文件</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line"> ···</span><br><span class="line">    externals: {</span><br><span class="line">      <span class="string">'vue'</span>: <span class="string">'Vue'</span>,</span><br><span class="line">      <span class="string">'vuex'</span>: <span class="string">'Vuex'</span>,</span><br><span class="line">      <span class="string">'vue-router'</span>: <span class="string">'VueRouter'</span>,</span><br><span class="line">      <span class="string">'element-ui'</span>: <span class="string">'ELEMENT'</span>,</span><br><span class="line">      <span class="string">'Axios'</span>:<span class="string">'axios'</span></span><br><span class="line">    }</span><br><span class="line">  },</span><br></pre></td></tr></tbody></table></figure><p>3、卸载依赖的 npm 包</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall axios element-ui vue vue-router vuex</span><br></pre></td></tr></tbody></table></figure><p>4、修改 <code>main.js</code> 文件里之前的引包方式</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import Vue from 'vue'</span></span><br><span class="line"><span class="comment">// import ElementUI from 'element-ui'</span></span><br><span class="line"><span class="comment">// import 'element-ui/lib/theme-chalk/index.css'</span></span><br><span class="line"><span class="comment">// import VueRouter from 'vue-router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'./utils/Utils'</span></span><br><span class="line"></span><br><span class="line">Vue.use(ELEMENT)</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter({</span><br><span class="line">  mode: <span class="string">'hash'</span>, <span class="comment">//路由的模式</span></span><br><span class="line">  routes,</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue({</span><br><span class="line">  router,</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="html-webpack-externals-plugin"><a href="#html-webpack-externals-plugin" class="headerlink" title="html-webpack-externals-plugin"></a>html-webpack-externals-plugin</h4><p>这种方法每次都需要在 index.html 模板中手动引入需要的 cdn 文件，然后还要在 webpack 里配置，有点繁琐了<br><code>html-webpack-externals-plugin</code>这样的插件就应运而生了。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js文件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackExternalsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-externals-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackExternalsPlugin({</span><br><span class="line">      externals: [</span><br><span class="line">        {</span><br><span class="line">          <span class="comment">// 引入的模块</span></span><br><span class="line">          <span class="built_in">module</span>: <span class="string">'jquery'</span>,</span><br><span class="line">          <span class="comment">// cdn的地址</span></span><br><span class="line">          entry: <span class="string">'https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js'</span>,</span><br><span class="line">          <span class="comment">// 挂载到了window上的名称</span></span><br><span class="line">          <span class="built_in">global</span>: <span class="string">'jQuery'</span>,</span><br><span class="line">        },</span><br><span class="line">        {</span><br><span class="line">          <span class="built_in">module</span>: <span class="string">'vue'</span>,</span><br><span class="line">          entry: <span class="string">'https://cdn.bootcss.com/vue/2.6.10/vue.min.js'</span>,</span><br><span class="line">          <span class="built_in">global</span>: <span class="string">'Vue'</span>,</span><br><span class="line">        },</span><br><span class="line">      ],</span><br><span class="line">    }),</span><br><span class="line">  ],</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="8、多进程解析和处理文件"><a href="#8、多进程解析和处理文件" class="headerlink" title="8、多进程解析和处理文件"></a>8、多进程解析和处理文件</h2><p>由于运行在 Node.js 之上的 webpack 是单线程模型的，所以 webpack 需要处理的事情需要一件一件的做，不能多件事一起做。当 webpack 需要打包大量文件时，打包时间就会比较漫长。</p><p>以下两个方法能让 webpack 在同一时刻处理多个任务发挥多核 CPU 电脑的功能，提升构建速度。</p><h4 id="thread-loader"><a href="#thread-loader" class="headerlink" title="thread loader"></a>thread loader</h4><p>把这个 <code>thread loader</code> 放置在其他 loader 之前， 放置在这个 loader 之后的 loader 就会在一个单独的 worker 池(worker pool)中运行。</p><p>在 worker 池(worker pool)中运行的 loader 是受到限制的。例如：</p><ul><li>这些 loader 不能产生新的文件。</li><li>这些 loader 不能使用定制的 loader API（也就是说，通过插件）。</li><li>这些 loader 无法获取 webpack 的选项设置。</li></ul><p>每个 worker 都是一个单独的有 600ms 限制的 node.js 进程。同时跨进程的数据交换也会被限制。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  <span class="built_in">module</span>: {</span><br><span class="line">    rules: [</span><br><span class="line">      {</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        include: path.resolve(<span class="string">'src'</span>),</span><br><span class="line">        use: [<span class="string">'thread-loader'</span>, <span class="string">'expensive-loader'</span>],</span><br><span class="line">      },</span><br><span class="line">    ],</span><br><span class="line">  },</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h4><p><code>HappyPack</code> 能让 webpack 把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。要注意的是 HappyPack 对 file-loader、url-loader 支持的不友好，所以不建议对该 loader 使用。</p><p>使用方法如下：</p><p>1、 HappyPack 插件安装</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D happypack</span><br></pre></td></tr></tbody></table></figure><p>2、 <code>webpack.base.conf.js</code> 文件对 module.rules 进行配置</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: {</span><br><span class="line">  rules: [</span><br><span class="line">    {</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: [<span class="string">'happypack/loader?id=babel'</span>],</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>), resolve(<span class="string">'test'</span>)],</span><br><span class="line">      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>),</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">      test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">      use: [<span class="string">'happypack/loader?id=vue'</span>],</span><br><span class="line">    },</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3、在生产环境 <code>webpack.prod.conf.js</code> 文件进行配置</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>)</span><br><span class="line"><span class="comment">// 构造出共享进程池，在进程池中包含5个子进程</span></span><br><span class="line"><span class="keyword">const</span> HappyPackThreadPool = HappyPack.ThreadPool({ <span class="attr">size</span>: <span class="number">5</span> })</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HappyPack({</span><br><span class="line">    <span class="comment">// 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件</span></span><br><span class="line">    id: <span class="string">'babel'</span>,</span><br><span class="line">    <span class="comment">// 如何处理.js文件，用法和Loader配置中一样</span></span><br><span class="line">    loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">    threadPool: HappyPackThreadPool,</span><br><span class="line">  }),</span><br><span class="line">  <span class="keyword">new</span> HappyPack({</span><br><span class="line">    id: <span class="string">'vue'</span>, <span class="comment">// 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件</span></span><br><span class="line">    loaders: [</span><br><span class="line">      {</span><br><span class="line">        loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">        options: vueLoaderConfig,</span><br><span class="line">      },</span><br><span class="line">    ],</span><br><span class="line">    threadPool: HappyPackThreadPool,</span><br><span class="line">  }),</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p><strong>注意，当项目较小时，多线程打包反而会使打包速度变慢。</strong></p><h2 id="启用-gzip-压缩"><a href="#启用-gzip-压缩" class="headerlink" title="启用 gzip 压缩"></a>启用 gzip 压缩</h2><p>使用 Gzip 两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。</p><p>1、安装依赖</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i compression-webpack-plugin --save</span><br></pre></td></tr></tbody></table></figure><p>2、在 vue.congig.js 中引入并修改 webpack 配置</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  configureWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">if</span> (progress.env.NODE_ENV === <span class="string">'production'</span>) {</span><br><span class="line">      <span class="keyword">return</span> {</span><br><span class="line">        plugins: [</span><br><span class="line">          <span class="keyword">new</span> CompressionPlugin({</span><br><span class="line">            test: <span class="regexp">/\.js$|\.html$|.\css/</span>, <span class="comment">//匹配文件名</span></span><br><span class="line">            threshold: <span class="number">10240</span>, <span class="comment">//对超过10k的数据压缩</span></span><br><span class="line">            deleteOriginalAssets: <span class="literal">false</span>, <span class="comment">//不删除源文件</span></span><br><span class="line">          }),</span><br><span class="line">        ],</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>比较实用的方法: 按需加载，优化 loader 配置，关闭生产环境的 sourceMap，CDN 优化。</li><li>vue-cli 已做的优化： 代码压缩，提取公共代码，再优化空间不大。</li><li>根据项目实际需要和自身开发水平选择优化方法，必须避免因为优化产生 bug。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/2020%E5%B9%B4%E4%BD%A0%E4%B8%8D%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
      <url>2020/12/29/2020%E5%B9%B4%E4%BD%A0%E4%B8%8D%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在很久很久以前，在我们前端还只是页面切图仔的年代，我们开发一个html页面，通常会遇到这些情况：</p><ul><li>需要引入十几个css和js文件，而且因为他们彼此间有着依赖关系，所以引入的顺序还不能乱。</li><li>传统的<code>html+css+js</code>开发方式不能不能很好地运用<code>less/scss</code>等css预处理器以及<code>ES6+</code>的高级语法。</li><li>代码复用性差，可维护性差。  </li></ul><p>此时就需要一个处理这些问题的工具，webpack应运而生。</p><p>webpack可以看做是模块打包工具：它将各种静态资源（比如：<code>javaScript</code> 文件，图片文件，<code>css</code>文件等）视为模块，它能够对这些模块进行解析优化和转换等操作，最后将它们打包在一起，打包后的文件可用于在浏览器中使用。</p><h3 id="webpack的优点："><a href="#webpack的优点：" class="headerlink" title="webpack的优点："></a>webpack的优点：</h3><ul><li>代码转换: <code>typeScript</code> 编译成 <code>javaScript</code>、<code>scss，less</code> 编译成 <code>css</code>.</li><li>文件优化：压缩 <code>javaScript</code>、<code>css</code>、<code>html</code> 代码，压缩合并图片。</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li><li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li><li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</li><li>扩展性强，插件机制完善。</li></ul><h3 id="webpack打包过程："><a href="#webpack打包过程：" class="headerlink" title="webpack打包过程："></a>webpack打包过程：</h3><ol><li>利用babel完成代码转换,并生成单个文件的依赖</li><li>从入口开始递归分析，并生成依赖图谱</li><li>将各个引用模块打包为一个立即执行函数</li><li>将最终的bundle文件写入bundle.js中</li></ol><h3 id="Webpack-的四大核心："><a href="#Webpack-的四大核心：" class="headerlink" title="Webpack 的四大核心："></a>Webpack 的四大核心：</h3><ul><li>entry：js 入口源文件</li><li>output：生成文件</li><li>loader：进行文件处理</li><li>plugins：插件，比 loader 更强大，能使用更多 webpack 的 api</li></ul><h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>webpack 应该使用哪个模块做为入口文件，来作为构建其内部依赖图的开始。进去入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的，每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。  </p><p>单⼊⼝：entry 是⼀个字符串</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>多⼊⼝：entry 是⼀个对象</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  entry: {</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    manager: <span class="string">'./src/manager.js'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，这些都可以在webpack的配置文件中指定。</p><p>单⼊⼝配置</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: {</span><br><span class="line">        filename: <span class="string">'bundle.js’,</span></span><br><span class="line"><span class="string">        path: __dirname + '</span>/dist<span class="string">'</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">};</span></span><br></pre></td></tr></tbody></table></figure><p>多⼊⼝配置</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = {</span><br><span class="line">  entry: {</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    search: <span class="string">'./src/search.js'</span></span><br><span class="line">  },</span><br><span class="line">  output: {</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过[name]占位符确保⽂件名称的唯⼀</p><h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p><code>loader</code> 让 <code>webpack</code> 能够去处理那些非 <code>javaScript</code> 文件（<code>webpack</code> 自身只理解 <code>javaScript</code>）。<code>loader</code> 可以将所有类型的文件转换为 <code>webpack</code> 能够处理的有效模块，然后你就可以利用 <code>webpack</code> 的打包能力，对它们进行处理。</p><h3 id="loader的特点"><a href="#loader的特点" class="headerlink" title="loader的特点"></a>loader的特点</h3><ul><li>一个Loader 的职责是单一的，只需要完成一种转换</li><li>一个Loader 其实就是一个Node.js 模块，这个模块需要导出一个函数</li><li>loader 总是从右到左地被调用。</li></ul><h3 id="常用的loader"><a href="#常用的loader" class="headerlink" title="常用的loader"></a>常用的loader</h3><h4 id="处理样式"><a href="#处理样式" class="headerlink" title="处理样式"></a>处理样式</h4><ul><li><code>css-loader</code>: 加载.css 文件，</li><li><code>style-loader</code>:使用 style 标签将 <code>css-loader</code> 内部样式注入到我们的 html 页面</li><li><code>less-loader, sass-loader</code>: 解析css预处理器</li></ul><h4 id="处理-js"><a href="#处理-js" class="headerlink" title="处理 js"></a>处理 js</h4><ul><li>让你能使用最新的js代码（ES6，ES7…）</li><li>让你能使用基于js进行了拓展的语言，比如React的JSX；</li></ul><h4 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h4><p>处理图片资源时，我们常用的两种loader是<code>file-loader</code>或者<code>url-loader</code>，两者的主要差异在于。<code>url-loader</code>可以设置图片大小限制，当图片超过限制时，其表现行为等同于<code>file-loader</code>，而当图片不超过限制时，则会将图片以<code>base64</code>的形式打包进css文件，以减少请求次数</p><h4 id="处理-vue文件"><a href="#处理-vue文件" class="headerlink" title="处理.vue文件"></a>处理.vue文件</h4><p><code>vue-loader</code> 是 <code>webpack</code> 的加载器模块，它使我们可以用 <code>.vue</code> 文件格式编写单文件组件。单文件组件文件有三个部分，即模板、脚本和样式。 <code>vue-loader</code> 模块允许 <code>webpack</code> 使用单独的加载器模块（例如 <code>sass 或 scss 加载器</code>）提取和处理每个部分。该设置使我们可以使用 <code>.vue</code> 文件无缝编写程序。</p><h3 id="开发一个loader"><a href="#开发一个loader" class="headerlink" title="开发一个loader"></a>开发一个loader</h3><!-- 1. 基本形式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source </span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> source; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>调用第三方模块<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sass= <span class="built_in">require</span>(<span class="string">&#x27;node-sass&#x27;</span>); </span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> sass(source);</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` --&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">需求：手写一个 `</span><span class="string">`loader`</span><span class="string">`，将 `</span><span class="string">`&#x27;kobe&#x27;`</span><span class="string">` 转换成 `</span><span class="string">`&#x27;Black Mamba&#x27;`</span><span class="string">`。当然大家可以根据自己的需求进行设计。这里只是讲解方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 1、编写 loader</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在根目录下，新建目录 `</span><span class="string">`kobe-loader`</span><span class="string">` 作为我们编写 `</span><span class="string">`loader`</span><span class="string">` 的名称，执行 `</span><span class="string">`npm init -y`</span><span class="string">` 命令，新建一个模块化项目，然后新建 `</span><span class="string">`index.js`</span><span class="string">` 文件，相关源码如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> content &amp;&amp; content.replace(<span class="regexp">/kobe/gi</span>, <span class="string">&#x27;Black Mamba&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、注册模块"><a href="#2、注册模块" class="headerlink" title="2、注册模块"></a>2、注册模块</h4></li></ol><p>正常我们安装的 <code>loader</code> 是从 <code>npm</code> 下载安装，但是我们可以在 <code>kobe-loader</code> 目录底下使用 <code>npm link</code> 做到在不发布模块的情况下，将本地的一个正在开发的模块的源码链接到项目的 <code>node_modules</code> 目录下，让项目可以直接使用本地的 <code>npm</code> 模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><p>然后在项目根目录执行以下命令，将注册到全局的本地 <code>npm</code> 模块链接到项目的 <code>node_modules</code> 下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm link kobe-loader</span><br></pre></td></tr></table></figure><p>注册成功后，我们可以在 <code>node_modules</code> 目录下能查找到对应的 <code>loader</code>。</p><h4 id="3、在-webpack-中配置-loader"><a href="#3、在-webpack-中配置-loader" class="headerlink" title="3、在 webpack 中配置 loader"></a>3、在 webpack 中配置 loader</h4><p>在 <code>webpack.base.conf.js</code> 加上如下配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test:<span class="regexp">/\.js/</span>,</span><br><span class="line">  loader: <span class="string">&#x27;kobe-loader&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们在所有 js 文件下书写的 <code>&#39;kobe&#39;</code> 就全部替换成 <code>&#39;Black Mamba&#39;</code>了。</p><h4 id="4、配置参数"><a href="#4、配置参数" class="headerlink" title="4、配置参数"></a>4、配置参数</h4><p>上面我们是写死的替换文案，假如我想通过配置项来改变，可以在 loader 中做以下调整</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// custom-loader/index.js</span></span><br><span class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">&#x27;loader-utils&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = utils.getOptions(<span class="built_in">this</span>)</span><br><span class="line">  <span class="keyword">return</span> content &amp;&amp; content.replace(<span class="regexp">/kobe/gi</span>, options.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.base.conf.js</span></span><br><span class="line">&#123;</span><br><span class="line">  test:<span class="regexp">/\.js/</span>,</span><br><span class="line">  use: &#123;</span><br><span class="line">    loader: <span class="string">&#x27;kobe-loader&#x27;</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      name: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><p>专注处理 webpack 在编译过程中的某个特定的任务的功能模块，可以称为插件。</p><h3 id="Plugin-的特点"><a href="#Plugin-的特点" class="headerlink" title="Plugin 的特点"></a>Plugin 的特点</h3><ul><li>是一个独立的模块</li><li>模块对外暴露一个 js 函数</li><li>函数的原型 <code>(prototype)</code> 上定义了一个注入 <code>compiler</code> 对象的 <code>apply </code>方法 <code>apply</code> 函数中需要有通过 <code>compiler</code> 对象挂载的 <code>webpack</code> 事件钩子，钩子的回调中能拿到当前编译的 <code>compilation</code> 对象，如果是异步编译插件的话可以拿到回调 <code>callback</code></li><li>完成自定义子编译流程并处理 <code>complition</code> 对象的内部数据</li><li>如果异步编译插件的话，数据处理完成后执行 <code>callback</code> 回调。</li></ul><h3 id="常用Plugin"><a href="#常用Plugin" class="headerlink" title="常用Plugin"></a>常用Plugin</h3><ul><li><p><code>HotModuleReplacementPlugin</code> 代码热替换。因为 <code>Hot-Module-Replacement</code> 的热更新是依赖于 <code>webpack-dev-server</code>，后者是在打包文件改变时更新打包文件或者 reload 刷新整个页面，<code>HRM</code> 是只更新修改的部分。</p></li><li><p><code>HtmlWebpackPlugin</code>, 生成 html 文件。将 webpack 中<code>entry</code>配置的相关入口 chunk 和 <code>extract-text-webpack-plugin</code>抽取的 css 样式 插入到该插件提供的<code>template</code>或者<code>templateContent</code>配置项指定的内容基础上生成一个 html 文件，具体插入方式是将样式<code>link</code>插入到<code>head</code>元素中，<code>script</code>插入到<code>head</code>或者<code>body</code>中。</p></li><li><p><code>ExtractTextPlugin</code>, 将 css 成生文件，而非内联 。该插件的主要是为了抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象。</p></li><li><p><code>NoErrorsPlugin</code>报错但不退出 webpack 进程</p></li><li><p><code>UglifyJsPlugin</code>，代码丑化，开发过程中不建议打开。 <code>uglifyJsPlugin</code> 用来对 js 文件进行压缩，从而减小 js 文件的大小，加速 load 速度。<code>uglifyJsPlugin</code> 会拖慢 webpack 的编译速度，所有建议在开发简单将其关闭，部署的时候再将其打开。多个 html 共用一个 js 文件(chunk)，可用 <code>CommonsChunkPlugin</code></p></li><li><p><code>purifycss-webpack</code>  。打包编译时，可剔除页面和 js 中未被使用的 css，这样使用第三方的类库时，只加载被使用的类，大大减小 css 体积</p></li><li><p><code>optimize-css-assets-webpack-plugin</code>   压缩 css，优化 css 结构，利于网页加载和渲染</p></li><li><p><code>webpack-parallel-uglify-plugin</code>   可以并行运行 UglifyJS 插件，这可以有效减少构建时间</p></li></ul><h3 id="开发一个-plugin"><a href="#开发一个-plugin" class="headerlink" title="开发一个 plugin"></a>开发一个 plugin</h3><ul><li>Webpack 在编译过程中，会广播很多事件，例如 run、compile、done、fail 等等，可以查看官网；</li><li>Webpack 的事件流机制应用了观察者模式，我们编写的插件可以监听 Webpack 事件来触发对应的处理逻辑；</li><li>插件中可以使用很多 Webpack 提供的 API，例如读取输出资源、代码块、模块及依赖等；</li></ul><h4 id="1、编写插件"><a href="#1、编写插件" class="headerlink" title="1、编写插件"></a>1、编写插件</h4><p>在根目录下，新建目录 my-plugin 作为我们编写插件的名称，执行 npm init -y 命令，新建一个模块化项目，然后新建 index.js 文件，相关源码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">doneCallback, failCallback</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存在创建插件实例时传入的回调函数</span></span><br><span class="line">    <span class="built_in">this</span>.doneCallback = doneCallback</span><br><span class="line">    <span class="built_in">this</span>.failCallback = failCallback</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 成功完成一次完整的编译和输出流程时，会触发 done 事件</span></span><br><span class="line">    compiler.plugin(<span class="string">&#x27;done&#x27;</span>, <span class="function"><span class="params">stats</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.doneCallback(stats)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 在编译和输出的流程中遇到异常时，会触发 failed 事件</span></span><br><span class="line">    compiler.plugin(<span class="string">&#x27;failed&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.failCallback(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = MyPlugin</span><br></pre></td></tr></table></figure><h4 id="2、注册模块-1"><a href="#2、注册模块-1" class="headerlink" title="2、注册模块"></a>2、注册模块</h4><p>按照以上的方法，我们在 my-plugin 目录底下使用 npm link 做到在不发布模块的情况下，将本地的一个正在开发的模块的源码链接到项目的 node_modules 目录下，让项目可以直接使用本地的 npm 模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><p>然后在项目根目录执行以下命令，将注册到全局的本地 npm 模块链接到项目的 node_modules 下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm link my-plugin</span><br></pre></td></tr></table></figure><p>注册成功后，我们可以在 node_modules 目录下能查找到对应的插件了。</p><h4 id="3、配置插件"><a href="#3、配置插件" class="headerlink" title="3、配置插件"></a>3、配置插件</h4><p>在 webpack.base.conf.js 加上如下配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> MyPlugin(</span><br><span class="line">    stats =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.info(<span class="string">&#x27;编译成功!&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">&#x27;编译失败!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>执行运行 or 编译命令，就能看到我们的 plugin 起作用了。</p>-->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E8%B0%88%E8%B0%88%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%89%88vuex/"/>
      <url>2020/12/29/%E8%B0%88%E8%B0%88%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%89%88vuex/</url>
      
        <content type="html"><![CDATA[<h3 id="数据状态管理"><a href="#数据状态管理" class="headerlink" title="数据状态管理"></a>数据状态管理</h3><p>首先说说什么叫“前端状态”。所有程序都有“状态”，状态表现在代码中的各种类型的变量，在程序运行的过程中发生改变的过程，而我们编写的程序就是在控制这些“状态”如何发生改变。</p><h4 id="为什么要进行数据状态管理"><a href="#为什么要进行数据状态管理" class="headerlink" title="为什么要进行数据状态管理"></a>为什么要进行数据状态管理</h4><p>数据状态管理是近年随着在 React/Vue 等现代化的前端框架流行起来的，主要应用在单页应用 SPA<code>(Single Page Application)</code>中。在以前前端“刀耕火种”的年代还没有这种概念的。</p><p>前端技术在如火如荼地发展，前端工作也越来越复杂，现阶段的前端不在只是传统意义上的“切图仔”，更多地负责页面数据逻辑处理，原有的很多技术体系、解决方案已经不能很好的支撑这些越来越复杂的需求。而且，现在 Vue/React 等前端框架都是使用 MVVM 的设计模式，都是依靠数据驱动视图的更新。</p><p>比如 Vue 使用了 Virtual DOM 的 思想。将 DOM 放到内存中，当 data 发生变化的时候，生成新的 Virtual DOM，再将它和之前的 Virtual DOM 通过一个 diff 算法进行对比，将被改变的内容在浏览器中渲染，大大减少了对 DOM 的操作，提升了前端性能。</p><p>其次数据管理逻辑和页面渲染逻辑分离，使得代码更容易维护。操作数据的地方不会关心页面如何展示，展示页面的地方不会关心数据从哪里来的。</p><h4 id="数据状态管理的方法"><a href="#数据状态管理的方法" class="headerlink" title="数据状态管理的方法"></a>数据状态管理的方法</h4><ul><li>localStorage 和 sessionStorage : 适合小量简单数据的存储</li><li>prop 和 $emit: 适合父子组件传值</li><li>provide 和 inject: 允许一个祖先组件向其所有子孙后代注入一个依赖</li><li>vuex: 全局数据状态管理，适合数据复杂的大型应用</li></ul><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><h4 id="Vuex-解决了什么问题"><a href="#Vuex-解决了什么问题" class="headerlink" title="Vuex 解决了什么问题"></a>Vuex 解决了什么问题</h4><ul><li>多个组件依赖于同一状态时，对于多层嵌套的组件的传参将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。</li><li>来自不同组件的行为需要变更同一状态。以往采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</li></ul><h4 id="五个核心属性"><a href="#五个核心属性" class="headerlink" title="五个核心属性"></a>五个核心属性</h4><ul><li>state：存储状态（变量）,相当于 vue 的 data</li><li>getters：对数据获取之前的再次编译，可以理解为 state 的计算属性。我们在组件中使用 <code>$sotre.getters.fun()</code></li><li>mutations：修改状态，并且是同步的。在组件中使用<code>$store.commit('',params)</code>。相当于 vue 的 methods。</li><li>actions：异步操作。在组件中使用是<code>$store.dispath('')</code></li><li>modules：store 的子模块，为了开发大型项目，方便状态管理而使用的。</li></ul><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>state 是存储状态，它是一个对象。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">  state: {</span><br><span class="line">    count: <span class="number">10</span>,</span><br><span class="line">    price: <span class="number">10</span>,</span><br><span class="line">  },</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> { mapState } <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  computed: mapState({</span><br><span class="line">    count: <span class="function">(<span class="params">state</span>) =&gt;</span> state.count,</span><br><span class="line">    price: <span class="function">(<span class="params">state</span>) =&gt;</span> state.price,</span><br><span class="line">  }),</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。</span></span><br><span class="line">computed: mapState([<span class="string">'count'</span>, <span class="string">'price'</span>])</span><br></pre></td></tr></tbody></table></figure><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><p>有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数，这时候我们就用到 getter 属性。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">  state: {</span><br><span class="line">    list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">  },</span><br><span class="line">  getters: { <span class="comment">//  这个主要是对状态的处理，相当于把状态处理的方法抽成公共部分来管理了</span></span><br><span class="line">    <span class="function"><span class="title">filterArr</span>(<span class="params">state</span>)</span> { <span class="comment">// 一般化getter</span></span><br><span class="line">      <span class="keyword">return</span> state.list.filter(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> {</span><br><span class="line">        <span class="keyword">return</span> item % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">      })</span><br><span class="line">    },</span><br><span class="line">    <span class="function"><span class="title">getLength</span>(<span class="params">state, getter</span>)</span> { <span class="comment">// 方法里面传getter，调用modifyArr来计算长度</span></span><br><span class="line">      <span class="keyword">return</span> getter.filterArr.length;</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>然后在组件中可以用计算属性 computed 来访问这些派生转态。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: {</span><br><span class="line">  <span class="function"><span class="title">list</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$store.getters.filterArr</span><br><span class="line">  },</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性，当我们想在组件里面引入多个 getter 时，可以使用 mapGetters：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { mapGetters } <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  computed: {</span><br><span class="line">    ...mapGetters([<span class="string">'filterArr'</span>, <span class="string">'getLength'</span>]),</span><br><span class="line">  },</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h4><p><strong>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。</strong> Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的事件类型 (type) 和 一个 回调函数 (handler)。<br>它会接受 state 作为第一个参数，提交载荷（Payload）作为第二个参数。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">  state: {</span><br><span class="line">    count: <span class="number">1</span>,</span><br><span class="line">  },</span><br><span class="line">  mutations: {</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state, n</span>)</span> {</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count += n</span><br><span class="line">    },</span><br><span class="line">  },</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</span><br></pre></td></tr></tbody></table></figure><p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mutations: {</span><br><span class="line">  increment (state, payload) {</span><br><span class="line">    state.count += payload.count</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">store.commit(<span class="string">'increment'</span>, {</span><br><span class="line">  count: <span class="number">10</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>提交 mutation 的另一种方式是直接使用包含 type 属性的对象：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.commit({</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  count: <span class="number">10</span>,</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><strong>在组件中提交 Mutation</strong><br>你可以在组件中使用 <code>this.$store.commit('xxx')</code> 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用（需要在根节点注入 store）。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { mapMutations } <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: {</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span></span><br><span class="line">    ]),</span><br><span class="line">  },</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>Action 类似于 mutation，不同在于：</p><ul><li>action 提交的是 mutation，而不是直接变更状态。mutation 可以直接变更状态。</li><li>action 可以包含任意异步操作。mutation 只能是同步操作。</li><li>提交方式不同，action 是用<code>this.$store.dispatch('ACTION_NAME',data)</code>来提交。mutation 是用<code>this.$store.commit('SET_NUMBER',10)</code>来提交。</li><li>接收参数不同，mutation 第一个参数是 state，而 action 第一个参数是 context。</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">  state: {</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  },</span><br><span class="line">  mutations: {</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> {</span><br><span class="line">      state.count++</span><br><span class="line">    },</span><br><span class="line">  },</span><br><span class="line">  actions: {</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">context</span>)</span> {</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    },</span><br><span class="line">  },</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><strong>注意：vuex 的 mutation 中不能做异步操作</strong></p><p>vuex 中所有的状态更新的唯一方式都是提交 mutation，异步操作需要通过 action 来提交 mutation（dispatch）。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地使用 vuex</p><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = {</span><br><span class="line">  state: { ... },</span><br><span class="line">  getters: { ... },</span><br><span class="line">  mutations: { ... },</span><br><span class="line">  actions: { ... },</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = {</span><br><span class="line">  state: { ... },</span><br><span class="line">  getters: { ... },</span><br><span class="line">  mutations: { ... },</span><br><span class="line">  actions: { ... }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">  modules: {</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></tbody></table></figure><h3 id="实现一个简易版的-vuex"><a href="#实现一个简易版的-vuex" class="headerlink" title="实现一个简易版的 vuex"></a>实现一个简易版的 vuex</h3><p>我们先来看一下 vuex 的使用方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">  state: {},</span><br><span class="line">  mutations: {},</span><br><span class="line">  actions: {},</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>通过上面可以看到，<code>vuex</code> 是通过 <code>Vue.use()</code> 注入到 <code>Vue</code> 的。使用<code>Vue.use()</code> 的插件，如果插件是一个对象，必须提供 <code>install</code> 方法。如果插件是一个函数，它会被作为 <code>install</code> 方法。<code>install</code> 方法调用时，会将 Vue 作为参数传入。</p><h4 id="实现-Store-类"><a href="#实现-Store-类" class="headerlink" title="实现 Store 类"></a>实现 Store 类</h4><p>首先来实现一个 Store 类，代码如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="keyword">new</span> Vue({</span><br><span class="line">      data: options.state,</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.mutations = options.mutations</span><br><span class="line">    <span class="built_in">this</span>.actions = options.actions</span><br><span class="line"></span><br><span class="line">    options.getters &amp;&amp; <span class="built_in">this</span>.handleGetters(options.getters)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  commit = <span class="function">(<span class="params">type, arg</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">this</span>.mutations[type](<span class="built_in">this</span>.state, arg)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">dispatch</span>(<span class="params">type, arg</span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.actions[type](</span><br><span class="line">      {</span><br><span class="line">        commit: <span class="built_in">this</span>.commit,</span><br><span class="line">        state: <span class="built_in">this</span>.state,</span><br><span class="line">      },</span><br><span class="line">      arg</span><br><span class="line">    )</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// getters为参数 而this.getters是实例化的</span></span><br><span class="line">  <span class="function"><span class="title">handleGetters</span>(<span class="params">getters</span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.getters = {}</span><br><span class="line">    <span class="built_in">Object</span>.keys(getters).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> {</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>.getters, key, {</span><br><span class="line">        get: <span class="function">() =&gt;</span> {</span><br><span class="line">          <span class="keyword">return</span> getters[key](<span class="built_in">this</span>.state)</span><br><span class="line">        },</span><br><span class="line">      })</span><br><span class="line">    })</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="实现-install-方法"><a href="#实现-install-方法" class="headerlink" title="实现 install 方法"></a>实现 install 方法</h4><p>使用<code>Vue.use()</code> 的插件，必须提供 <code>install</code> 方法。并将 Vue 作为参数传入。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">_Vue</span>) </span>{</span><br><span class="line">  Vue = _Vue</span><br><span class="line"></span><br><span class="line">  Vue.mixin({</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> {</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.$options.store) {</span><br><span class="line">        Vue.prototype.$store = <span class="built_in">this</span>.$options.store</span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>vuex 最终 export 了一个对象这个对象包括了一个 install 方法和一个类 Store, 注意对应我们的使用方法。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> { Store, install }</span><br></pre></td></tr></tbody></table></figure><h4 id="使用简易版-vuex"><a href="#使用简易版-vuex" class="headerlink" title="使用简易版 vuex"></a>使用简易版 vuex</h4><p>1、新建 store.js</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = {</span><br><span class="line">  count: <span class="number">0</span>,</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> getters = {</span><br><span class="line">  <span class="function"><span class="title">getCount</span>(<span class="params">state</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> state.count</span><br><span class="line">  },</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> mutations = {</span><br><span class="line">  <span class="function"><span class="title">addCount</span>(<span class="params">state, payload</span>)</span> {</span><br><span class="line">    state.count += payload</span><br><span class="line">  },</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> actions = {</span><br><span class="line">  <span class="function"><span class="title">asyncAdd</span>(<span class="params">context, payload</span>)</span> {</span><br><span class="line">    context.commit(<span class="string">'addCount'</span>, payload)</span><br><span class="line">  },</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store({</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  getters,</span><br><span class="line">  actions,</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></tbody></table></figure><p>2、main.js 引入</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/index'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue({</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">}).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></tbody></table></figure><p>3、页面使用数据状态管理</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>当前数量是{{count}} <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"asyncAdd"</span>&gt;</span>异步操作+10<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line">    computed: {</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">count</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.$store.getters.getCount</span></span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">    methods: {</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$store.commit(<span class="string">'add'</span>, <span class="number">1</span>)</span></span><br><span class="line">      },</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">asyncAdd</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$store.dispatch(<span class="string">'asyncAdd'</span>, <span class="number">10</span>)</span></span><br><span class="line">        }, 1000)</span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这样就能完成一个简易版的 vuex 了。  </p><p>详细代码可见 <a href="https://github.com/Michael-lzg/vuex-demo">https://github.com/Michael-lzg/vuex-demo</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E6%80%BB%E7%BB%93vue%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%B9%8B%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E7%AF%87/"/>
      <url>2020/12/29/%E6%80%BB%E7%BB%93vue%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%B9%8B%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue-use"><a href="#Vue-use" class="headerlink" title="Vue.use"></a>Vue.use</h3><p>我们使用的第三方 Vue.js 插件。如果插件是一个对象，必须提供<code>install</code>方法。如果插件是一个函数，它会被作为<code>install</code>方法。<code>install</code>方法调用时，会将<code>Vue</code>作为参数传入。该方法需要在调用<code>new Vue()</code>之前被调用。</p><p>我们在使用插件或者第三方组件库的时候用到<code>Vue.use</code>这个方法，比如</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> iView <span class="keyword">from</span> <span class="string">'iview'</span></span><br><span class="line">Vue.use(iView)</span><br></pre></td></tr></tbody></table></figure><p>那么<code>Vue.use</code>到底做了些什么事情呢？我们先来看一下源码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { toArray } <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span>(<span class="params">Vue: GlobalAPI</span>) </span>{</span><br><span class="line">  Vue.use = <span class="function"><span class="keyword">function</span>(<span class="params">plugin: <span class="built_in">Function</span> | <span class="built_in">Object</span></span>) </span>{</span><br><span class="line">    <span class="keyword">const</span> installedPlugins = <span class="built_in">this</span>._installedPlugins || (<span class="built_in">this</span>._installedPlugins = [])</span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.indexOf(plugin) &gt; -<span class="number">1</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// additional parameters</span></span><br><span class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    args.unshift(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">'function'</span>) {</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">'function'</span>) {</span><br><span class="line">      plugin.apply(<span class="literal">null</span>, args)</span><br><span class="line">    }</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们由以上可以看出，<code>plugin</code>参数为函数或者对象类型，首先<code>Vue</code>会去寻找这个插件在已安装的插件列表里有没有，如果没有，则进行安装插件，如果有则跳出函数，这保证插件只被安装一次。</p><p>接着通过<code>toArray</code>方法将参数变成数组，再判断<code>plugin</code>的<code>install</code>属性是否为函数，或者<code>plugin</code>本身就是函数，最后执行<code>plugin.install</code>或者<code>plugin</code>的方法。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>下面我们来举个实际例子<br>1、编写两个插件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Plugin1 = {</span><br><span class="line">  <span class="function"><span class="title">install</span>(<span class="params">a</span>)</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin2</span>(<span class="params">b</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> { Plugin1, Plugin2 }</span><br></pre></td></tr></tbody></table></figure><p>2、引入并 use 这两个插件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> { Plugin1, Plugin2 } <span class="keyword">from</span> <span class="string">'./plugins'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Plugin1, <span class="string">'参数1'</span>)</span><br><span class="line">Vue.use(Plugin2, <span class="string">'参数2'</span>)</span><br></pre></td></tr></tbody></table></figure><p>此时我们运行项目代码就可以用到上面两个插件了。</p><h3 id="Vue-mixin"><a href="#Vue-mixin" class="headerlink" title="Vue.mixin"></a>Vue.mixin</h3><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p><p>1、定义一个 mixin.js</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> mixin {</span><br><span class="line"> <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">   name: <span class="string">'mixin'</span></span><br><span class="line">  }</span><br><span class="line"> },</span><br><span class="line"> <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'mixin...'</span>, <span class="built_in">this</span>.name);</span><br><span class="line"> },</span><br><span class="line"> <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> {},</span><br><span class="line"> methods: {  <span class="comment">//日期转换</span></span><br><span class="line">   formatDate (dateTime, fmt = <span class="string">'YYYY年MM月DD日 HH:mm:ss'</span>) {</span><br><span class="line">     <span class="keyword">if</span> (!dateTime) {</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">     }</span><br><span class="line">     moment.locale(<span class="string">'zh-CN'</span>)</span><br><span class="line">     dateTime = moment(dateTime).format(fmt)</span><br><span class="line">     <span class="keyword">return</span> dateTime</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、在vue文件中使用mixin</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'@/mixin'</span>; <span class="comment">// 引入mixin文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line"> mixins: [mixin],  <span class="comment">//用法</span></span><br><span class="line"> <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">   userName: <span class="string">"adimin"</span>,</span><br><span class="line">   time: <span class="built_in">this</span>.formatDate(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">//这个vue文件的数据源data里面的time就是引用混入进来的方法</span></span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>或者在全局中使用在main.js中，所有页面都能使用了</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mixin <span class="keyword">from</span> <span class="string">'./mixin'</span></span><br><span class="line">Vue.mixin(mixin)  </span><br></pre></td></tr></tbody></table></figure><h4 id="合并选项"><a href="#合并选项" class="headerlink" title="合并选项"></a>合并选项</h4><p>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。</p><ul><li><code>data</code>对象在内部会进行递归合并，并在发生冲突时以组件数据优先。</li><li>同名钩子函数将合并为一个数组，因此都将被调用。混入对象的钩子将在组件自身钩子之前调用。</li><li>值为对象的选项，例如 <code>methods</code>、<code>components</code> 和 <code>directives</code>，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</li></ul><h3 id="Vue-extend"><a href="#Vue-extend" class="headerlink" title="Vue.extend"></a>Vue.extend</h3><p><code>Vue.extend</code> 属于 Vue 的全局 API。它使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Profile = Vue.extend({</span><br><span class="line">  template: <span class="string">'&lt;p&gt;{{firstName}} {{lastName}}&lt;/p&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      firstName: <span class="string">'Walter'</span>,</span><br><span class="line">      lastName: <span class="string">'White'</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"><span class="comment">// 创建 Profile 实例，并挂载到一个元素上。</span></span><br><span class="line"><span class="keyword">new</span> Profile().$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>我们常用 <code>Vue.extend</code> 封装一些全局插件，比如 <code>toast</code>， <code>diolog</code> 等。   </p><p>下面以封装一个 <code>toast</code> 组件为例。  </p><p>1、编写组件</p><ul><li>根据传入的 type 确定弹窗的类型（成功提示，失败提示，警告，加载，纯文字）</li><li>设置弹窗消失的时间<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"little-tip"</span> <span class="attr">v-show</span>=<span class="string">"showTip"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/success.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"36"</span> <span class="attr">v-if</span>=<span class="string">"type=='success'"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/fail.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"36"</span> <span class="attr">v-if</span>=<span class="string">"type=='fail'"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/warning.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"36"</span> <span class="attr">v-if</span>=<span class="string">"type=='warning'"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/loading.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"36"</span> <span class="attr">v-if</span>=<span class="string">"type=='loading'"</span> <span class="attr">class</span>=<span class="string">"loading"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>{{msg}}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">        showTip: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        msg: <span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">        type: <span class="string">''</span></span></span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.showTip = <span class="literal">false</span></span></span><br><span class="line">      }, 1500)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 样式略 */</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>2、利用 <code>Vue.extend</code> 构造器把 <code>toast</code> 组件挂载到 <code>vue</code> 实例下<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Main <span class="keyword">from</span> <span class="string">'./toast.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Toast = Vue.extend(Main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance</span><br><span class="line"><span class="keyword">const</span> toast = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>{</span><br><span class="line">  options = options || {}</span><br><span class="line">  instance = <span class="keyword">new</span> Toast({</span><br><span class="line">    data: options</span><br><span class="line">  })</span><br><span class="line">  instance.vm = instance.$mount()</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(instance.vm.$el)</span><br><span class="line">  <span class="keyword">return</span> instance.vm</span><br><span class="line">}</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> toast</span><br></pre></td></tr></tbody></table></figure>3、在 <code>main.js</code> 引入 <code>toast</code> 组价并挂载在 <code>vue</code> 原型上<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> toast <span class="keyword">from</span> <span class="string">'./components/toast'</span></span><br><span class="line">Vue.prototype.$toast = toast</span><br></pre></td></tr></tbody></table></figure>4、在项目中调用<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$toast({ <span class="attr">msg</span>: <span class="string">'手机号码不能为空'</span> })</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$toast({</span><br><span class="line">  msg: <span class="string">'成功提示'</span>,</span><br><span class="line">  type: <span class="string">'success'</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="Vue-extend-和-Vue-component-的区别"><a href="#Vue-extend-和-Vue-component-的区别" class="headerlink" title="Vue.extend 和 Vue.component 的区别"></a>Vue.extend 和 Vue.component 的区别</h4></li><li><code>component</code>是需要先进行组件注册后，然后在 <code>template</code> 中使用注册的标签名来实现组件的使用。<code>Vue.extend</code> 则是编程式的写法。</li><li>控制<code>component</code>的显示与否，需要在父组件中传入一个状态来控制或者在组件外部用 <code>v-if/v-show</code> 来实现控制，而 <code>Vue.extend</code> 的显示与否是手动的去做组件的挂载和销毁。</li></ul><h3 id="Vue-directive"><a href="#Vue-directive" class="headerlink" title="Vue.directive"></a>Vue.directive</h3><p>注册或获取全局指令。指令定义函数提供了几个钩子函数（可选）：</p><ul><li>bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作。</li><li>inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li><li>update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值。</li><li>componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。</li><li>unbind: 只调用一次， 指令与元素解绑时调用。</li></ul><h4 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h4><p>下面封装一个复制粘贴文本的例子。  </p><p>1、编写指令 <code>copy.js</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vCopy = { </span><br><span class="line">  bind (el, { value }) {</span><br><span class="line">    el.$value = value <span class="comment">// 用一个全局属性来存传进来的值</span></span><br><span class="line">    el.handler = <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="keyword">if</span> (!el.$value) {</span><br><span class="line">        alert(<span class="string">'无复制内容'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 动态创建 textarea 标签</span></span><br><span class="line">      <span class="keyword">const</span> textarea = <span class="built_in">document</span>.createElement(<span class="string">'textarea'</span>)</span><br><span class="line">      <span class="comment">// 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域</span></span><br><span class="line">      textarea.readOnly = <span class="string">'readonly'</span></span><br><span class="line">      textarea.style.position = <span class="string">'absolute'</span></span><br><span class="line">      textarea.style.left = <span class="string">'-9999px'</span></span><br><span class="line">      <span class="comment">// 将要 copy 的值赋给 textarea 标签的 value 属性</span></span><br><span class="line">      textarea.value = el.$value</span><br><span class="line">      <span class="comment">// 将 textarea 插入到 body 中</span></span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(textarea)</span><br><span class="line">      <span class="comment">// 选中值并复制</span></span><br><span class="line">      textarea.select()</span><br><span class="line">      <span class="comment">// textarea.setSelectionRange(0, textarea.value.length);</span></span><br><span class="line">      <span class="keyword">const</span> result = <span class="built_in">document</span>.execCommand(<span class="string">'Copy'</span>)</span><br><span class="line">      <span class="keyword">if</span> (result) {</span><br><span class="line">        alert(<span class="string">'复制成功'</span>)</span><br><span class="line">      }</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(textarea)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 绑定点击事件，就是所谓的一键 copy 啦</span></span><br><span class="line">    el.addEventListener(<span class="string">'click'</span>, el.handler)</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 当传进来的值更新的时候触发</span></span><br><span class="line">  componentUpdated (el, { value }) {</span><br><span class="line">    el.$value = value</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 指令与元素解绑的时候，移除事件绑定</span></span><br><span class="line">  unbind (el) {</span><br><span class="line">    el.removeEventListener(<span class="string">'click'</span>, el.handler)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> vCopy</span><br></pre></td></tr></tbody></table></figure><p>2、注册指令</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy <span class="keyword">from</span> <span class="string">'./copy'</span></span><br><span class="line"><span class="comment">// 自定义指令</span></span><br><span class="line"><span class="keyword">const</span> directives = {</span><br><span class="line">  copy</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 这种写法可以批量注册指令</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  install (Vue) {</span><br><span class="line">    <span class="built_in">Object</span>.keys(directives).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> {</span><br><span class="line">      Vue.directive(key, directives[key])</span><br><span class="line">    })</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3、在 <code>main.js</code> 引入并 <code>use</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Directives <span class="keyword">from</span> <span class="string">'./JS/directives'</span></span><br><span class="line">Vue.use(Directives)</span><br></pre></td></tr></tbody></table></figure><p>这样就可以在项目直接用 <code>vCopy</code> 指令了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E6%80%BB%E7%BB%93vue%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%B9%8B%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>2020/12/29/%E6%80%BB%E7%BB%93vue%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%B9%8B%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="监听组件的生命周期"><a href="#监听组件的生命周期" class="headerlink" title="监听组件的生命周期"></a>监听组件的生命周期</h3><p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，常规的写法可能如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Parent.vue</span></span><br><span class="line">&lt;Child @mounted=<span class="string">"doSomething"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.vue</span></span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">this</span>.$emit(<span class="string">"mounted"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此外，还有一种特别简单的方式，子组件不需要任何处理，只需要在父组件引用的时候通过@hook 来监听即可，代码如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span> @<span class="attr">hook:mounted</span>=<span class="string">"doSomething"</span> /&gt;</span> <span class="tag">&lt;<span class="name">Child</span> @<span class="attr">hook:updated</span>=<span class="string">"doSomething"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>当然这里不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以。</p><h3 id="watch-的初始立即执行"><a href="#watch-的初始立即执行" class="headerlink" title="watch 的初始立即执行"></a>watch 的初始立即执行</h3><p>观察和响应 Vue 实例上的数据变动。类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作。</p><p>但是当 watch 一个变量的时候，初始化时并不会执行，如下面的例子，你需要在 created 的时候手动调用一次。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">this</span>.getList();</span><br><span class="line">},</span><br><span class="line">watch: {</span><br><span class="line">  keyWord: <span class="string">'getList'</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面这样的做法可以使用，但很麻烦，我们可以添加 immediate 属性，这样初始化的时候就会自动触发(不用再写 created 去调用了)，然后上面的代码就能简化为：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch: {</span><br><span class="line">  keyWord: {</span><br><span class="line">    handler: <span class="string">'getList'</span>,</span><br><span class="line">    immediate: <span class="literal">true</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>watch 有三个参数</p><ul><li><code>handler</code>：其值是一个回调函数。即监听到变化时应该执行的函数</li><li><code>deep</code>：其值是 true 或 false；确认是否深入监听。</li><li><code>immediate</code>：其值是 true 或 false，确认是否以当前的初始值执行 handler 的函数</li></ul><h3 id="路由参数变化组件不更新"><a href="#路由参数变化组件不更新" class="headerlink" title="路由参数变化组件不更新"></a>路由参数变化组件不更新</h3><p>同一<code>path</code>的页面跳转时路由参数变化，但是组件没有对应的更新。</p><p>原因：主要是因为获取参数写在了<code>created</code>或者<code>mounted</code>路由钩子函数中，路由参数变化的时候，这个生命周期不会重新执行。</p><p>解决方案 1：<code>watch</code>监听路由</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">watch: {</span><br><span class="line"> <span class="comment">// 方法1 //监听路由是否变化</span></span><br><span class="line">  <span class="string">'$route'</span> (to, <span class="keyword">from</span>) {</span><br><span class="line">   <span class="keyword">if</span>(to.query.id !== <span class="keyword">from</span>.query.id){</span><br><span class="line"><span class="built_in">this</span>.id = to.query.id;</span><br><span class="line"><span class="built_in">this</span>.init();<span class="comment">//重新加载数据</span></span><br><span class="line">}</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//方法 2  设置路径变化时的处理函数</span></span><br><span class="line">watch: {</span><br><span class="line"><span class="string">'$route'</span>: {</span><br><span class="line">    handler: <span class="string">'init'</span>,</span><br><span class="line">    immediate: <span class="literal">true</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解决方案 2 ：为了实现这样的效果可以给<code>router-view</code>添加一个不同的<code>key</code>，这样即使是公用组件，只要 url 变化了，就一定会重新创建这个组件。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">:key</span>=<span class="string">"$route.fullpath"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>Vue 项目中实现路由按需加载（路由懒加载）的 3 中方式：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、Vue异步组件技术：</span></span><br><span class="line">{</span><br><span class="line">path: <span class="string">'/home'</span>,</span><br><span class="line">name: <span class="string">'Home'</span>,</span><br><span class="line">component: <span class="function"><span class="params">resolve</span> =&gt;</span> reqire([<span class="string">'path路径'</span>], resolve)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、es6提案的import()</span></span><br><span class="line">  <span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'path路径'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、webpack提供的require.ensure()</span></span><br><span class="line">{</span><br><span class="line">path: <span class="string">'/home'</span>,</span><br><span class="line">name: <span class="string">'Home'</span>,</span><br><span class="line">component: <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([],<span class="function">() =&gt;</span>  r(<span class="built_in">require</span>(<span class="string">'path路径'</span>)), <span class="string">'demo'</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="require-context"><a href="#require-context" class="headerlink" title="require.context()"></a>require.context()</h3><p>require.context(directory,useSubdirectories,regExp)</p><ul><li>directory：说明需要检索的目录</li><li>useSubdirectories：是否检索子目录</li><li>regExp: 匹配文件的正则表达式,一般是文件名</li></ul><p>场景:如页面需要导入多个组件,原始写法:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> titleCom <span class="keyword">from</span> <span class="string">'@/components/home/titleCom'</span></span><br><span class="line"><span class="keyword">import</span> bannerCom <span class="keyword">from</span> <span class="string">'@/components/home/bannerCom'</span></span><br><span class="line"><span class="keyword">import</span> cellCom <span class="keyword">from</span> <span class="string">'@/components/home/cellCom'</span></span><br><span class="line">components: {</span><br><span class="line">  titleCom, bannerCom, cellCom</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样就写了大量重复的代码,利用 require.context 可以写成</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> files = <span class="built_in">require</span>.context(<span class="string">'@/components/home'</span>, <span class="literal">false</span>, <span class="regexp">/\.vue$/</span>)</span><br><span class="line"><span class="keyword">const</span> modules = {}</span><br><span class="line">files.keys().forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> name = path.basename(key, <span class="string">'.vue'</span>)</span><br><span class="line">  modules[name] = files(key).default || files(key)</span><br><span class="line">})</span><br><span class="line">components: modules</span><br></pre></td></tr></tbody></table></figure><h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><ul><li>递归组件: 组件在它的模板内可以递归的调用自己，只要给组件设置 name 组件就可以了。</li><li>不过需要注意的是，必须给一个条件来限制数量，否则会抛出错误: max stack size exceeded</li><li>组件递归用来开发一些具体有未知层级关系的独立组件。比如：联级选择器和树形控件</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-<span class="keyword">for</span>=<span class="string">"(item,index) in treeArr"</span>&gt; {{index}} &lt;br/&gt;</span><br><span class="line">      &lt;tree :item=<span class="string">"item.arr"</span> v-<span class="keyword">if</span>=<span class="string">"item.flag"</span>&gt;&lt;/tree&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="comment">// 必须定义name，组件内部才能递归调用</span></span><br><span class="line">  name: <span class="string">'tree'</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="keyword">return</span> {}</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 接收外部传入的值</span></span><br><span class="line">  props: {</span><br><span class="line">     item: {</span><br><span class="line">      type:<span class="built_in">Array</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function">()=&gt;</span>[]</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="清除定时器或者事件监听"><a href="#清除定时器或者事件监听" class="headerlink" title="清除定时器或者事件监听"></a>清除定时器或者事件监听</h3><p>由于项目中有些页面难免会碰到需要定时器或者事件监听。但是在离开当前页面的时候，定时器如果不及时合理地清除，会造成业务逻辑混乱甚至应用卡死的情况，这个时就需要清除定时器事件监听，即在页面卸载（关闭）的生命周期函数里，清除定时器。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">methods:{</span><br><span class="line">  resizeFun () {</span><br><span class="line">    <span class="built_in">this</span>.tableHeight = <span class="built_in">window</span>.innerHeight - <span class="built_in">document</span>.getElementById(<span class="string">'table'</span>).offsetTop - <span class="number">128</span></span><br><span class="line">  },</span><br><span class="line">  <span class="function"><span class="title">setTimer</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> { })</span><br><span class="line">  },</span><br><span class="line">  <span class="function"><span class="title">clearTimer</span>(<span class="params"></span>)</span> {<span class="comment">//清除定时器</span></span><br><span class="line"><span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer)</span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="literal">null</span></span><br><span class="line">}</span><br><span class="line">},</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">this</span>.setTimer()</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="built_in">this</span>.resizeFun)</span><br><span class="line">},</span><br><span class="line"><span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, <span class="built_in">this</span>.resizeFun)</span><br><span class="line">  <span class="built_in">this</span>.clearTimer()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="自定义路径别名"><a href="#自定义路径别名" class="headerlink" title="自定义路径别名"></a>自定义路径别名</h3><p>我们也可以在基础配置文件中添加自己的路径别名</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resolve: {</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    alias: {</span><br><span class="line">      <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span>,</span><br><span class="line">      <span class="string">'@'</span>: resolve(<span class="string">'src'</span>),</span><br><span class="line">      <span class="string">'assets'</span>: resolve(<span class="string">'src/assets'</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>然后我们导入组件的时候就可以这样写：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import YourComponent from '/src/assets/YourComponent'</span></span><br><span class="line"><span class="keyword">import</span> YourComponent <span class="keyword">from</span> <span class="string">'assets/YourComponent'</span></span><br></pre></td></tr></tbody></table></figure><p>这样既解决了路径过长的麻烦，又解决了相对路径的烦恼。</p><h3 id="动态给修改-dom-的样式"><a href="#动态给修改-dom-的样式" class="headerlink" title="动态给修改 dom 的样式"></a>动态给修改 dom 的样式</h3><p>原因：因为我们在写.vue 文件中的样式都会追加 scoped。这样针对模板 dom 中的样式就可以生效，但其生效后的最终样式并不是我们写的样式名，而是编码后的。比如：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>dom<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> {</span></span><br><span class="line">    background: red;</span><br><span class="line">  }</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>vue 将代码转译成如下，所以我们在 js 中拼接上的 dom 结构样式并不会生效。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box[data-v-11c6864c]{ background:red; }</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">data-v-11c6864c</span>&gt;</span>dom<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>解决方法：将要改变的样式写在非 scoped 样式标签中。</p><h3 id="长列表性能优化"><a href="#长列表性能优化" class="headerlink" title="长列表性能优化"></a>长列表性能优化</h3><p>我们应该都知道 vue 会通过 object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间。</p><p>所以，我们可以通过 object.freeze 方法来冻结一个对象，这个对象一旦被冻结，vue 就不会对数据进行劫持了。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  data: <span class="function">() =&gt;</span> ({</span><br><span class="line">    list: [],</span><br><span class="line">  }),</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="keyword">const</span> list = <span class="keyword">await</span> axios.get(<span class="string">'xxxx'</span>)</span><br><span class="line">    <span class="built_in">this</span>.list = <span class="built_in">Object</span>.freeze(list)</span><br><span class="line">  },</span><br><span class="line">  methods: {</span><br><span class="line">    <span class="comment">// 此处做的操作都不能改变list的值</span></span><br><span class="line">  },</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另外需要说明的是，这里只是冻结了 list 的值，引用不会被冻结，当我们需要 reactive 数据的时候，我们可以重新给 list 赋值。</p><h3 id="内容分发-slot"><a href="#内容分发-slot" class="headerlink" title="内容分发(slot)"></a>内容分发(slot)</h3><p>插槽 slot，也是组件的一块 HTML 模板，这一块模板显示不显示、以及怎样显示由父组件来决定。实际上，一个 slot 最核心的两个问题在这里就点出来了，是显示不显示和怎样显示。</p><h4 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h4><p>又名单个插槽、匿名插槽，这类插槽没有具体名字，一个组件只能有一个该类插槽。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>父容器<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tmpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子组件 child.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>匿名插槽没有 name 属性，所以叫匿名插槽。那么，插槽加了 name 属性，就变成了具名插槽。具名插槽可以在一个组件中出现 N 次，出现在不同的位置，只需要使用不同的 name 属性区分即可。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>父容器<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tmpl"</span> <span class="attr">slot</span>=<span class="string">"up"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单up-1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tmpl"</span> <span class="attr">slot</span>=<span class="string">"down"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单down-1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tmpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>菜单-&gt;1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子组件 child.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 具名插槽 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"up"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这里是子组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 具名插槽 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"down"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 匿名插槽 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>作用域插槽可以是默认插槽，也可以是具名插槽，不一样的地方是，作用域插槽可以为 slot 标签绑定数据，让其父组件可以获取到子组件的数据。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是父组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    &lt;child</span><br><span class="line">      &gt;&gt;</span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"default"</span> <span class="attr">slot-scope</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">        {{ slotProps.user.name }}</span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span> &lt;/child</span><br><span class="line">    &gt;&gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子组件 child.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是子组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:user</span>=<span class="string">"user"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> {</span></span><br><span class="line">        user: {</span><br><span class="line"><span class="javascript">          name: <span class="string">'小赵'</span>,</span></span><br><span class="line">        },</span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E6%80%BB%E7%BB%93vue%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/"/>
      <url>2020/12/29/%E6%80%BB%E7%BB%93vue%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue-的优缺点是什么"><a href="#Vue-的优缺点是什么" class="headerlink" title="Vue 的优缺点是什么"></a>Vue 的优缺点是什么</h3><p>优点：</p><ol><li>低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li><li>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。</li><li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码。</li><li>可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li><li>vue 是单页面应用，使页面局部刷新，不用每次跳转页面都要请求所有数据和 dom，这样大大加快了访问速度和提升用户体验。而且他的第三方 ui 库很多节省开发时间</li></ol><p>缺点：不利于 SEO，社区维护力度不强，相比还不够成熟</p><h3 id="vue-常用指令"><a href="#vue-常用指令" class="headerlink" title="vue 常用指令"></a>vue 常用指令</h3><ul><li><code>v-html / v-text</code>：把值中的标签渲染出来</li><li><code>v-model</code>： 放在表单元素上的，实现双向数据绑定</li><li><code>v-bind</code>（缩写 :）：用于绑定行内属性</li><li><code>v-if / v-show</code> 是否能显示，true 能显示，false 不能显示</li><li><code>v-cloak</code>：需要配合 css 使用：解决小胡子显示问题</li><li><code>v-once</code> 对应的标签只渲染一次</li><li><code>v-for</code> ：循环显示元素</li><li><code>v-on</code> 事件绑定</li></ul><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p><code>Vue.js</code> 为 <code>v-on</code> 提供了事件修饰符，修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>stop</code>：阻止事件继续传播</li><li><code>prevent</code>：阻止事件默认行为</li><li><code>capture</code>：添加事件监听器时使用事件捕获模式</li><li><code>self</code>：当前元素触发时才触发事件处理函数</li><li><code>once</code>：事件只触发一次</li><li><code>passive</code>：告诉浏览器你不想阻止事件的默认行为，不能和.prevent 一起使用。</li></ul><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"toDo"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"toSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"toDo"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"toDo"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"toDo"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">"toDo"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">"onScroll"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h3><ul><li>.lazy 在输入框输入完内容，光标离开时才更新视图</li><li>.trim 过滤首尾空格</li><li>.number 如果先输入数字，那它就会限制你输入的只能是数字;如果先输入字符串，那就相当于没有加.number</li></ul><h3 id="过滤器-filter"><a href="#过滤器-filter" class="headerlink" title="过滤器 filter"></a>过滤器 filter</h3><p>过滤器是对即将显示的数据做进一步的筛选处理，然后进行显示，值得注意的是过滤器并没有改变原来的数据，只是在原数据的基础上产生新的数据。</p><ol><li>定义过滤器<br>全局注册</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">'myFilter'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value1[,value2,...] </span>) </span>{</span><br><span class="line"><span class="comment">// 代码逻辑</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>局部注册</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue({</span><br><span class="line"> filters: {</span><br><span class="line">    <span class="string">'myFilter'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value1[,value2,...] </span>) </span>{</span><br><span class="line">       <span class="comment">// 代码逻辑</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">　})</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>使用过滤器</li></ol><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>{{ message | myFilter }}<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在 `v-bind` 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"message | myFilter"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h3><p>依赖其它属性值，并且 <code>computed</code> 的值有缓存，只有它依赖的属性值发生改变，下一次获取 <code>computed</code> 的值时才会重新计算 <code>computed</code> 的值；</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "{{ message }}"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "{{ reversedMessage }}"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue({</span></span><br><span class="line"><span class="javascript">    el: <span class="string">'#example'</span>,</span></span><br><span class="line">    data: {</span><br><span class="line"><span class="javascript">      message: <span class="string">'Hello'</span></span></span><br><span class="line">    },</span><br><span class="line">    computed: {</span><br><span class="line"><span class="javascript">      <span class="comment">// 计算属性的 getter</span></span></span><br><span class="line"><span class="javascript">      reversedMessage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="comment">// `this` 指向 vm 实例</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="监听属性-watch"><a href="#监听属性-watch" class="headerlink" title="监听属性 watch"></a>监听属性 watch</h3><p>观察和响应 Vue 实例上的数据变动。类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作。它可以有三个参数</p><ul><li><code>handler</code>：其值是一个回调函数。即监听到变化时应该执行的函数</li><li><code>deep</code>：其值是 true 或 false；确认是否深入监听。</li><li><code>immediate</code>：其值是 true 或 false，确认是否以当前的初始值执行 handler 的函数</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch:{</span><br><span class="line">  message:{</span><br><span class="line">    handler:<span class="function"><span class="keyword">function</span>(<span class="params">val, oldVal</span>)</span>{</span><br><span class="line">      <span class="built_in">console</span>.log(val, oldVal)</span><br><span class="line">    },</span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line">    immediate: <span class="literal">true</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a>computed 和 watch 的区别</h3><ul><li><code>computed</code>： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</li><li><code>watch</code>： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作。</li></ul><p><strong>运用场景</strong></p><ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li><li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 &nbsp;watch&nbsp; 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul><h3 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h3><ul><li><code>beforeCreate</code>(创建前) vue 实例的挂载元素$el 和数据对象 data 都是 undefined, 还未初始化</li><li><code>created</code>(创建后) 完成了 data 数据初始化, el 还未初始化</li><li><code>beforeMount</code>(载入前) vue 实例的$el 和 data 都初始化了, 相关的 render 函数首次被调用</li><li><code>mounted</code>(载入后) 此过程中进行 ajax 交互</li><li><code>beforeUpdate</code>(更新前)</li><li><code>updated</code>(更新后)</li><li><code>beforeDestroy</code>(销毁前)</li><li><code>destroyed</code>(销毁后)</li></ul><p><strong>Vue 的父组件和子组件生命周期钩子执行顺序是什么?</strong></p><ol><li>渲染过程：父组件挂载完成一定是等子组件都挂载完成后，才算是父组件挂载完，所以父组件的 mounted 在子组件 mouted 之后。</li></ol><ul><li>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li></ul><ol start="2"><li>子组件更新过程：</li></ol><ul><li>影响到父组件：父 beforeUpdate -&gt; 子 beforeUpdate-&gt;子 updated -&gt; 父 updted</li><li>不影响父组件：子 beforeUpdate -&gt; 子 updated</li></ul><ol start="3"><li>父组件更新过程：</li></ol><ul><li>影响到子组件：父 beforeUpdate -&gt; 子 beforeUpdate-&gt;子 updated -&gt; 父 updted</li><li>不影响子组件：父 beforeUpdate -&gt; 父 updated</li></ul><ol start="4"><li>销毁过程：</li></ol><ul><li>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li></ul><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><p>组件<code>（component）</code>是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。组件的使用过程包括定义和注册的过程。</p><ol><li>定义组件</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一 Vue.extend</span></span><br><span class="line"><span class="keyword">var</span> MyComponent = Vue.extend({</span><br><span class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class="line">})</span><br><span class="line"><span class="comment">// 方法二：新建一个.vue 文件</span></span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>注册组件</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局注册</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, MyComponent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部注册</span></span><br><span class="line"><span class="keyword">new</span> Vue({</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  components: {</span><br><span class="line">    <span class="string">'my-component'</span>: MyComponent</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>使用组件</li></ol><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h3><h4 id="1-props-父组件给子组件传值"><a href="#1-props-父组件给子组件传值" class="headerlink" title="1. props 父组件给子组件传值"></a>1. props 父组件给子组件传值</h4><p>props 值可以是一个数组或对象;</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组:不建议使用</span></span><br><span class="line">props:[]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">props:{</span><br><span class="line"> inpVal:{</span><br><span class="line">  type:<span class="built_in">Number</span>, <span class="comment">//传入值限定类型</span></span><br><span class="line">  <span class="comment">// type 值可为String,Number,Boolean,Array,Object,Date,Function,Symbol</span></span><br><span class="line">  <span class="comment">// type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认</span></span><br><span class="line">  required: <span class="literal">true</span>, <span class="comment">//是否必传</span></span><br><span class="line">  <span class="keyword">default</span>:<span class="number">200</span>,  <span class="comment">//默认值,对象或数组默认值必须从一个工厂函数获取如 default:()=&gt;[]</span></span><br><span class="line">  validator:(value) {</span><br><span class="line">    <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'danger'</span>].indexOf(value) !== -<span class="number">1</span></span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-emit-子组件给父组件传值"><a href="#2-emit-子组件给父组件传值" class="headerlink" title="2. $emit 子组件给父组件传值"></a>2. $emit 子组件给父组件传值</h4><p>触发子组件触发父组件给自己绑定的事件,其实就是子传父的方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;v-Header @title=<span class="string">"title"</span>&gt;</span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">'title'</span>,{<span class="attr">title</span>:<span class="string">'这是title'</span>})</span><br></pre></td></tr></tbody></table></figure><h4 id="3-vuex-数据状态管理"><a href="#3-vuex-数据状态管理" class="headerlink" title="3. vuex 数据状态管理"></a>3. vuex 数据状态管理</h4><ul><li><code>state</code>:定义存贮数据的仓库 ,可通过 this.$store.state 或 mapState 访问</li><li><code>getter</code>:获取 store 值,可认为是 store 的计算属性,可通过 this.$store.getter 或 mapGetters 访问</li><li><code>mutation</code>:同步改变 store 值,可通过 mapMutations 调用</li><li><code>action</code>:异步调用函数执行 mutation,进而改变 store 值,可通过 this.$dispatch 或 mapActions 访问</li><li><code>modules</code>:模块,如果状态过多,可以拆分成模块,最后在入口通过…解构引入</li></ul><h4 id="4-attrs-和-listeners"><a href="#4-attrs-和-listeners" class="headerlink" title="4. attrs 和 listeners"></a>4. attrs 和 listeners</h4><p><code>attrs</code> 获取子传父中未在 props 定义的值</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;home title=<span class="string">"这是标题"</span> width=<span class="string">"80"</span> height=<span class="string">"80"</span> imgUrl=<span class="string">"imgUrl"</span>/&gt;</span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.$attrs) <span class="comment">//{title: "这是标题", width: "80", height: "80", imgUrl: "imgUrl"}</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对应的如果子组件定义了 props,打印的值就是剔除定义的属性</span></span><br><span class="line">props: {</span><br><span class="line">  width: {</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">  }</span><br><span class="line">},</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.$attrs) <span class="comment">//{title: "这是标题", height: "80", imgUrl: "imgUrl"}</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>listeners</code>:场景:子组件需要调用父组件的方法。<br>解决:父组件的方法可以通过 <code>v-on="listeners"</code> 传入内部组件——在创建更高层次的组件时非常有用</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;home @change=<span class="string">"change"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.$listeners) <span class="comment">//即可拿到 change 事件</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="5-provide-和-inject"><a href="#5-provide-和-inject" class="headerlink" title="5. provide 和 inject"></a>5. provide 和 inject</h4><p><code>provide</code> 和 <code>inject</code> 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中; 并且这对选项需要一起使用; 以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件:</span></span><br><span class="line">provide: { <span class="comment">//provide 是一个对象,提供一个属性或方法</span></span><br><span class="line">  foo: <span class="string">'这是 foo'</span>,</span><br><span class="line">  fooMethod:<span class="function">()=&gt;</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父组件 fooMethod 被调用'</span>)</span><br><span class="line">  }</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子或者孙子组件</span></span><br><span class="line">inject: [<span class="string">'foo'</span>,<span class="string">'fooMethod'</span>], <span class="comment">//数组或者对象,注入到子组件</span></span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">this</span>.fooMethod()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.foo)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//在父组件下面所有的子组件都可以利用inject</span></span><br></pre></td></tr></tbody></table></figure><h4 id="6-refs"><a href="#6-refs" class="headerlink" title="6. $refs"></a>6. $refs</h4><p>通常用于父组件调用子组件的方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;home ref=<span class="string">"child"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.child) <span class="comment">//即可拿到子组件的实例,就可以直接操作 data 和 methods</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="7-EventBus"><a href="#7-EventBus" class="headerlink" title="7. EventBus"></a>7. EventBus</h4><ol><li>就是声明一个全局 Vue 实例变量 EventBus , 把所有的通信数据，事件监听都存储到这个变量上;</li><li>类似于 Vuex。但这种方式只适用于极小的项目 3.原理就是利用 emit 并实例化一个全局 vue 实现数据共享</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 main.js</span></span><br><span class="line">Vue.prototype.$eventBus = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传值组件</span></span><br><span class="line"><span class="built_in">this</span>.$eventBus.$emit(<span class="string">'eventTarget'</span>, <span class="string">'这是eventTarget传过来的值'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收组件</span></span><br><span class="line"><span class="built_in">this</span>.$eventBus.$on(<span class="string">'eventTarget'</span>, <span class="function"><span class="params">v</span> =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'eventTarget'</span>, v) <span class="comment">//这是eventTarget传过来的值</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="路由配置和使用"><a href="#路由配置和使用" class="headerlink" title="路由配置和使用"></a>路由配置和使用</h3><ol><li>配置路由信息<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> routes = [</span><br><span class="line">  {</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    component: home</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    path: <span class="string">'/list'</span>,</span><br><span class="line">    component: list</span><br><span class="line">  }</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> VueRouter({</span><br><span class="line">  routes: routes</span><br><span class="line">})</span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue({</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>在html使用<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/home'</span> <span class="attr">active-class</span>=<span class="string">'current'</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/list'</span> <span class="attr">tag</span>=<span class="string">'div'</span>&gt;</span>列表<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>此外，<code>vue-router</code>还可以通过一下方式配置动态路由</li></ol><ul><li><code>query</code>传参（问号传参）</li><li><code>params</code>传参（路径传参）</li></ul><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>Vue 项目中实现路由按需加载（路由懒加载）的 3 中方式：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、Vue异步组件技术：</span></span><br><span class="line">{</span><br><span class="line">path: <span class="string">'/home'</span>,</span><br><span class="line">name: <span class="string">'Home'</span>,</span><br><span class="line">component: <span class="function"><span class="params">resolve</span> =&gt;</span> reqire([<span class="string">'path路径'</span>], resolve)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、es6提案的import()</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'path路径'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、webpack提供的require.ensure()</span></span><br><span class="line">{</span><br><span class="line">path: <span class="string">'/home'</span>,</span><br><span class="line">name: <span class="string">'Home'</span>,</span><br><span class="line">component: <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([],<span class="function">() =&gt;</span>  r(<span class="built_in">require</span>(<span class="string">'path路径'</span>)), <span class="string">'demo'</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><p>vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。  </p><p><strong>全局前置守卫</strong><br>常用于判断登录状态和菜单权限校验</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">let</span> isLogin = sessionStorage.getItem(<span class="string">'isLogin'</span>) || <span class="string">''</span></span><br><span class="line">  <span class="keyword">if</span> (!isLogin &amp;&amp; to.meta.auth) {</span><br><span class="line">    next(<span class="string">'/login'</span>)</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    next()</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><ul><li><code>to</code>: Route: 即将要进入的目标 路由对象</li><li><code>from</code>: Route: 当前导航正要离开的路由</li><li><code>next</code>: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</li></ul><p><strong>组件内的守卫</strong></p><ul><li><code>beforeRouteEnter</code></li><li><code>beforeRouteUpdate</code> </li><li><code>beforeRouteLeave</code></li></ul><h3 id="路由缓存-keepalive"><a href="#路由缓存-keepalive" class="headerlink" title="路由缓存 keepalive"></a>路由缓存 keepalive</h3><p><code>keep-alive</code> 是 Vue 提供的一个抽象组件，用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在 v 页面渲染完毕后不会被渲染成一个 DOM 元素。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>当组件在 <code>keep-alive</code> 内被切换时组件的 <code>activated</code>、<code>deactivated</code> 这两个生命周期钩子函数会被执行</p><h4 id="1-使用参数include-exclude"><a href="#1-使用参数include-exclude" class="headerlink" title="1. 使用参数include/exclude"></a>1. 使用参数include/exclude</h4><ul><li>include: 字符串或正则表达式。只有匹配的组件会被缓存。</li><li>exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。</li></ul><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">"a,b"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">exclude</span>=<span class="string">"c"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><code>include</code> 属性表示只有 name 属性为 a，b 的组件会被缓存，（注意是组件的名字，不是路由的名字）其它组件不会被缓存。<br><code>exclude</code> 属性表示除了 name 属性为 c 的组件不会被缓存，其它组件都会被缓存。</p><h4 id="2-使用-route-meta-的-keepAlive-属性"><a href="#2-使用-route-meta-的-keepAlive-属性" class="headerlink" title="2. 使用$route.meta 的 keepAlive 属性"></a>2. 使用$route.meta 的 keepAlive 属性</h4><p>需要在 router 中设置 router 的元信息 meta</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router({</span><br><span class="line">  routes: [</span><br><span class="line">    {</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'Hello'</span>,</span><br><span class="line">      component: Hello,</span><br><span class="line">      meta: {</span><br><span class="line">        keepAlive: <span class="literal">false</span> <span class="comment">// 不需要缓存</span></span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">      path: <span class="string">'/page1'</span>,</span><br><span class="line">      name: <span class="string">'Page1'</span>,</span><br><span class="line">      component: Page1,</span><br><span class="line">      meta: {</span><br><span class="line">        keepAlive: <span class="literal">true</span> <span class="comment">// 需要被缓存</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>在 app.vue 进行区别缓存和不用缓存的页面</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">"!$route.meta.keepAlive"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">"$route.meta.keepAlive"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="hash-和-history模式"><a href="#hash-和-history模式" class="headerlink" title="hash 和 history模式"></a>hash 和 history模式</h3><ul><li><p>hash 模式：在浏览器中符号“#”，#以及#后面的字符称之为 hash，用 <code>window.location.hash</code> 读取。特点：hash 虽然在 URL 中，但不被包括在 HTTP 请求中；用来指导浏览器动作，对服务端安全无用，hash 不会重加载页面。</p></li><li><p>history 模式：history 采用 HTML5 的新特性；且提供了两个新方法： <code>pushState()， replaceState()</code>可以对浏览器历史记录栈进行修改，以及<code>popState</code>事件的监听到状态变更。</p></li><li><p>hash 模式中<code>（ http://localhost:8080#home）</code>，即使不需要配置，静态服务器始终会去寻找<code>index.html</code>并返回给我们，然后<code>vue-router</code>会获取 #后面的字符作为参数，对前端页面进行变换。</p></li><li><p>history 模式中，我们所想要的情况就是：输入<code>http://localhost:8080/home</code>，但最终返回的也是<code>index.html</code>，然后<code>vue-router</code>会获取 home 作为参数，对前端页面进行变换。那么在<code>nginx</code>中，谁能做到这件事呢？答案就是<code>try_files</code>。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E5%88%86%E4%BA%AB8%E4%B8%AAVue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"/>
      <url>2020/12/29/%E5%88%86%E4%BA%AB8%E4%B8%AAVue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-自定义指令"><a href="#Vue-自定义指令" class="headerlink" title="Vue 自定义指令"></a>Vue 自定义指令</h1><p>在 Vue，除了核心功能默认内置的指令 ( v-model 和 v-show )，Vue 也允许注册自定义指令。它的作用价值在于当开发人员在某些场景下需要对普通 DOM 元素进行操作。</p><p>Vue 自定义指令有全局注册和局部注册两种方式。先来看看注册全局指令的方式，通过 <code>Vue.directive( id, [definition] )</code> 方式注册全局指令。然后在入口文件中进行 <code>Vue.use()</code> 调用。</p><p>批量注册指令，新建 <code>directives/index.js</code> 文件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy <span class="keyword">from</span> <span class="string">'./copy'</span></span><br><span class="line"><span class="keyword">import</span> longpress <span class="keyword">from</span> <span class="string">'./longpress'</span></span><br><span class="line"><span class="comment">// 自定义指令</span></span><br><span class="line"><span class="keyword">const</span> directives = {</span><br><span class="line">  copy,</span><br><span class="line">  longpress,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="function"><span class="title">install</span>(<span class="params">Vue</span>)</span> {</span><br><span class="line">    <span class="built_in">Object</span>.keys(directives).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> {</span><br><span class="line">      Vue.directive(key, directives[key])</span><br><span class="line">    })</span><br><span class="line">  },</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 <code>main.js</code> 引入并调用</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Directives <span class="keyword">from</span> <span class="string">'./JS/directives'</span></span><br><span class="line">Vue.use(Directives)</span><br></pre></td></tr></tbody></table></figure><p>指令定义函数提供了几个钩子函数（可选）：</p><ul><li>bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作。</li><li>inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li><li>update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值。</li><li>componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。</li><li>unbind: 只调用一次， 指令与元素解绑时调用。</li></ul><p>下面分享几个实用的 Vue 自定义指令</p><ul><li>复制粘贴指令 <code>v-copy</code></li><li>长按指令 <code>v-longpress</code></li><li>输入框防抖指令 <code>v-debounce</code></li><li>禁止表情及特殊字符 <code>v-emoji</code></li><li>图片懒加载 <code>v-LazyLoad</code></li><li>权限校验指令 <code>v-premission</code></li><li>实现页面水印 <code>v-waterMarker</code></li><li>拖拽指令 <code>v-draggable</code></li></ul><h2 id="v-copy"><a href="#v-copy" class="headerlink" title="v-copy"></a>v-copy</h2><p>需求：实现一键复制文本内容，用于鼠标右键粘贴。</p><p>思路：</p><ol><li>动态创建 <code>textarea</code> 标签，并设置 <code>readOnly</code> 属性及移出可视区域</li><li>将要复制的值赋给 <code>textarea</code> 标签的 <code>value</code> 属性，并插入到 <code>body</code></li><li>选中值 <code>textarea</code> 并复制</li><li>将 <code>body</code> 中插入的 <code>textarea</code> 移除</li><li>在第一次调用时绑定事件，在解绑时移除事件</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> copy = {</span><br><span class="line">  <span class="function"><span class="title">bind</span>(<span class="params">el, { value }</span>)</span> {</span><br><span class="line">    el.$value = value</span><br><span class="line">    el.handler = <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="keyword">if</span> (!el.$value) {</span><br><span class="line">        <span class="comment">// 值为空的时候，给出提示。可根据项目UI仔细设计</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'无复制内容'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 动态创建 textarea 标签</span></span><br><span class="line">      <span class="keyword">const</span> textarea = <span class="built_in">document</span>.createElement(<span class="string">'textarea'</span>)</span><br><span class="line">      <span class="comment">// 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域</span></span><br><span class="line">      textarea.readOnly = <span class="string">'readonly'</span></span><br><span class="line">      textarea.style.position = <span class="string">'absolute'</span></span><br><span class="line">      textarea.style.left = <span class="string">'-9999px'</span></span><br><span class="line">      <span class="comment">// 将要 copy 的值赋给 textarea 标签的 value 属性</span></span><br><span class="line">      textarea.value = el.$value</span><br><span class="line">      <span class="comment">// 将 textarea 插入到 body 中</span></span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(textarea)</span><br><span class="line">      <span class="comment">// 选中值并复制</span></span><br><span class="line">      textarea.select()</span><br><span class="line">      <span class="keyword">const</span> result = <span class="built_in">document</span>.execCommand(<span class="string">'Copy'</span>)</span><br><span class="line">      <span class="keyword">if</span> (result) {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'复制成功'</span>) <span class="comment">// 可根据项目UI仔细设计</span></span><br><span class="line">      }</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(textarea)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 绑定点击事件，就是所谓的一键 copy 啦</span></span><br><span class="line">    el.addEventListener(<span class="string">'click'</span>, el.handler)</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 当传进来的值更新的时候触发</span></span><br><span class="line">  <span class="function"><span class="title">componentUpdated</span>(<span class="params">el, { value }</span>)</span> {</span><br><span class="line">    el.$value = value</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 指令与元素解绑的时候，移除事件绑定</span></span><br><span class="line">  <span class="function"><span class="title">unbind</span>(<span class="params">el</span>)</span> {</span><br><span class="line">    el.removeEventListener(<span class="string">'click'</span>, el.handler)</span><br><span class="line">  },</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> copy</span><br></pre></td></tr></tbody></table></figure><p>使用：给 Dom 加上 <code>v-copy</code> 及复制的文本即可</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-copy</span>=<span class="string">"copyText"</span>&gt;</span>复制<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> {</span></span><br><span class="line"><span class="javascript">        copyText: <span class="string">'a copy directives'</span>,</span></span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="v-longpress"><a href="#v-longpress" class="headerlink" title="v-longpress"></a>v-longpress</h2><p>需求：实现长按，用户需要按下并按住按钮几秒钟，触发相应的事件</p><p>思路：</p><ol><li>创建一个计时器， 2 秒后执行函数</li><li>当用户按下按钮时触发 <code>mousedown</code> 事件，启动计时器；用户松开按钮时调用<code> mouseout</code> 事件。</li><li>如果 <code>mouseup</code> 事件 2 秒内被触发，就清除计时器，当作一个普通的点击事件</li><li>如果计时器没有在 2 秒内清除，则判定为一次长按，可以执行关联的函数。</li><li>在移动端要考虑 <code>touchstart</code>，<code>touchend</code> 事件</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> longpress = {</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding, vNode</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> binding.value !== <span class="string">'function'</span>) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">'callback must be a function'</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 定义变量</span></span><br><span class="line">    <span class="keyword">let</span> pressTimer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 创建计时器（ 2秒后执行函数 ）</span></span><br><span class="line">    <span class="keyword">let</span> start = <span class="function">(<span class="params">e</span>) =&gt;</span> {</span><br><span class="line">      <span class="keyword">if</span> (e.type === <span class="string">'click'</span> &amp;&amp; e.button !== <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (pressTimer === <span class="literal">null</span>) {</span><br><span class="line">        pressTimer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">          handler()</span><br><span class="line">        }, <span class="number">2000</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 取消计时器</span></span><br><span class="line">    <span class="keyword">let</span> cancel = <span class="function">(<span class="params">e</span>) =&gt;</span> {</span><br><span class="line">      <span class="keyword">if</span> (pressTimer !== <span class="literal">null</span>) {</span><br><span class="line">        <span class="built_in">clearTimeout</span>(pressTimer)</span><br><span class="line">        pressTimer = <span class="literal">null</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 运行函数</span></span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function">(<span class="params">e</span>) =&gt;</span> {</span><br><span class="line">      binding.value(e)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 添加事件监听器</span></span><br><span class="line">    el.addEventListener(<span class="string">'mousedown'</span>, start)</span><br><span class="line">    el.addEventListener(<span class="string">'touchstart'</span>, start)</span><br><span class="line">    <span class="comment">// 取消计时器</span></span><br><span class="line">    el.addEventListener(<span class="string">'click'</span>, cancel)</span><br><span class="line">    el.addEventListener(<span class="string">'mouseout'</span>, cancel)</span><br><span class="line">    el.addEventListener(<span class="string">'touchend'</span>, cancel)</span><br><span class="line">    el.addEventListener(<span class="string">'touchcancel'</span>, cancel)</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 当传进来的值更新的时候触发</span></span><br><span class="line">  <span class="function"><span class="title">componentUpdated</span>(<span class="params">el, { value }</span>)</span> {</span><br><span class="line">    el.$value = value</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 指令与元素解绑的时候，移除事件绑定</span></span><br><span class="line">  <span class="function"><span class="title">unbind</span>(<span class="params">el</span>)</span> {</span><br><span class="line">    el.removeEventListener(<span class="string">'click'</span>, el.handler)</span><br><span class="line">  },</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> longpress</span><br></pre></td></tr></tbody></table></figure><p>使用：给 Dom 加上 <code>v-longpress</code> 及回调函数即可</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-longpress</span>=<span class="string">"longpress"</span>&gt;</span>长按<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line">  methods: {</span><br><span class="line">    longpress () {</span><br><span class="line"><span class="javascript">      alert(<span class="string">'长按指令生效'</span>)</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="v-debounce"><a href="#v-debounce" class="headerlink" title="v-debounce"></a>v-debounce</h2><p>背景：在开发中，有些提交保存按钮有时候会在短时间内被点击多次，这样就会多次重复请求后端接口，造成数据的混乱，比如新增表单的提交按钮，多次点击就会新增多条重复的数据。</p><p>需求：防止按钮在短时间内被多次点击，使用防抖函数限制规定时间内只能点击一次。</p><p>思路：</p><ol><li>定义一个延迟执行的方法，如果在延迟时间内再调用该方法，则重新计算执行时间。</li><li>将时间绑定在 click 方法上。</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debounce = {</span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    el.addEventListener(<span class="string">'keyup'</span>, <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="keyword">if</span> (timer) {</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      }</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">        binding.value()</span><br><span class="line">      }, <span class="number">1000</span>)</span><br><span class="line">    })</span><br><span class="line">  },</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> debounce</span><br></pre></td></tr></tbody></table></figure><p>使用：给 Dom 加上 <code>v-debounce</code> 及回调函数即可</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-debounce</span>=<span class="string">"debounceClick"</span>&gt;</span>防抖<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line">  methods: {</span><br><span class="line">    debounceClick () {</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'只触发一次'</span>)</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="v-emoji"><a href="#v-emoji" class="headerlink" title="v-emoji"></a>v-emoji</h2><p>背景：开发中遇到的表单输入，往往会有对输入内容的限制，比如不能输入表情和特殊字符，只能输入数字或字母等。</p><p>我们常规方法是在每一个表单的 <code>on-change</code> 事件上做处理。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"note"</span> @<span class="attr">change</span>=<span class="string">"vaidateEmoji"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line">    methods: {</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">vaidateEmoji</span>(<span class="params"></span>)</span> {</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> reg = <span class="regexp">/[^\u4E00-\u9FA5|\d|\a-zA-Z|\r\n\s,.?!，。？！…—&amp;$=()-+/*{}[\]]|\s/g</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.note = <span class="built_in">this</span>.note.replace(reg, <span class="string">''</span>)</span></span><br><span class="line">      },</span><br><span class="line">    },</span><br><span class="line">  }</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这样代码量比较大而且不好维护，所以我们需要自定义一个指令来解决这问题。</p><p>需求：根据正则表达式，设计自定义处理表单输入规则的指令，下面以禁止输入表情和特殊字符为例。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> findEle = <span class="function">(<span class="params">parent, type</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> parent.tagName.toLowerCase() === type ? parent : parent.querySelector(type)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> trigger = <span class="function">(<span class="params">el, type</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> e = <span class="built_in">document</span>.createEvent(<span class="string">'HTMLEvents'</span>)</span><br><span class="line">  e.initEvent(type, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">  el.dispatchEvent(e)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> emoji = {</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) </span>{</span><br><span class="line">    <span class="comment">// 正则规则可根据需求自定义</span></span><br><span class="line">    <span class="keyword">var</span> regRule = <span class="regexp">/[^\u4E00-\u9FA5|\d|\a-zA-Z|\r\n\s,.?!，。？！…—&amp;$=()-+/*{}[\]]|\s/g</span></span><br><span class="line">    <span class="keyword">let</span> $inp = findEle(el, <span class="string">'input'</span>)</span><br><span class="line">    el.$inp = $inp</span><br><span class="line">    $inp.handle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">      <span class="keyword">let</span> val = $inp.value</span><br><span class="line">      $inp.value = val.replace(regRule, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">      trigger($inp, <span class="string">'input'</span>)</span><br><span class="line">    }</span><br><span class="line">    $inp.addEventListener(<span class="string">'keyup'</span>, $inp.handle)</span><br><span class="line">  },</span><br><span class="line">  unbind: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>{</span><br><span class="line">    el.$inp.removeEventListener(<span class="string">'keyup'</span>, el.$inp.handle)</span><br><span class="line">  },</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> emoji</span><br></pre></td></tr></tbody></table></figure><p>使用：将需要校验的输入框加上 <code>v-emoji</code> 即可</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"note"</span> <span class="attr">v-emoji</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="v-LazyLoad"><a href="#v-LazyLoad" class="headerlink" title="v-LazyLoad"></a>v-LazyLoad</h2><p>背景：在类电商类项目，往往存在大量的图片，如 banner 广告图，菜单导航图，美团等商家列表头图等。图片众多以及图片体积过大往往会影响页面加载速度，造成不良的用户体验，所以进行图片懒加载优化势在必行。</p><p>需求：实现一个图片懒加载指令，只加载浏览器可见区域的图片。</p><p>思路：</p><ol><li>图片懒加载的原理主要是判断当前图片是否到了可视区域这一核心逻辑实现的</li><li>拿到所有的图片 Dom ，遍历每个图片判断当前图片是否到了可视区范围内</li><li>如果到了就设置图片的 <code>src</code> 属性，否则显示默认图片</li></ol><p>图片懒加载有两种方式可以实现，一是绑定 <code>srcoll</code> 事件进行监听，二是使用 <code>IntersectionObserver</code> 判断图片是否到了可视区域，但是有浏览器兼容性问题。</p><p>下面封装一个懒加载指令兼容两种方法，判断浏览器是否支持 <code>IntersectionObserver</code> API，如果支持就使用 <code>IntersectionObserver</code> 实现懒加载，否则则使用 <code>srcoll</code> 事件监听 + 节流的方法实现。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LazyLoad = {</span><br><span class="line">  <span class="comment">// install方法</span></span><br><span class="line">  <span class="function"><span class="title">install</span>(<span class="params">Vue, options</span>)</span> {</span><br><span class="line">    <span class="keyword">const</span> defaultSrc = options.default</span><br><span class="line">    Vue.directive(<span class="string">'lazy'</span>, {</span><br><span class="line">      <span class="function"><span class="title">bind</span>(<span class="params">el, binding</span>)</span> {</span><br><span class="line">        LazyLoad.init(el, binding.value, defaultSrc)</span><br><span class="line">      },</span><br><span class="line">      <span class="function"><span class="title">inserted</span>(<span class="params">el</span>)</span> {</span><br><span class="line">        <span class="keyword">if</span> (IntersectionObserver) {</span><br><span class="line">          LazyLoad.observe(el)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          LazyLoad.listenerScroll(el)</span><br><span class="line">        }</span><br><span class="line">      },</span><br><span class="line">    })</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params">el, val, def</span>)</span> {</span><br><span class="line">    el.setAttribute(<span class="string">'data-src'</span>, val)</span><br><span class="line">    el.setAttribute(<span class="string">'src'</span>, def)</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 利用IntersectionObserver监听el</span></span><br><span class="line">  <span class="function"><span class="title">observe</span>(<span class="params">el</span>)</span> {</span><br><span class="line">    <span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries</span>) =&gt;</span> {</span><br><span class="line">      <span class="keyword">const</span> realSrc = el.dataset.src</span><br><span class="line">      <span class="keyword">if</span> (entries[<span class="number">0</span>].isIntersecting) {</span><br><span class="line">        <span class="keyword">if</span> (realSrc) {</span><br><span class="line">          el.src = realSrc</span><br><span class="line">          el.removeAttribute(<span class="string">'data-src'</span>)</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    })</span><br><span class="line">    io.observe(el)</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 监听scroll事件</span></span><br><span class="line">  <span class="function"><span class="title">listenerScroll</span>(<span class="params">el</span>)</span> {</span><br><span class="line">    <span class="keyword">const</span> handler = LazyLoad.throttle(LazyLoad.load, <span class="number">300</span>)</span><br><span class="line">    LazyLoad.load(el)</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, <span class="function">() =&gt;</span> {</span><br><span class="line">      handler(el)</span><br><span class="line">    })</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 加载真实图片</span></span><br><span class="line">  <span class="function"><span class="title">load</span>(<span class="params">el</span>)</span> {</span><br><span class="line">    <span class="keyword">const</span> windowHeight = <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">    <span class="keyword">const</span> elTop = el.getBoundingClientRect().top</span><br><span class="line">    <span class="keyword">const</span> elBtm = el.getBoundingClientRect().bottom</span><br><span class="line">    <span class="keyword">const</span> realSrc = el.dataset.src</span><br><span class="line">    <span class="keyword">if</span> (elTop - windowHeight &lt; <span class="number">0</span> &amp;&amp; elBtm &gt; <span class="number">0</span>) {</span><br><span class="line">      <span class="keyword">if</span> (realSrc) {</span><br><span class="line">        el.src = realSrc</span><br><span class="line">        el.removeAttribute(<span class="string">'data-src'</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 节流</span></span><br><span class="line">  <span class="function"><span class="title">throttle</span>(<span class="params">fn, delay</span>)</span> {</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">let</span> prevTime</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>{</span><br><span class="line">      <span class="keyword">const</span> currTime = <span class="built_in">Date</span>.now()</span><br><span class="line">      <span class="keyword">const</span> context = <span class="built_in">this</span></span><br><span class="line">      <span class="keyword">if</span> (!prevTime) prevTime = currTime</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (currTime - prevTime &gt; delay) {</span><br><span class="line">        prevTime = currTime</span><br><span class="line">        fn.apply(context, args)</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        prevTime = <span class="built_in">Date</span>.now()</span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">        fn.apply(context, args)</span><br><span class="line">      }, delay)</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> LazyLoad</span><br></pre></td></tr></tbody></table></figure><p>使用，将组件内 <img> 标签的 <code>src</code> 换成 <code>v-LazyLoad</code></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-LazyLoad</span>=<span class="string">"xxx.jpg"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="v-permission"><a href="#v-permission" class="headerlink" title="v-permission"></a>v-permission</h2><p>背景：在一些后台管理系统，我们可能需要根据用户角色进行一些操作权限的判断，很多时候我们都是粗暴地给一个元素添加 <code>v-if / v-show</code> 来进行显示隐藏，但如果判断条件繁琐且多个地方需要判断，这种方式的代码不仅不优雅而且冗余。针对这种情况，我们可以通过全局自定义指令来处理。</p><p>需求：自定义一个权限指令，对需要权限判断的 Dom 进行显示隐藏。</p><p>思路：</p><ol><li>自定义一个权限数组</li><li>判断用户的权限是否在这个数组内，如果是则显示，否则则移除 Dom</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkArray</span>(<span class="params">key</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> arr = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>]</span><br><span class="line">  <span class="keyword">let</span> index = arr.indexOf(key)</span><br><span class="line">  <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 有权限</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 无权限</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> permission = {</span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> permission = binding.value <span class="comment">// 获取到 v-permission的值</span></span><br><span class="line">    <span class="keyword">if</span> (permission) {</span><br><span class="line">      <span class="keyword">let</span> hasPermission = checkArray(permission)</span><br><span class="line">      <span class="keyword">if</span> (!hasPermission) {</span><br><span class="line">        <span class="comment">// 没有权限 移除Dom元素</span></span><br><span class="line">        el.parentNode &amp;&amp; el.parentNode.removeChild(el)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> permission</span><br></pre></td></tr></tbody></table></figure><p>使用：给 <code>v-permission</code> 赋值判断即可</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"btns"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 显示 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-permission</span>=<span class="string">"'1'"</span>&gt;</span>权限按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 不显示 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-permission</span>=<span class="string">"'10'"</span>&gt;</span>权限按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="vue-waterMarker"><a href="#vue-waterMarker" class="headerlink" title="vue-waterMarker"></a>vue-waterMarker</h2><p>需求：给整个页面添加背景水印</p><p>思路：</p><ol><li>使用 <code>canvas</code> 特性生成 <code>base64</code> 格式的图片文件，设置其字体大小，颜色等。</li><li>将其设置为背景图片，从而实现页面或组件水印效果</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addWaterMarker</span>(<span class="params">str, parentNode, font, textColor</span>) </span>{</span><br><span class="line">  <span class="comment">// 水印文字，父元素，字体，文字颜色</span></span><br><span class="line">  <span class="keyword">var</span> can = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line">  parentNode.appendChild(can)</span><br><span class="line">  can.width = <span class="number">200</span></span><br><span class="line">  can.height = <span class="number">150</span></span><br><span class="line">  can.style.display = <span class="string">'none'</span></span><br><span class="line">  <span class="keyword">var</span> cans = can.getContext(<span class="string">'2d'</span>)</span><br><span class="line">  cans.rotate((-<span class="number">20</span> * <span class="built_in">Math</span>.PI) / <span class="number">180</span>)</span><br><span class="line">  cans.font = font || <span class="string">'16px Microsoft JhengHei'</span></span><br><span class="line">  cans.fillStyle = textColor || <span class="string">'rgba(180, 180, 180, 0.3)'</span></span><br><span class="line">  cans.textAlign = <span class="string">'left'</span></span><br><span class="line">  cans.textBaseline = <span class="string">'Middle'</span></span><br><span class="line">  cans.fillText(str, can.width / <span class="number">10</span>, can.height / <span class="number">2</span>)</span><br><span class="line">  parentNode.style.backgroundImage = <span class="string">'url('</span> + can.toDataURL(<span class="string">'image/png'</span>) + <span class="string">')'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> waterMarker = {</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>{</span><br><span class="line">    addWaterMarker(binding.value.text, el, binding.value.font, binding.value.textColor)</span><br><span class="line">  },</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> waterMarker</span><br></pre></td></tr></tbody></table></figure><p>使用，设置水印文案，颜色，字体大小即可</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-waterMarker</span>=<span class="string">"{text:'lzg版权所有',textColor:'rgba(180, 180, 180, 0.4)'}"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="v-draggable"><a href="#v-draggable" class="headerlink" title="v-draggable"></a>v-draggable</h2><p>需求：实现一个拖拽指令，可在页面可视区域任意拖拽元素。</p><p>思路：</p><ol><li>设置需要拖拽的元素为相对定位，其父元素为绝对定位。</li><li>鼠标按下<code>(onmousedown)</code>时记录目标元素当前的 <code>left</code> 和 <code>top</code> 值。</li><li>鼠标移动<code>(onmousemove)</code>时计算每次移动的横向距离和纵向距离的变化值，并改变元素的 <code>left</code> 和 <code>top</code> 值</li><li>鼠标松开<code>(onmouseup)</code>时完成一次拖拽</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> draggable = {</span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>{</span><br><span class="line">    el.style.cursor = <span class="string">'move'</span></span><br><span class="line">    el.onmousedown = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>{</span><br><span class="line">      <span class="keyword">let</span> disx = e.pageX - el.offsetLeft</span><br><span class="line">      <span class="keyword">let</span> disy = e.pageY - el.offsetTop</span><br><span class="line">      <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>{</span><br><span class="line">        <span class="keyword">let</span> x = e.pageX - disx</span><br><span class="line">        <span class="keyword">let</span> y = e.pageY - disy</span><br><span class="line">        <span class="keyword">let</span> maxX = <span class="built_in">document</span>.body.clientWidth - <span class="built_in">parseInt</span>(<span class="built_in">window</span>.getComputedStyle(el).width)</span><br><span class="line">        <span class="keyword">let</span> maxY = <span class="built_in">document</span>.body.clientHeight - <span class="built_in">parseInt</span>(<span class="built_in">window</span>.getComputedStyle(el).height)</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) {</span><br><span class="line">          x = <span class="number">0</span></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; maxX) {</span><br><span class="line">          x = maxX</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">0</span>) {</span><br><span class="line">          y = <span class="number">0</span></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (y &gt; maxY) {</span><br><span class="line">          y = maxY</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        el.style.left = x + <span class="string">'px'</span></span><br><span class="line">        el.style.top = y + <span class="string">'px'</span></span><br><span class="line">      }</span><br><span class="line">      <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        <span class="built_in">document</span>.onmousemove = <span class="built_in">document</span>.onmouseup = <span class="literal">null</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">}</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> draggable</span><br></pre></td></tr></tbody></table></figure><p>使用: 在 Dom 上加上 v-draggable 即可</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"el-dialog"</span> <span class="attr">v-draggable</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E4%BB%8E%20js%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9C%8B%20Vue.nextTick%20%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>2020/12/29/%E4%BB%8E%20js%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9C%8B%20Vue.nextTick%20%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-nextTick"><a href="#vue-nextTick" class="headerlink" title="vue.$nextTick"></a>vue.$nextTick</h1><p>Vue 的特点之一就是响应式，但是有些时候数据更新了，我们看到页面上的 DOM 并没有立刻更新。如果我们需要在 DOM 更新之后再执行一段代码时，可以借助 nextTick 实现。</p><p>我们先来看一个例子</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      msg: <span class="number">0</span></span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.msg = <span class="number">1</span></span><br><span class="line">    <span class="built_in">this</span>.msg = <span class="number">2</span></span><br><span class="line">    <span class="built_in">this</span>.msg = <span class="number">3</span></span><br><span class="line">  },</span><br><span class="line">  watch: {</span><br><span class="line">    <span class="function"><span class="title">msg</span>(<span class="params"></span>)</span> {</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里的结果是只输出一个 3，而非依次输出 1，2，3。这是为什么呢？<br>vue 的官方文档是这样解释的</p><blockquote><p>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0)代替。</p></blockquote><p>假如有这样一种情况，<code>mounted</code>钩子函数下一个变量 a 的值会被++循环执行 1000 次。 每次++时，都会根据响应式触发<code>setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;run</code>。 如果这时候没有异步更新视图，那么每次++都会直接操作 DOM 一次，这是非常消耗性能的。 所以 Vue 实现了一个<code>queue</code>队列，在下一个 Tick（或者是当前 Tick 的微任务阶段）的时候会统一执行<code>queue</code>中<code>Watcher</code>的<code>run</code>。同时，拥有相同 id 的<code>Watcher</code>不会被重复加入到该<code>queue</code>中去，所以不会执行 1000 次<code>Watcher</code>的<code>run</code>。最终的结果是直接把 a 的值从 1 变成 1000，大大提升了性能。</p><p>在 vue 中，数据监测都是通过 Object.defineProperty 来重写里面的 set 和 get 方法实现的，vue 更新 DOM 是异步的，每当观察到数据变化时，vue 就开始一个队列，将同一事件循环内所有的数据变化缓存起来，等到下一次 event loop，将会把队列清空，进行 dom 更新。</p><p>想要了解 vue.nextTick 的执行机制，我们先来了解一下 javascript 的事件循环。</p><h3 id="js-事件循环"><a href="#js-事件循环" class="headerlink" title="js 事件循环"></a>js 事件循环</h3><p>js 的任务队列分为同步任务和异步任务，所有的同步任务都是在主线程里执行的。异步任务可能会在 macrotask 或者 microtask 里面，异步任务进入 <code>Event Table</code> 并注册函数。当指定的事情完成时，<code>Event Table</code> 会将这个函数移入 <code>Event Queue</code>。主线程内的任务执行完毕为空，会去 <code>Event Queue</code> 读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的 <code>Event Loop</code>(事件循环)。</p><img src="../img/js3.png"><h4 id="macro-task-宏任务-："><a href="#macro-task-宏任务-：" class="headerlink" title="macro-task(宏任务)："></a>macro-task(宏任务)：</h4><p>每次执行栈执行的代码就是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)。浏览器为了能够使得 js 内部<code>(macro)task</code>与 DOM 任务能够有序执行，会在一个<code>(macro)task</code>执行结束后，在下一个<code>(macro)task</code>执行开始前，对页面进行重新渲染。宏任务主要包含：</p><ul><li>script(整体代码)</li><li>setTimeout / setInterval</li><li>setImmediate(Node.js 环境)</li><li>I/O</li><li>UI render</li><li>postMessage</li><li>MessageChannel</li></ul><h4 id="micro-task-微任务-："><a href="#micro-task-微任务-：" class="headerlink" title="micro-task(微任务)："></a>micro-task(微任务)：</h4><p>可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前。所以它的响应速度相比 setTimeout（setTimeout 是 task）会更快，因为无需等渲染。也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）。microtask 主要包含：</p><ul><li>process.nextTick(Node.js 环境)</li><li>Promise</li><li>Async/Await</li><li>MutationObserver(html5 新特性)</li></ul><img src="../img/eventLoop.png" width="80%"><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>先执行主线程</li><li>遇到宏队列（macrotask）放到宏队列（macrotask）</li><li>遇到微队列（microtask）放到微队列（microtask）</li><li>主线程执行完毕</li><li>执行微队列（microtask），微队列（microtask）执行完毕</li><li>执行一次宏队列（macrotask）中的一个任务，执行完毕</li><li>执行微队列（microtask），执行完毕</li><li>依次循环。。。</li></ol><h3 id="Vue-nextTick-源码"><a href="#Vue-nextTick-源码" class="headerlink" title="Vue.nextTick 源码"></a>Vue.nextTick 源码</h3><p>vue 是采用双向数据绑定的方法驱动数据更新的，虽然这样能避免直接操作 dom，提高了性能，但有时我们也不可避免需要操作 DOM，这时就该 Vue.nextTick(callback)出场了，它接受一个回调函数，在 DOM 更新完成后，这个回调函数就会被调用。不管是 vue.nextTick 还是 vue.prototype.$nextTick 都是直接用的 nextTick 这个闭包函数。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> nextTick = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">const</span> callbacks = []</span><br><span class="line">  <span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">nextTickHandler</span> (<span class="params"></span>) </span>{</span><br><span class="line">    pending = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">    callbacks.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) {</span><br><span class="line">      copies[i]()</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"> ...</span><br><span class="line">})()</span><br></pre></td></tr></tbody></table></figure><p>使用数组 callbacks 保存回调函数，pending 表示当前状态，使用函数 nextTickHandler 来执行回调队列。在该方法内，先通过 slice(0)保存了回调队列的一个副本，通过设置 callbacks.length = 0 清空回调队列，最后使用循环执行在副本里的所有函数。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) {</span><br><span class="line">  <span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  <span class="keyword">var</span> logError = <span class="function"><span class="params">err</span> =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  }</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> {</span><br><span class="line">    p.then(nextTickHandler).catch(logError)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  }</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (isNative(MutationObserver) || MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span>)) {</span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(nextTickHandler)</span><br><span class="line">  <span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, {</span><br><span class="line">    characterData: <span class="literal">true</span></span><br><span class="line">  })</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> {</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">  }</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  timeFunc = <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="built_in">setTimeout</span>(nextTickHandle, <span class="number">0</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>队列控制的最佳选择是 microtask，而 microtask 的最佳选择是 Promise。但如果当前环境不支持 Promise，就检测到浏览器是否支持 MO，是则创建一个文本节点，监听这个文本节点的改动事件，以此来触发 nextTickHandler（也就是 DOM 更新完毕回调）的执行。此外因为兼容性问题，vue 不得不做了 microtask 向 macrotask 的降级方案。</p><p>为让这个回调函数延迟执行，vue 优先用 promise 来实现，其次是 html5 的 MutationObserver，然后是 setTimeout。前两者属于 microtask，后一个属于 macrotask。下面来看最后一部分。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">queueNextTick</span>(<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="keyword">if</span> (cb) cb.call(ctx)</span><br><span class="line">    <span class="keyword">if</span> (_resolve) _resolve(ctx)</span><br><span class="line">  })</span><br><span class="line">  <span class="keyword">if</span> (!pending) {</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    timerFunc()</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> {</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    })</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这就是我们真正调用的 nextTick 函数，在一个 event loop 内它会将调用 nextTick 的 cb 回调函数都放入 callbacks 中，pending 用于判断是否有队列正在执行回调，例如有可能在 nextTick 中还有一个 nextTick，此时就应该属于下一个循环了。最后几行代码是 promise 化，可以将 nextTick 按照 promise 方式去书写（暂且用的较少）。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>场景一、点击按钮显示原本以 v-show = false 隐藏起来的输入框，并获取焦点。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"keywords"</span> v-<span class="keyword">if</span>=<span class="string">"showit"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">showInput</span>(<span class="params"></span>)</span>{</span><br><span class="line">  <span class="built_in">this</span>.showit = <span class="literal">true</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"keywords"</span>).focus()</span><br></pre></td></tr></tbody></table></figure><p>以上的写法在第一个 tick 里，因为获取不到输入框，自然也获取不到焦点。如果我们改成以下的写法，在 DOM 更新后就可以获取到输入框焦点了。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">showsou</span>(<span class="params"></span>)</span>{</span><br><span class="line">  <span class="built_in">this</span>.showit = <span class="literal">true</span></span><br><span class="line">  <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">// DOM 更新了</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"keywords"</span>).focus()</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>场景二、获取元素属，点击获取元素宽度。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;p ref=<span class="string">"myWidth"</span> v-<span class="keyword">if</span>=<span class="string">"showMe"</span>&gt;{{ message }}&lt;/p&gt;</span><br><span class="line">  &lt;button @click=<span class="string">"getMyWidth"</span>&gt;获取p元素宽度&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">getMyWidth</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">this</span>.showMe = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">this</span>.message = <span class="built_in">this</span>.$refs.myWidth.offsetWidth;</span><br><span class="line">  <span class="comment">//报错 TypeError: this.$refs.myWidth is undefined</span></span><br><span class="line">  <span class="built_in">this</span>.$nextTick(<span class="function">()=&gt;</span>{</span><br><span class="line">      <span class="comment">//dom元素更新后执行，此时能拿到p元素的属性</span></span><br><span class="line">    <span class="built_in">this</span>.message = <span class="built_in">this</span>.$refs.myWidth.offsetWidth;</span><br><span class="line">})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E8%B0%88%E8%B0%88%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>2020/12/29/%E8%B0%88%E8%B0%88%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>前端开发中总免不了关于文件的上传、下载需求。下面来总结一下常用的方法，欢迎讨论和吐槽。</p><h3 id="form-表单提交"><a href="#form-表单提交" class="headerlink" title="form 表单提交"></a>form 表单提交</h3><p>最传统的文件上传方法是使用<code>form</code>表单上传文件的，只需要把<code>enctype</code>设置为 <code>multipart/form-data</code>。这种方式上传文件不需要 js ，而且没有兼容问题，所有浏览器都支持，就是体验很差，导致页面刷新，页面其他数据丢失。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"xxxxx"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  选择文件:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  标题：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"title"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>注意：<code>input</code> 必须设置 <code>name</code> 属性，否则数据无法发送</strong></p><h3 id="文件接口上传"><a href="#文件接口上传" class="headerlink" title="文件接口上传"></a>文件接口上传</h3><p>这种方法由服务端提供接口，设置相应的请求头，前端提交 <code>formData</code> 形式的文件数据。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"uploadFile"</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/png,image/gif"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>accept</code>：表示可以选择的文件 MIME 类型，多个 MIME 类型用英文逗号分开</li><li><code>multiple</code>：是否可以选择多个文件</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#uploadFile'</span>).on(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> file = <span class="built_in">this</span>.files[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">  formData.append(<span class="string">'file'</span>, file)</span><br><span class="line"></span><br><span class="line">  $.ajax({</span><br><span class="line">    url: <span class="string">'xxxx'</span>,</span><br><span class="line">    type: <span class="string">'post'</span>,</span><br><span class="line">    data: formData,</span><br><span class="line">    cache: <span class="literal">false</span>,</span><br><span class="line">    contentType: <span class="literal">false</span>,</span><br><span class="line">    processData: <span class="literal">false</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>{</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">    },</span><br><span class="line">  })</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><ul><li><code>processData</code> 设置为 false。因为 data 值是 <code>FormData</code> 对象，不需要对数据做处理。</li><li><code>cache</code> 设置为 false，上传文件不需要缓存。</li><li><code>contentType</code> 设置为 false。</li></ul><h3 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h3><p>有时候我们上传的文件可能很大，比如视频等可能达到 2 个 G，这样会造成上传速度太慢，甚至有时候会出现链接超时的情况。而且有时候服务端会设置文件允许上传的大小，太大的文件就不允许上传了。为解决这个问题，我们可以将文件进行分片上传，每次只上传很小的一部分 比如 1M。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>将文件按一定大小(比如 1M)截取成一小份，并将切片带上 hash 值，用于作为标识。</li><li>将每个切片文件并发提交到服务端，服务端保存每个切片文件的信息。</li><li>切片上传完成后，服务端根据文件标识进行合并，合并完后删除切片文件。</li></ol><p>这样因为每个切片是并发上传的，所以可以有效地降低上传时间。下面说一下具体的实现步骤。（PS：这是我司的实现方式，并不是唯一方法，且涉及到具体接口的代码就不贴在这里了）</p><h4 id="生成-hash-值"><a href="#生成-hash-值" class="headerlink" title="生成 hash 值"></a>生成 hash 值</h4><p>无论上传文件信息还是上传切片文件，都必须要生成文件和切片的 <code>hash</code>。最简单粗暴的 <code>hash</code> 值可以用文件名字+下标来标识，但是这样文件名一旦修改就失去了效果，而事实上只要文件内容不变，<code>hash</code> 就不应该变化，所以正确的做法是根据文件内容生成 <code>hash</code>。我司用的是 <code>spark-md5</code> 库，在这里就不一一细说了。</p><h4 id="文件信息上传"><a href="#文件信息上传" class="headerlink" title="文件信息上传"></a>文件信息上传</h4><p>在文件分片上传之前需要把整个文件的信息如该文件的总的文件大小、文件名、哈希值等等，主要目的是初始化一个文件分片上传事件，返回文件 id，用于每个分片的提交。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">getFileId (file) {</span><br><span class="line">  <span class="keyword">let</span> vm = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">let</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">  formData.append(<span class="string">'file'</span>, file)</span><br><span class="line">  axios({</span><br><span class="line">    timeout: <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>,</span><br><span class="line">    headers: {</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/json-'</span>,</span><br><span class="line">      <span class="string">'x-data'</span>: <span class="built_in">JSON</span>.stringify({</span><br><span class="line">        fileName: file.fileName,</span><br><span class="line">        size: file.size,</span><br><span class="line">        hash: <span class="string">'hashxxx'</span>,</span><br><span class="line">      }),</span><br><span class="line">    },</span><br><span class="line">    url: <span class="string">'xxxxxx'</span>,</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">  })</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">if</span> (res.code === <span class="string">'200'</span>) {</span><br><span class="line">      <span class="keyword">return</span> res.data.fileId</span><br><span class="line">    })</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="文件切片分割"><a href="#文件切片分割" class="headerlink" title="文件切片分割"></a>文件切片分割</h4><p>当前端获取到本地图片后，利用 <code>Blob.prototype.slice</code> 方法（和数组的 <code>slice</code> 方法相似），将大文件按照没小片 1M 进行切割，返回原文件的某个切片，再并发将各个分片上传到服务端。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">getCkunk (file, fileId) {</span><br><span class="line">  <span class="keyword">let</span> vm = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">let</span> chunkSize = <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">  <span class="keyword">let</span> totalSize = file.size</span><br><span class="line">  <span class="keyword">let</span> count = <span class="built_in">Math</span>.ceil(totalSize / chunkSize)</span><br><span class="line">  <span class="keyword">let</span> chunkArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">    <span class="keyword">if</span> (i === count.length - <span class="number">1</span>) {</span><br><span class="line">      chunkArr.push(file.slice(i * chunkSize, totalSize))</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      chunkArr.push(file.slice(i * chunkSize, (i + <span class="number">1</span>) * chunkSize))</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; count; index++) {</span><br><span class="line">    <span class="keyword">let</span> item = chunkArr[index]</span><br><span class="line">    <span class="built_in">this</span>.uploadChunk(item, index, fileId)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>各个分片上传到服务端的方法。此处省略 hash 值得获取方式。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">ploadChunk</span>(<span class="params">item, index, fileId</span>)</span> {</span><br><span class="line">  <span class="keyword">let</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">  formData.append(<span class="string">'file'</span>, item)</span><br><span class="line">  request({</span><br><span class="line">    headers: {</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/octet-stream;'</span>,</span><br><span class="line">      <span class="string">'x-data'</span>: <span class="built_in">JSON</span>.stringify({</span><br><span class="line">        fileId: fileId,</span><br><span class="line">        partId: index + <span class="number">1</span>,</span><br><span class="line">        hash: res,</span><br><span class="line">      })</span><br><span class="line">    },</span><br><span class="line">    url: <span class="string">'xxxxx'</span>,</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    data: formData,</span><br><span class="line">  })</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">return</span> res.data.path</span><br><span class="line">  })</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="显示上传进度条"><a href="#显示上传进度条" class="headerlink" title="显示上传进度条"></a>显示上传进度条</h4><p>由于文件比较大，即使是采用分片上传的方式也是需要一定的时间的，为了更好的用户体验，前端最好是提示上传的进度。这时候就需要后端在每个分片的放回结果加上上传的 100%字段。前端获取到返回值就改变当前进度。</p><p>当最后一个分片上传完成后，服务端返回文件的 url，前端获取 url，同时将进度条状态改变为 100%。</p><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>上面说到的分片上传，解决了大文件上传超时和服务器的限制。但是对于更大的文件，上传并不是短时间内就上传完成，甚至有时候会面临断网或者手动暂停，难道就要重新将整个文件上传了，我们当然不希望。这时候断点续传就派上用场了。</p><p>下面说一下实现思路。<br>首先断点续传必须是基于分片上传的基础上的</p><ol><li>每个分片上传的时候，服务端记录上传好的文件 hash 值，上传成功后返回 hash 值给前端，前端记录 hash 值</li><li>重新上传时，将每个文件的 hash 值与记录的 hash 值做比对，如果相同的话则跳过，继续下一个分段的上传。</li><li>全部分片上传完成后，服务端根据文件标识进行合并，合并完后删除小文件。</li></ol><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>文件下载有以下几种方法</p><h4 id="form-表单提交-1"><a href="#form-表单提交-1" class="headerlink" title="form 表单提交"></a>form 表单提交</h4><p>这是最原始的方法，为一个下载按钮添加 click 事件，点击时动态生成一个表单，利用表单提交的功能来实现文件的下载（实际上表单的提交就是发送一个请求）。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadFile</span>(<span class="params">downloadUrl, fileName</span>) </span>{</span><br><span class="line">  <span class="comment">// 创建表单</span></span><br><span class="line">  <span class="keyword">let</span> form = <span class="built_in">document</span>.createElement(<span class="string">'form'</span>)</span><br><span class="line">  form.method = <span class="string">'get'</span></span><br><span class="line">  form.action = downloadUrl</span><br><span class="line">  <span class="comment">//form.target = '_blank';// form新开页面</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(form)</span><br><span class="line">  form.submit()</span><br><span class="line">  <span class="built_in">document</span>.body.removeChild(form)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>优点:兼容性好，不会出现 URL 长度限制问题。</li><li>缺点:无法知道下载的进度，无法直接下载浏览器可直接预览的文件类型（如 txt/png 等）</li></ul><h4 id="window-open-或-window-location-href"><a href="#window-open-或-window-location-href" class="headerlink" title="window.open 或 window.location.href"></a>window.open 或 window.location.href</h4><p>最简单最直接的方式，实际上跟 a 标签访问下载链接一样</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">'downloadFile.zip'</span>)</span><br><span class="line">location.href = <span class="string">'downloadFile.zip'</span></span><br></pre></td></tr></tbody></table></figure><p>缺点</p><ul><li>会出现 URL 长度限制问题</li><li>需要注意 url 编码问题</li><li>浏览器可直接浏览的文件类型是不提供下载的，如 txt、png、jpg、gif 等</li><li>不能添加 header，也就不能进行鉴权</li><li>无法知道下载的进度</li></ul><h4 id="a-标签-download-属性"><a href="#a-标签-download-属性" class="headerlink" title="a 标签 download 属性"></a>a 标签 download 属性</h4><p>download 属性是 HTML5 新增的属性，兼容性可以了解下 <code>can i use download</code>。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"xxxx"</span> <span class="attr">download</span>&gt;</span>点击下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 重命名下载文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"xxxx"</span> <span class="attr">download</span>=<span class="string">"test"</span>&gt;</span>点击下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>优点:能解决不能直接下载浏览器可浏览的文件。</p><p>缺点</p><ul><li>得已知下载文件地址</li><li>不能下载跨域下的浏览器可浏览的文件</li><li>有兼容性问题，特别是 IE</li><li>不能进行鉴权</li></ul><h4 id="利用-Blob-对象"><a href="#利用-Blob-对象" class="headerlink" title="利用 Blob 对象"></a>利用 Blob 对象</h4><p>此方法除了能利用已知文件地址路径进行下载外，还能通过发送 ajax 请求 api 获取文件流进行下载。利用 Blob 对象可以将文件流转化成 Blob 二进制对象。</p><p>进行下载的思路很简单：发请求获取二进制数据，转化为 Blob 对象，利用 URL.createObjectUrl 生成 url 地址，赋值在 a 标签的 href 属性上，结合 download 进行下载。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">downdFile (path, name) {</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">'get'</span>, path);</span><br><span class="line">  xhr.responseType = <span class="string">'blob'</span>;</span><br><span class="line">  xhr.send();</span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span> || <span class="built_in">this</span>.status === <span class="number">304</span>) {</span><br><span class="line">      <span class="comment">// const blob = new Blob([this.response], { type: xhr.getResponseHeader('Content-Type') });</span></span><br><span class="line">      <span class="comment">// const url = URL.createObjectURL(blob);</span></span><br><span class="line">      <span class="keyword">const</span> url = URL.createObjectURL(<span class="built_in">this</span>.response);</span><br><span class="line">      <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">      a.style.display = <span class="string">'none'</span>;</span><br><span class="line">      a.href = url;</span><br><span class="line">      a.download = name;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(a);</span><br><span class="line">      a.click();</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(a);</span><br><span class="line">      URL.revokeObjectURL(url);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E6%B5%85%E8%B0%88webscoket%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>2020/12/29/%E6%B5%85%E8%B0%88webscoket%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-webSocket"><a href="#什么是-webSocket" class="headerlink" title="什么是 webSocket"></a>什么是 webSocket</h3><p>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。  </p><p>在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><h3 id="WebSocket-解决了什么问题："><a href="#WebSocket-解决了什么问题：" class="headerlink" title="WebSocket 解决了什么问题："></a>WebSocket 解决了什么问题：</h3><p>在不使用 WebSocket 时，如果我们需要建立一条长连接，有以下几种方法：</p><ul><li>轮询</li><li>长轮询（常用）</li><li>SSE(Server Send Event)</li></ul><p>当出现类似体育赛事、聊天室、实时位置之类的场景时，客户端要获取服务器端的变化，就只能通过轮询(定时请求)来了解服务器端有没有新的信息变化。WebSocket 的出现，让服务器端可以主动向服务器端发送信息，使得浏览器具备了实时双向通信的能力,这就是 WebSocket 解决的问题</p><ul><li>带宽问题：WebSocket 相对于 HTTP 来说协议头更加小，同时按需传递。</li><li>数据实时性问题：WebSocket 相对于轮询和长轮询来说，能够实时传递数据，延迟更小。</li><li>状态问题：相较于 HTTP 的无状态请求，WebSocket 在建立连接后能够维持特定的状态。</li></ul><h3 id="WebSocket-与-HTTP-对比"><a href="#WebSocket-与-HTTP-对比" class="headerlink" title="WebSocket 与 HTTP 对比"></a>WebSocket 与 HTTP 对比</h3><p><img src="https://user-gold-cdn.xitu.io/2019/12/3/16ec9bc6c28a9a19?w=1014&amp;h=442&amp;f=png&amp;s=225703"></p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><strong>客户端</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8888'</span>)</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'WebSocket onopen'</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="params">e</span> =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">  <span class="built_in">console</span>.log(e.data)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="params">e</span> =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'WebSocket onclose'</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ws.onerror = <span class="function"><span class="params">e</span> =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'WebSocket onerror'</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>WebSocket.onopen： 连接成功后调用</li><li>WebSocket.onmessage： 当接收到服务器消息时调用</li><li>WebSocket.onclose： 连接关闭后调用</li><li>WebSocket.onerror： 发生错误后调用</li></ul><p><strong>服务端例子(koa)</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket.Server({ <span class="attr">port</span>: <span class="number">8888</span> })</span><br><span class="line"></span><br><span class="line">ws.on(<span class="string">'connection'</span>, <span class="function"><span class="params">ws</span> =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server connection'</span>)</span><br><span class="line"></span><br><span class="line">  ws.on(<span class="string">'message'</span>, <span class="function"><span class="params">msg</span> =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server receive msg：'</span>, msg)</span><br><span class="line">  })</span><br><span class="line"></span><br><span class="line">  ws.send(<span class="string">'Information from the server'</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></tbody></table></figure><p>WebSocket 可以传递 String、ArrayBuffer 和 Blob 三种数据类型，因此在收到消息时可能是其中的任意一种。其中，String 和 ArrayBuffer 使用的最多。</p><ul><li>如果是 String 类型，直接通过字符串处理函数即可进行相关转换，如 JSON 等格式。</li><li>如果是二进制 blob 类型，则需要使用 ArrayBuffer 和 DataView 来进行处理，下面简单介绍。</li></ul><p>二进制数据包括：blob 对象和 Arraybuffer 对象，所以我们需要分开来处理。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (event.data <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>) {</span><br><span class="line">    <span class="comment">// 判断 ArrayBuffer 对象</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (event.data <span class="keyword">instanceof</span> Blob) {</span><br><span class="line">    <span class="comment">// 判断 Blob 对象</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 Blob 对象的例子</span></span><br><span class="line"><span class="keyword">let</span> file = <span class="built_in">document</span>.querySelector(<span class="string">'input[type="file"]'</span>).files[<span class="number">0</span>]</span><br><span class="line">ws.send(file)</span><br><span class="line"><span class="comment">// 发送 ArrayBuffer 对象的例子</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>)</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(img.data.length)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.data.length; i++) {</span><br><span class="line">  binary[i] = img.data[i]</span><br><span class="line">}</span><br><span class="line">ws.send(binary.buffer)</span><br></pre></td></tr></tbody></table></figure><p>webSocket.bufferedAmount 属性，表示还有多少字节的二进制数据没有发送出去<br>如果发送的二进制数据很大的话，可以这样判断</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10000000</span>)</span><br><span class="line">socket.send(data)</span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) {</span><br><span class="line">  <span class="comment">// 发送完毕</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">// 发送还没结束</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="总结-WebSocket-的优点"><a href="#总结-WebSocket-的优点" class="headerlink" title="总结 WebSocket 的优点"></a>总结 WebSocket 的优点</h3><ul><li>双向通信(一开始说的，也是最重要的一点)。</li><li>数据格式比较轻量，性能开销小，通信高效</li><li>协议控制的数据包头部较小，而 HTTP 协议每次通信都需要携带完整的头部</li><li>更好的二进制支持</li><li>没有同源限制，客户端可以与任意服务器通信</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E6%80%BB%E7%BB%93%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>2020/12/29/%E6%80%BB%E7%BB%93%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="html-篇"><a href="#html-篇" class="headerlink" title="html 篇"></a>html 篇</h3><h4 id="常用的meta属性设置"><a href="#常用的meta属性设置" class="headerlink" title="常用的meta属性设置"></a>常用的meta属性设置</h4><p>meta对于移动端的一些特殊属性，可根据需要自行设置</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"screen-orientation"</span> <span class="attr">content</span>=<span class="string">"portrait"</span>&gt;</span> //Android 禁止屏幕旋转</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"full-screen"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span>             //全屏显示</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"browsermode"</span> <span class="attr">content</span>=<span class="string">"application"</span>&gt;</span>     //UC应用模式，使用了application这种应用模式后，页面讲默认全屏，禁止长按菜单，禁止收拾，标准排版，以及强制图片显示。</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-orientation"</span> <span class="attr">content</span>=<span class="string">"portrait"</span>&gt;</span>     //QQ强制竖屏</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-fullscreen"</span> <span class="attr">content</span>=<span class="string">"true"</span>&gt;</span>          //QQ强制全屏</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-page-mode"</span> <span class="attr">content</span>=<span class="string">"app"</span>&gt;</span>            //QQ应用模式</span><br></pre></td></tr></tbody></table></figure><h4 id="电话号码识别"><a href="#电话号码识别" class="headerlink" title="电话号码识别"></a>电话号码识别</h4><p>在 iOS Safari （其他浏览器和 Android 均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如：</p><ul><li>7 位数字，形如：1234567</li><li>带括号及加号的数字，形如：(+86)123456789</li><li>双连接线的数字，形如：00-00-00111</li><li>11 位数字，形如：13800138000</li></ul><p>关闭识别</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>开启识别</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"tel:123456"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="邮箱识别（Android）"><a href="#邮箱识别（Android）" class="headerlink" title="邮箱识别（Android）"></a>邮箱识别（Android）</h4><p>安卓上会对符合邮箱格式的字符串进行识别，我们可以通过如下的 meta 来管别邮箱的自动识别：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"email=no"</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>同样地，我们也可以通过标签属性来开启长按邮箱地址弹出邮件发送的功能：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">mailto:dooyoe</span>@<span class="attr">gmail.com</span>"&gt;</span>dooyoe@gmail.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="css-篇"><a href="#css-篇" class="headerlink" title="css 篇"></a>css 篇</h3><h4 id="0-5px细线"><a href="#0-5px细线" class="headerlink" title="0.5px细线"></a>0.5px细线</h4><p>移动端 H5 项目越来越多，设计师对于 UI 的要求也越来越高，比如 1px 的边框。在高清屏下，移动端的 1px 会很粗。</p><p>那么为什么会产生这个问题呢？主要是跟一个东西有关，DPR(devicePixelRatio) 设备像素比，它是默认缩放为 100%的情况下，设备像素和 CSS 像素的比值。目前主流的屏幕 DPR=2（iPhone 8）,或者 3（iPhone 8 Plus）。拿 2 倍屏来说，设备的物理像素要实现 1 像素，而 DPR=2，所以 css 像素只能是 0.5。</p><p>下面介绍最常用的方法</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 底边框 */</span></span><br><span class="line"><span class="selector-class">.b-border</span> {</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.b-border</span><span class="selector-pseudo">:before</span> {</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#d9d9d9</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">-webkit-transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 上边框 */</span></span><br><span class="line"><span class="selector-class">.t-border</span> {</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.t-border</span><span class="selector-pseudo">:before</span> {</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#d9d9d9</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">-webkit-transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 右边框 */</span></span><br><span class="line"><span class="selector-class">.r-border</span> {</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.r-border</span><span class="selector-pseudo">:before</span> {</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#d9d9d9</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">scaleX</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">-webkit-transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 左边框 */</span></span><br><span class="line"><span class="selector-class">.l-border</span> {</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.l-border</span><span class="selector-pseudo">:before</span> {</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#d9d9d9</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">scaleX</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">-webkit-transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 四条边 */</span></span><br><span class="line"><span class="selector-class">.setBorderAll</span> {</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  &amp;:after {</span><br><span class="line">    content: ' ';</span><br><span class="line">    <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">    <span class="selector-tag">top</span>: 0;</span><br><span class="line">    <span class="selector-tag">left</span>: 0;</span><br><span class="line">    <span class="selector-tag">width</span>: 200%;</span><br><span class="line">    <span class="selector-tag">height</span>: 200%;</span><br><span class="line">    <span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0.5);</span><br><span class="line">    <span class="selector-tag">transform-origin</span>: <span class="selector-tag">left</span> <span class="selector-tag">top</span>;</span><br><span class="line">    <span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>;</span><br><span class="line">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#e5e5e5</span>;</span><br><span class="line">    <span class="selector-tag">border-radius</span>: 4<span class="selector-tag">px</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="屏蔽用户选择"><a href="#屏蔽用户选择" class="headerlink" title="屏蔽用户选择"></a>屏蔽用户选择</h4><p>禁止用户选择页面中的文字或者图片</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> {</span><br><span class="line">  <span class="attribute">-webkit-touch-callout</span>: none;</span><br><span class="line">  <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-khtml-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-moz-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-ms-user-select</span>: none;</span><br><span class="line">  <span class="attribute">user-select</span>: none;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="清除输入框内阴影"><a href="#清除输入框内阴影" class="headerlink" title="清除输入框内阴影"></a>清除输入框内阴影</h4><p>在 iOS 上，输入框默认有内部阴影,以这样关闭：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> {</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="如何禁止保存或拷贝图像"><a href="#如何禁止保存或拷贝图像" class="headerlink" title="如何禁止保存或拷贝图像"></a>如何禁止保存或拷贝图像</h4><p>代码如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> {</span><br><span class="line">  <span class="attribute">-webkit-touch-callout</span>: none;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="输入框默认字体颜色"><a href="#输入框默认字体颜色" class="headerlink" title="输入框默认字体颜色"></a>输入框默认字体颜色</h4><p>设置 input 里面 placeholder 字体的颜色</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::-webkit-input-placeholder</span>,</span><br><span class="line"><span class="selector-tag">textarea</span><span class="selector-pseudo">::-webkit-input-placeholder</span> {</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c7c7c7</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:-moz-placeholder</span>,</span><br><span class="line"><span class="selector-tag">textarea</span><span class="selector-pseudo">:-moz-placeholder</span> {</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c7c7c7</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:-ms-input-placeholder</span>,</span><br><span class="line"><span class="selector-tag">textarea</span><span class="selector-pseudo">:-ms-input-placeholder</span> {</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c7c7c7</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="用户设置字号放大或者缩小导致页面布局错误"><a href="#用户设置字号放大或者缩小导致页面布局错误" class="headerlink" title="用户设置字号放大或者缩小导致页面布局错误"></a>用户设置字号放大或者缩小导致页面布局错误</h4><p>设置字体禁止缩放</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {</span><br><span class="line">  <span class="attribute">-webkit-text-size-adjust</span>: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">text-size-adjust</span>: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">-moz-text-size-adjust</span>: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="android系统中元素被点击时产生边框"><a href="#android系统中元素被点击时产生边框" class="headerlink" title="android系统中元素被点击时产生边框"></a>android系统中元素被点击时产生边框</h4><p>部分android系统点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样。去除代码如下</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>{</span><br><span class="line">  <span class="attribute">-webkit-tap-highlight-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">  -webkit-user-modify:read-write-plaintext-only; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="iOS-滑动不流畅"><a href="#iOS-滑动不流畅" class="headerlink" title="iOS 滑动不流畅"></a>iOS 滑动不流畅</h4><p>ios 手机上下滑动页面会产生卡顿，手指离开页面，页面立即停止运动。整体表现就是滑动不流畅，没有滑动惯性。<br>iOS 5.0 以及之后的版本，滑动有定义有两个值 auto 和 touch，默认值为 auto。</p><p><strong>解决方案</strong></p><ol><li>在滚动容器上增加滚动 touch 方法</li></ol><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> {</span><br><span class="line">  <span class="attribute">-webkit-overflow-scrolling</span>: touch;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>设置 overflow<br>设置外部 overflow 为 hidden,设置内容元素 overflow 为 auto。内部元素超出 body 即产生滚动，超出的部分 body 隐藏。</li></ol><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {</span><br><span class="line">  <span class="attribute">overflow-y</span>: hidden;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.wrapper</span> {</span><br><span class="line">  <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="js-篇"><a href="#js-篇" class="headerlink" title="js 篇"></a>js 篇</h3><h4 id="移动端click屏幕产生200-300-ms的延迟响应"><a href="#移动端click屏幕产生200-300-ms的延迟响应" class="headerlink" title="移动端click屏幕产生200-300 ms的延迟响应"></a>移动端click屏幕产生200-300 ms的延迟响应</h4><p>移动设备上的web网页是有300ms延迟的，往往会造成按钮点击延迟甚至是点击失效。解决方案：</p><ul><li>fastclick可以解决在手机上点击事件的300ms延迟</li><li>zepto的touch模块，tap事件也是为了解决在click的延迟问题</li></ul><p>触摸事件的响应顺序</p><ol><li>ontouchstart </li><li>ontouchmove </li><li>ontouchend </li><li>onclick</li></ol><h4 id="audio-和-video-在-ios-和-andriod-中自动播放"><a href="#audio-和-video-在-ios-和-andriod-中自动播放" class="headerlink" title="audio 和 video 在 ios 和 andriod 中自动播放"></a>audio 和 video 在 ios 和 andriod 中自动播放</h4><p>这个不是bug，由于自动播放网页中的音频或视频，会给用户带来一些困扰或者不必要的流量消耗，所以苹果系统和安卓系统通常都会禁止自动播放和使用 JS 的触发播放，必须由用户来触发才可以播放。加入自动触发播放的代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'html'</span>).one(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  audio.play()</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="iOS-上拉边界下拉出现空白"><a href="#iOS-上拉边界下拉出现空白" class="headerlink" title="iOS 上拉边界下拉出现空白"></a>iOS 上拉边界下拉出现空白</h4><p>手指按住屏幕下拉，屏幕顶部会多出一块白色区域。手指按住屏幕上拉，底部多出一块白色区域。</p><p>在 iOS 中，手指按住屏幕上下拖动，会触发 touchmove 事件。这个事件触发的对象是整个 webview 容器，容器自然会被拖动，剩下的部分会成空白。</p><p><strong>解决方案</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(</span><br><span class="line">  <span class="string">'touchmove'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (e._isScroller) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 阻止默认事件</span></span><br><span class="line">    e.preventDefault()</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    passive: <span class="literal">false</span></span><br><span class="line">  }</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><h4 id="ios-日期转换-NAN-的问题"><a href="#ios-日期转换-NAN-的问题" class="headerlink" title="ios 日期转换 NAN 的问题"></a>ios 日期转换 NAN 的问题</h4><p>将日期字符串的格式符号替换成’/‘</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'yyyy-MM-dd'</span>.replace(<span class="regexp">/-/g</span>, <span class="string">'/'</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="软键盘问题"><a href="#软键盘问题" class="headerlink" title="软键盘问题"></a>软键盘问题</h3><h4 id="IOS-键盘弹起挡住原来的视图"><a href="#IOS-键盘弹起挡住原来的视图" class="headerlink" title="IOS 键盘弹起挡住原来的视图"></a>IOS 键盘弹起挡住原来的视图</h4><ul><li>可以通过监听移动端软键盘弹起<br>Element.scrollIntoViewIfNeeded（Boolean）方法用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。 如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。</li><li>true，则元素将在其所在滚动区的可视区域中居中对齐。</li><li>false，则元素将与其所在滚动区的可视区域最近的边缘对齐。 根据可见区域最靠近元素的哪个边缘，元素的顶部将与可见区域的顶部边缘对准，或者元素的底部边缘将与可见区域的底部边缘对准。</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="built_in">document</span>.activeElement.tagName === <span class="string">'INPUT'</span> ||</span><br><span class="line">    <span class="built_in">document</span>.activeElement.tagName === <span class="string">'TEXTAREA'</span></span><br><span class="line">  ) {</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">'scrollIntoView'</span> <span class="keyword">in</span> <span class="built_in">document</span>.activeElement) {</span><br><span class="line">        <span class="built_in">document</span>.activeElement.scrollIntoView(<span class="literal">false</span>)</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">document</span>.activeElement.scrollIntoViewIfNeeded(<span class="literal">false</span>)</span><br><span class="line">      }</span><br><span class="line">    }, <span class="number">0</span>)</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="onkeyUp-和-onKeydown-兼容性问题"><a href="#onkeyUp-和-onKeydown-兼容性问题" class="headerlink" title="onkeyUp 和 onKeydown 兼容性问题"></a>onkeyUp 和 onKeydown 兼容性问题</h4><p>IOS 中 input 键盘事件 keyup、keydown、等支持不是很好, 用 input 监听键盘 keyup 事件，在安卓手机浏览器中没有问题，但是在 ios 手机浏览器中用输入法输入之后，并未立刻相应 keyup 事件</p><h4 id="IOS12-输入框难以点击获取焦点，弹不出软键盘"><a href="#IOS12-输入框难以点击获取焦点，弹不出软键盘" class="headerlink" title="IOS12 输入框难以点击获取焦点，弹不出软键盘"></a>IOS12 输入框难以点击获取焦点，弹不出软键盘</h4><p>定位找到问题是 fastclick.js 对 IOS12 的兼容性，可在 fastclick.js 源码或者 main.js 做以下修改</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FastClick.prototype.focus = <span class="function"><span class="keyword">function</span>(<span class="params">targetElement</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> length</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    deviceIsIOS &amp;&amp;</span><br><span class="line">    targetElement.setSelectionRange &amp;&amp;</span><br><span class="line">    targetElement.type.indexOf(<span class="string">'date'</span>) !== <span class="number">0</span> &amp;&amp;</span><br><span class="line">    targetElement.type !== <span class="string">'time'</span> &amp;&amp;</span><br><span class="line">    targetElement.type !== <span class="string">'month'</span></span><br><span class="line">  ) {</span><br><span class="line">    length = targetElement.value.length</span><br><span class="line">    targetElement.setSelectionRange(length, length)</span><br><span class="line">    targetElement.focus()</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    targetElement.focus()</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="IOS-键盘收起时页面没用回落，底部会留白"><a href="#IOS-键盘收起时页面没用回落，底部会留白" class="headerlink" title="IOS 键盘收起时页面没用回落，底部会留白"></a>IOS 键盘收起时页面没用回落，底部会留白</h4><p>通过监听键盘回落时间滚动到原来的位置</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'focusout'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">//input输入框弹起软键盘的解决方案。</span></span><br><span class="line"><span class="keyword">var</span> bfscrolltop = <span class="built_in">document</span>.body.scrollTop</span><br><span class="line">$(<span class="string">'input'</span>)</span><br><span class="line">  .focus(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">document</span>.body.scrollTop = <span class="built_in">document</span>.body.scrollHeight</span><br><span class="line">    <span class="comment">//console.log(document.body.scrollTop);</span></span><br><span class="line">  })</span><br><span class="line">  .blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">document</span>.body.scrollTop = bfscrolltop</span><br><span class="line">    <span class="comment">//console.log(document.body.scrollTop);</span></span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure><h4 id="IOS-下-fixed-失效的原因"><a href="#IOS-下-fixed-失效的原因" class="headerlink" title="IOS 下 fixed 失效的原因"></a>IOS 下 fixed 失效的原因</h4><p>软键盘唤起后，页面的 fixed 元素将失效，变成了 absolute，所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。不仅限于 type=text 的输入框，凡是软键盘（比如时间日期选择、select 选择等等）被唤起，都会遇到同样地问题。</p><p>解决方法: 不让页面滚动，而是让主体部分自己滚动,主体部分高度设为 100%，overflow:scroll</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'warper'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'main'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fix-bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.warper</span> {</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">  <span class="attribute">-webkit-overflow-scrolling</span>: touch; <span class="comment">/* 解决ios滑动不流畅问题 */</span></span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.fix-bottom</span> {</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E6%80%BB%E7%BB%93%E5%87%A0%E4%B8%AA%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E8%BD%AF%E9%94%AE%E7%9B%98%E7%9A%84%E5%A4%A7%E5%9D%91/"/>
      <url>2020/12/29/%E6%80%BB%E7%BB%93%E5%87%A0%E4%B8%AA%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E8%BD%AF%E9%94%AE%E7%9B%98%E7%9A%84%E5%A4%A7%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h3 id="1、部分机型软键盘弹起挡住原来的视图"><a href="#1、部分机型软键盘弹起挡住原来的视图" class="headerlink" title="1、部分机型软键盘弹起挡住原来的视图"></a>1、部分机型软键盘弹起挡住原来的视图</h3><p>解决方法：可以通过监听移动端软键盘弹起</p><p><code>Element.scrollIntoView()</code> 方法让当前的元素滚动到浏览器窗口的可视区域内。参数如下。</p><ul><li>true，表示元素的顶部与当前区域的可见部分的顶部对齐</li><li>false，表示元素的底部与当前区域的可见部分的尾部对齐  </li></ul><p><code>Element.scrollIntoViewIfNeeded()</code>方法也是用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。但如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。此方法是标准的<code>Element.scrollIntoView()</code>方法的专有变体。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.activeElement.tagName === <span class="string">'INPUT'</span> || <span class="built_in">document</span>.activeElement.tagName === <span class="string">'TEXTAREA'</span>) {</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">'scrollIntoView'</span> <span class="keyword">in</span> <span class="built_in">document</span>.activeElement) {</span><br><span class="line">        <span class="built_in">document</span>.activeElement.scrollIntoView(<span class="literal">false</span>)</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">document</span>.activeElement.scrollIntoViewIfNeeded(<span class="literal">false</span>)</span><br><span class="line">      }</span><br><span class="line">    }, <span class="number">0</span>)</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="2、ios-键盘收起时页面没有回落，底部会留白"><a href="#2、ios-键盘收起时页面没有回落，底部会留白" class="headerlink" title="2、ios 键盘收起时页面没有回落，底部会留白"></a>2、ios 键盘收起时页面没有回落，底部会留白</h3><p>部分苹果手机填写表单的时候的，输入内容后关闭软键盘，底部会留一块空白。这种情况可以通过监听键盘回落时间滚动到原来的位置。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'focusout'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">//input输入框弹起软键盘的解决方案。</span></span><br><span class="line"><span class="keyword">var</span> bfscrolltop = <span class="built_in">document</span>.body.scrollTop</span><br><span class="line">$(<span class="string">'input'</span>)</span><br><span class="line">  .focus(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">document</span>.body.scrollTop = <span class="built_in">document</span>.body.scrollHeight</span><br><span class="line">    <span class="comment">//console.log(document.body.scrollTop);</span></span><br><span class="line">  })</span><br><span class="line">  .blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">document</span>.body.scrollTop = bfscrolltop</span><br><span class="line">    <span class="comment">//console.log(document.body.scrollTop);</span></span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure><h3 id="3、onkeyUp-和-onKeydown-兼容性问题"><a href="#3、onkeyUp-和-onKeydown-兼容性问题" class="headerlink" title="3、onkeyUp 和 onKeydown 兼容性问题"></a>3、onkeyUp 和 onKeydown 兼容性问题</h3><p>部分 ios 机型 中 <code>input</code> 键盘事件 <code>keyup</code>、<code>keydown</code>、等支持不是很好, 用 <code>input</code> 监听键盘 <code>keyup</code> 事件，在安卓手机浏览器中没有问题，但是在 ios 手机浏览器中用输入法输入之后，并未立刻相应 <code>keyup</code> 事件</p><ul><li><code>onkeypress</code> 用户按下并放开任何字母数字键时发生。系统按钮（箭头键和功能键）无法得到识别。 </li><li><code>onkeyup</code> 用户放开任何先前按下的键盘键时发生。</li><li><code>onkeydown</code> 用户按下任何键盘键（包括系统按钮，如箭头键和功能键）时发生。</li></ul><h3 id="4、ios12-输入框难以点击获取焦点，弹不出软键盘"><a href="#4、ios12-输入框难以点击获取焦点，弹不出软键盘" class="headerlink" title="4、ios12 输入框难以点击获取焦点，弹不出软键盘"></a>4、ios12 输入框难以点击获取焦点，弹不出软键盘</h3><p>定位找到问题是 <code>fastclick.js</code> 对 <code>ios12</code> 的兼容性，可在 <code>fastclick.js</code> 源码或者 <code>main.js</code> 做以下修改</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FastClick.prototype.focus = <span class="function"><span class="keyword">function</span>(<span class="params">targetElement</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> length</span><br><span class="line">  <span class="keyword">if</span> (deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(<span class="string">'date'</span>) !== <span class="number">0</span> &amp;&amp; targetElement.type !== <span class="string">'time'</span> &amp;&amp; targetElement.type !== <span class="string">'month'</span>) {</span><br><span class="line">    length = targetElement.value.length</span><br><span class="line">    targetElement.setSelectionRange(length, length)</span><br><span class="line">    targetElement.focus()</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    targetElement.focus()</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5、fastclick-导致下拉框焦点冲突"><a href="#5、fastclick-导致下拉框焦点冲突" class="headerlink" title="5、fastclick 导致下拉框焦点冲突"></a>5、fastclick 导致下拉框焦点冲突</h3><p>移动端使用 <code>fastclick</code> 之后，在 ios 环境下，有几个连续的下拉框 第一个 <code>select</code> 框突然填充了第二个下拉框的内容。</p><p>根本原因是 <code>Fastclick</code> 导致 ios 下多个 <code>select</code> ，点击某一个，焦点不停变换的 bug。修改源码，在 onTouchStart 事件内判断设备是否为 ios，再判断当前 <code>nodeName</code> 是否为 <code>select</code>，如果是 <code>return false</code> 去阻止 <code>fastClick</code> 执行其他事件。 </p><p>github 源码地址：fastclick.js</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//line 391行</span></span><br><span class="line">FastClick.prototype.onTouchStart = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>{</span><br><span class="line">  <span class="comment">//在其方法中添加判断 符合ios select的时候 不返回事件</span></span><br><span class="line">  <span class="keyword">if</span> (deviceIsIOS &amp;&amp; <span class="built_in">this</span>.targetElement == <span class="string">'select'</span>) <span class="built_in">this</span>.targetElement = <span class="literal">null</span></span><br><span class="line">  event.preventDefault()</span><br><span class="line">}</span><br><span class="line"><span class="comment">//line521 或者讲源码中 有关touchEnd判断非ios或者非select的事件注释，</span></span><br><span class="line"><span class="keyword">if</span> (!deviceIsIOS || targetTagName !== <span class="string">'select'</span>) {</span><br><span class="line">  <span class="built_in">this</span>.targetElement = <span class="literal">null</span></span><br><span class="line">  event.preventDefault()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="6、ios-下-fixed-失效的原因"><a href="#6、ios-下-fixed-失效的原因" class="headerlink" title="6、ios 下 fixed 失效的原因"></a>6、ios 下 fixed 失效的原因</h3><p>软键盘唤起后，页面的 <code>fixed</code> 元素将失效，变成了 <code>absolute</code>，所以当页面超过一屏且滚动时，失效的 <code>fixed</code> 元素就会跟随滚动了。不仅限于 <code>type=text</code> 的输入框，凡是软键盘（比如时间日期选择、select 选择等等）被唤起，都会遇到同样地问题。</p><p>解决方法: 不让页面滚动，而是让主体部分自己滚动,主体部分高度设为 100%，<code>overflow:scroll</code></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'warper'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'main'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fix-bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.warper</span> {</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">  <span class="attribute">-webkit-overflow-scrolling</span>: touch; <span class="comment">/* 解决ios滑动不流畅问题 */</span></span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.fix-bottom</span> {</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="7、ios-键盘换行变为搜索"><a href="#7、ios-键盘换行变为搜索" class="headerlink" title="7、ios 键盘换行变为搜索"></a>7、ios 键盘换行变为搜索</h3><ol><li><code>input type="search"</code></li><li>input 外面套 form，必须要有 action，<code>action="javascript:return true"</code></li><li>表单提交阻止默认提交事件</li></ol><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"javascript:return true"</span> @<span class="attr">submit.prevent</span>=<span class="string">"formSubmit"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">placeholder</span>=<span class="string">"请输入诉求名称"</span> <span class="attr">id</span>=<span class="string">"search"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
      <url>2020/12/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h1><p>在类电商类项目，往往存在大量的图片，如 banner 广告图，菜单导航图，美团等商家列表头图等。图片众多以及图片体积过大往往会影响页面加载速度，造成不良的用户体验，所以进行图片懒加载优化势在必行。</p><h3 id="为什么要进行图片懒加载"><a href="#为什么要进行图片懒加载" class="headerlink" title="为什么要进行图片懒加载"></a>为什么要进行图片懒加载</h3><p>我们先来看一下页面启动时加载的图片信息。</p><img src="./img/2.png"><p>如图所示，这个页面启动时加载了几十张图片（甚至更多），而这些图片请求几乎是并发的，在 Chrome 浏览器，最多支持的并发请求次数是有限的，其他的请求会推入到队列中等待或者停滞不前，直到上轮请求完成后新的请求才会发出。所以相当一部分图片资源请求是需要排队等待时间的。</p><p>在上面可以看出，有部分图片达到几百 kB，设置 2M(这锅必须运营背，非得上传高清大图不可？)，直接导致了加载时间过长。</p><img src="./img/1.png"><p>针对以上情况，进行图片懒加载有以下优点：</p><ol><li>减少资源的加载，页面启动只加载首屏的图片，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。</li><li>防止并发加载的资源过多而阻塞 js 的加载，影响整个网站的启动。</li><li>能提升用户的体验，不妨设想下，用户打开页面的时候，如果页面上所有的图片都需要加载，由于图片数目较大，等待时间很长这就严重影响用户体验。</li></ol><h3 id="图片懒加载的原理"><a href="#图片懒加载的原理" class="headerlink" title="图片懒加载的原理"></a>图片懒加载的原理</h3><p>图片懒加载的原理主要是判断当前图片是否到了可视区域这一核心逻辑实现的</p><ol><li>拿到所有的图片 dome 。</li><li>遍历每个图片判断当前图片是否到了可视区范围内。</li><li>如果到了就设置图片的 src 属性。</li><li>绑定 window 的 <code>scroll</code> 事件，对其进行事件监听。</li></ol><p>我们先来看下页面结构</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Lazyload<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      img {</span><br><span class="line">        display: block;</span><br><span class="line">        margin-bottom: 50px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        width: 400px;</span><br><span class="line">      }</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/default.png"</span> <span class="attr">data-src</span>=<span class="string">"./img/1.jpg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/default.png"</span> <span class="attr">data-src</span>=<span class="string">"./img/2.jpg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/default.png"</span> <span class="attr">data-src</span>=<span class="string">"./img/3.jpg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/default.png"</span> <span class="attr">data-src</span>=<span class="string">"./img/4.jpg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/default.png"</span> <span class="attr">data-src</span>=<span class="string">"./img/5.jpg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/default.png"</span> <span class="attr">data-src</span>=<span class="string">"./img/6.jpg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/default.png"</span> <span class="attr">data-src</span>=<span class="string">"./img/7.jpg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/default.png"</span> <span class="attr">data-src</span>=<span class="string">"./img/8.jpg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/default.png"</span> <span class="attr">data-src</span>=<span class="string">"./img/9.jpg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/default.png"</span> <span class="attr">data-src</span>=<span class="string">"./img/10.jpg"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>先获取所有图片的 dom，通过 <code>document.body.clientHeight</code> 获取可视区高度，再使用 <code>element.getBoundingClientRect()</code> API 直接得到元素相对浏览的 top 值， 遍历每个图片判断当前图片是否到了可视区范围内。代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> viewHeight = <span class="built_in">document</span>.body.clientHeight <span class="comment">//获取可视区高度</span></span><br><span class="line">  <span class="keyword">let</span> imgs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'img[data-src]'</span>)</span><br><span class="line">  imgs.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">if</span> (item.dataset.src === <span class="string">''</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置</span></span><br><span class="line">    <span class="keyword">let</span> rect = item.getBoundingClientRect()</span><br><span class="line">    <span class="keyword">if</span> (rect.bottom &gt;= <span class="number">0</span> &amp;&amp; rect.top &lt; viewHeight) {</span><br><span class="line">      item.src = item.dataset.src</span><br><span class="line">      item.removeAttribute(<span class="string">'data-src'</span>)</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后给 window 绑定 <code>onscroll</code> 事件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, lazyload)</span><br></pre></td></tr></tbody></table></figure><p>主要就完成了一个图片懒加载的操作了。但是这样存在较大的性能问题，因为 <code>scroll</code> 事件会在很短的时间内触发很多次，严重影响页面性能，为了提高网页性能，我们需要一个节流函数来控制函数的多次触发，在一段时间内（如 200ms）只执行一次回调。</p><p>下面实现一个节流函数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line">  <span class="keyword">let</span> prevTime</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>{</span><br><span class="line">    <span class="keyword">const</span> currTime = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">const</span> context = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">if</span> (!prevTime) prevTime = currTime</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currTime - prevTime &gt; delay) {</span><br><span class="line">      prevTime = currTime</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">      prevTime = <span class="built_in">Date</span>.now()</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    }, delay)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后修改一下 <code>srcoll</code> 事件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, throttle(lazyload, <span class="number">200</span>))</span><br></pre></td></tr></tbody></table></figure><h3 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h3><p>通过上面例子的实现，我们要实现懒加载都需要去监听 <code>scroll</code> 事件，尽管我们可以通过函数节流的方式来阻止高频率的执行函数，但是我们还是需要去计算 <code>scrollTop</code>，<code>offsetHeight</code> 等属性，有没有简单的不需要计算这些属性的方式呢，答案就是 <code>IntersectionObserver</code>。</p><p><code>IntersectionObserver</code> 是一个新的 API，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。我们来看一下它的用法：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(callback, option)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始观察</span></span><br><span class="line">io.observe(<span class="built_in">document</span>.getElementById(<span class="string">'example'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止观察</span></span><br><span class="line">io.unobserve(element)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭观察器</span></span><br><span class="line">io.disconnect()</span><br></pre></td></tr></tbody></table></figure><p><code>IntersectionObserver</code> 是浏览器原生提供的构造函数，接受两个参数：callback 是可见性变化时的回调函数，option 是配置对象（该参数可选）。</p><p>目标元素的可见性变化时，就会调用观察器的回调函数 callback。callback 一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries</span>) =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(entries)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>callback 函数的参数<code>（entries）</code>是一个数组，每个成员都是一个 <code>IntersectionObserverEntry</code> 对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，<code>entries</code> 数组就会有两个成员。</p><ul><li>time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</li><li>target：被观察的目标元素，是一个 DOM 节点对象</li><li>isIntersecting: 目标是否可见</li><li>rootBounds：根元素的矩形区域的信息，<code>getBoundingClientRect()</code>方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回 null</li><li>boundingClientRect：目标元素的矩形区域的信息</li><li>intersectionRect：目标元素与视口（或根元素）的交叉区域的信息</li><li>intersectionRatio：目标元素的可见比例，即 <code>intersectionRect</code> 占 <code>boundingClientRect</code> 的比例，完全可见时为 1，完全不可见时小于等于 0</li></ul><p>下面我们用 <code>IntersectionObserver</code> 实现图片懒加载</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imgs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'img[data-src]'</span>)</span><br><span class="line"><span class="keyword">const</span> config = {</span><br><span class="line">  rootMargin: <span class="string">'0px'</span>,</span><br><span class="line">  threshold: <span class="number">0</span>,</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries, self</span>) =&gt;</span> {</span><br><span class="line">  entries.forEach(<span class="function">(<span class="params">entry</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">if</span> (entry.isIntersecting) {</span><br><span class="line">      <span class="keyword">let</span> img = entry.target</span><br><span class="line">      <span class="keyword">let</span> src = img.dataset.src</span><br><span class="line">      <span class="keyword">if</span> (src) {</span><br><span class="line">        img.src = src</span><br><span class="line">        img.removeAttribute(<span class="string">'data-src'</span>)</span><br><span class="line">      }</span><br><span class="line">      <span class="comment">// 解除观察</span></span><br><span class="line">      self.unobserve(entry.target)</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}, config)</span><br><span class="line"></span><br><span class="line">imgs.forEach(<span class="function">(<span class="params">image</span>) =&gt;</span> {</span><br><span class="line">  observer.observe(image)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="懒加载指令"><a href="#懒加载指令" class="headerlink" title="懒加载指令"></a>懒加载指令</h3><p>Vue 中除了平时常用的 <code>v-show</code>、<code>v-bind</code>、<code>v-for</code> 等指令外，还可以自定义指令。Vue 指令定义函数提供了几个钩子函数（可选）：</p><ul><li>bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作。</li><li>inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li><li>update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值。</li><li>componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。</li><li>unbind: 只调用一次， 指令与元素解绑时调用。</li></ul><p>实现一个懒加载指令的思路</p><ol><li>判断浏览器是否支持 <code>IntersectionObserver</code> API，如果支持就使用 <code>IntersectionObserver</code> 实现懒加载，否则则使用 <code>srcoll</code> 事件监听 + 节流的方法实现。</li><li>通过 <code>Vue.directive</code> 注册一个 <code>v-lazy</code> 的指令，暴露一个 <code>install()</code> 函数，供 Vue 调用。</li><li>在 <code>main.js</code> 里 use(指令) 即可调用。</li><li>将组件内 <code>&lt;img&gt;</code> 标签的 <code>src</code> 换成 <code>v-lazy</code> 即可实现图片懒加载。</li></ol><p>代码如下</p><p>新建 <code>LazyLoad.js</code> 文件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LazyLoad = {</span><br><span class="line">  <span class="comment">// install方法</span></span><br><span class="line">  <span class="function"><span class="title">install</span>(<span class="params">Vue, options</span>)</span> {</span><br><span class="line">    <span class="keyword">const</span> defaultSrc = options.default</span><br><span class="line">    Vue.directive(<span class="string">'lazy'</span>, {</span><br><span class="line">      <span class="function"><span class="title">bind</span>(<span class="params">el, binding</span>)</span> {</span><br><span class="line">        LazyLoad.init(el, binding.value, defaultSrc)</span><br><span class="line">      },</span><br><span class="line">      <span class="function"><span class="title">inserted</span>(<span class="params">el</span>)</span> {</span><br><span class="line">        <span class="keyword">if</span> (IntersectionObserver) {</span><br><span class="line">          LazyLoad.observe(el)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          LazyLoad.listenerScroll(el)</span><br><span class="line">        }</span><br><span class="line">      },</span><br><span class="line">    })</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params">el, val, def</span>)</span> {</span><br><span class="line">    el.setAttribute(<span class="string">'data-src'</span>, val)</span><br><span class="line">    el.setAttribute(<span class="string">'src'</span>, def)</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 利用IntersectionObserver监听el</span></span><br><span class="line">  <span class="function"><span class="title">observe</span>(<span class="params">el</span>)</span> {</span><br><span class="line">    <span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries</span>) =&gt;</span> {</span><br><span class="line">      <span class="keyword">const</span> realSrc = el.dataset.src</span><br><span class="line">      <span class="keyword">if</span> (entries[<span class="number">0</span>].isIntersecting) {</span><br><span class="line">        <span class="keyword">if</span> (realSrc) {</span><br><span class="line">          el.src = realSrc</span><br><span class="line">          el.removeAttribute(<span class="string">'data-src'</span>)</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    })</span><br><span class="line">    io.observe(el)</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 监听scroll事件</span></span><br><span class="line">  <span class="function"><span class="title">listenerScroll</span>(<span class="params">el</span>)</span> {</span><br><span class="line">    <span class="keyword">const</span> handler = LazyLoad.throttle(LazyLoad.load, <span class="number">300</span>)</span><br><span class="line">    LazyLoad.load(el)</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, <span class="function">() =&gt;</span> {</span><br><span class="line">      handler(el)</span><br><span class="line">    })</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 加载真实图片</span></span><br><span class="line">  <span class="function"><span class="title">load</span>(<span class="params">el</span>)</span> {</span><br><span class="line">    <span class="keyword">const</span> windowHeight = <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">    <span class="keyword">const</span> elTop = el.getBoundingClientRect().top</span><br><span class="line">    <span class="keyword">const</span> elBtm = el.getBoundingClientRect().bottom</span><br><span class="line">    <span class="keyword">const</span> realSrc = el.dataset.src</span><br><span class="line">    <span class="keyword">if</span> (elTop - windowHeight &lt; <span class="number">0</span> &amp;&amp; elBtm &gt; <span class="number">0</span>) {</span><br><span class="line">      <span class="keyword">if</span> (realSrc) {</span><br><span class="line">        el.src = realSrc</span><br><span class="line">        el.removeAttribute(<span class="string">'data-src'</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  <span class="comment">// 节流</span></span><br><span class="line">  <span class="function"><span class="title">throttle</span>(<span class="params">fn, delay</span>)</span> {</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">let</span> prevTime</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>{</span><br><span class="line">      <span class="keyword">const</span> currTime = <span class="built_in">Date</span>.now()</span><br><span class="line">      <span class="keyword">const</span> context = <span class="built_in">this</span></span><br><span class="line">      <span class="keyword">if</span> (!prevTime) prevTime = currTime</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (currTime - prevTime &gt; delay) {</span><br><span class="line">        prevTime = currTime</span><br><span class="line">        fn.apply(context, args)</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        prevTime = <span class="built_in">Date</span>.now()</span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">        fn.apply(context, args)</span><br><span class="line">      }, delay)</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> LazyLoad</span><br></pre></td></tr></tbody></table></figure><p>在 <code>main.js</code> 里 use 指令</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> LazyLoad <span class="keyword">from</span> <span class="string">'./LazyLoad.js'</span></span><br><span class="line"></span><br><span class="line">Vue.use(LazyLoad, {</span><br><span class="line">  <span class="keyword">default</span>: <span class="string">'xxx.png'</span>,</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>将组件内 <code>&lt;img&gt;</code> 标签的 <code>src</code> 换成 <code>v-lazy</code></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-lazy</span>=<span class="string">"xxx.jpg"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这样就能完成一个 vue 懒加载的指令了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>为提高网站加载性能，图片懒加载是必要的。</li><li>图片懒加载是实现原理是判断当前图片是否到了可视区域进行加载，可通过监听 scroll 事件和 IntersectionObserver 实现相应的功能。</li><li>可通过 Vue.directive 编写图片懒加载指令。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>2020/12/29/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-开发规范及代码优化"><a href="#vue-开发规范及代码优化" class="headerlink" title="vue 开发规范及代码优化"></a>vue 开发规范及代码优化</h1><p>所谓无规矩不成方圆，前端时间在团队 <code>code-review</code> 中发现，不同时期不同开发人员写的代码可谓五花八门。因此我们提出了一些相关代码方面的规范，希望日后能形成团队的编码规范。</p><p>制定开发规范的目的</p><ul><li>统一编码风格，规范，提高团队协作效率</li><li>在团队协作中输出可读性强，易维护，风格一致的代码</li></ul><p>本文在gitthub做了收录：<a href="https://github.com/Michael-lzg/my--article/blob/master/other/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%8F%8A%E4%BC%98%E5%8C%96.md">https://github.com/Michael-lzg/my--article/blob/master/other/前端代码规范及优化.md</a></p><h2 id="HTML-篇"><a href="#HTML-篇" class="headerlink" title="HTML 篇"></a>HTML 篇</h2><h4 id="启用标准模式"><a href="#启用标准模式" class="headerlink" title="启用标准模式"></a>启用标准模式</h4><p>使用 HTML5 的 <code>doctype</code> 来启用标准模式</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="统一使用-UTF-8-编码"><a href="#统一使用-UTF-8-编码" class="headerlink" title="统一使用 UTF-8 编码"></a>统一使用 UTF-8 编码</h4><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="优先使用-IE-最新版本和-Chrome"><a href="#优先使用-IE-最新版本和-Chrome" class="headerlink" title="优先使用 IE 最新版本和 Chrome"></a>优先使用 IE 最新版本和 Chrome</h4><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="移动设备添加-viewport"><a href="#移动设备添加-viewport" class="headerlink" title="移动设备添加 viewport"></a>移动设备添加 viewport</h4><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="自闭合标签无需闭合"><a href="#自闭合标签无需闭合" class="headerlink" title="自闭合标签无需闭合"></a>自闭合标签无需闭合</h4><p>例如： <code>img</code>， <code>input</code>， <code>br</code>， <code>hr</code> 等</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://xxx.png"</span> <span class="attr">alt</span>=<span class="string">"Google"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"title"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="使用语义化标签"><a href="#使用语义化标签" class="headerlink" title="使用语义化标签"></a>使用语义化标签</h4><p>html 的标签能使用语义化的，尽量使用语义化标签，避免一个页面都是 div 或者 p 标签</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="属性顺序要求"><a href="#属性顺序要求" class="headerlink" title="属性顺序要求"></a>属性顺序要求</h4><p>HTML 属性应该按照特定的顺序出现以保证易读性。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">class</span><br><span class="line">name</span><br><span class="line">data-xxx</span><br><span class="line">src, for, type, href</span><br><span class="line">title, alt</span><br><span class="line">aria-xxx, role</span><br></pre></td></tr></tbody></table></figure><h2 id="CSS-篇"><a href="#CSS-篇" class="headerlink" title="CSS 篇"></a>CSS 篇</h2><h4 id="BEM-命名原则"><a href="#BEM-命名原则" class="headerlink" title="BEM 命名原则"></a>BEM 命名原则</h4><ul><li>block：模块，名字单词间用 - 连接</li><li>element：元素，模块的子元素，以 __ 与 block 连接</li><li>modifier：修饰，模块的变体，定义特殊模块，以 – 与 block 连接</li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 举个例子 */</span></span><br><span class="line"><span class="selector-class">.block__element</span> {</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.block--modifier</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="有效使用-css-选择器"><a href="#有效使用-css-选择器" class="headerlink" title="有效使用 css 选择器"></a>有效使用 css 选择器</h4><p>选择器嵌套应少于 3 级</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.page</span> <span class="selector-class">.header</span> <span class="selector-class">.login</span> <span class="selector-id">#username</span> <span class="selector-tag">input</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-id">#username</span> <span class="selector-tag">input</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有效使用 css 选择器，因遵循以下原则</p><ul><li>保持简单，不要使用嵌套过多过于复杂的选择器。</li><li>通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。</li><li>不要使用类选择器和 ID 选择器修饰元素标签。</li><li>不要为了追求速度而放弃可读性与可维护性</li><li>避免使用 CSS 表达式</li></ul><h4 id="慎重选择高消耗的样式"><a href="#慎重选择高消耗的样式" class="headerlink" title="慎重选择高消耗的样式"></a>慎重选择高消耗的样式</h4><p>高消耗属性在绘制前需要浏览器进行大量计算：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">box-shadows</span><br><span class="line">border-radius</span><br><span class="line">transparency</span><br><span class="line">transforms</span><br><span class="line">CSS filters（性能杀手）</span><br></pre></td></tr></tbody></table></figure><h4 id="避免重绘重排"><a href="#避免重绘重排" class="headerlink" title="避免重绘重排"></a>避免重绘重排</h4><p>当发生重排的时候，浏览器需要重新计算布局位置与大小，不利于性能优化。</p><p>常见引起重绘重排属性和方法</p><ul><li>添加或者删除可见的 <code>DOM</code> 元素；</li><li>元素尺寸改变——边距、填充、边框、宽度和高度</li><li>内容变化，比如用户在 <code>input</code> 框中输入文字</li><li>浏览器窗口尺寸改变——<code>resize</code> 事件发生时</li><li>计算 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性</li><li>设置 <code>style</code> 属性的值</li></ul><p>减少重绘重排的方法</p><ul><li>使用 <code>transform</code> 替代 <code>top</code></li><li>使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>不要把节点的属性值放在一个循环里当成循环里的变量。</li><li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li><li>CSS 选择符从右往左匹配查找，避免节点层级过多</li></ul><h2 id="Javascript-篇"><a href="#Javascript-篇" class="headerlink" title="Javascript 篇"></a>Javascript 篇</h2><h4 id="关于命名"><a href="#关于命名" class="headerlink" title="关于命名"></a>关于命名</h4><p>普通命名采用小驼峰式命名</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userName = <span class="string">'jack'</span></span><br></pre></td></tr></tbody></table></figure><p>命名是复数的时候需要加 s，比如说我想声明一个数组，表示很多人的名字</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br></pre></td></tr></tbody></table></figure><p>每个常量都需命名，这样更利于别人读懂含义</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> COL_NUM = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> row = <span class="built_in">Math</span>.ceil(num / COL_NUM)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> row = <span class="built_in">Math</span>.ceil(num / <span class="number">10</span>)</span><br></pre></td></tr></tbody></table></figure><p>命名需要符合语义化，如果函数命名，可以采用加上动词前缀：</p><ul><li>can 判断是否可执行某个动作</li><li>has 判断是否含有某个值</li><li>is 判断是否为某个值</li><li>get 获取某个值</li><li>set 设置某个值</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否可阅读</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canRead</span>(<span class="params"></span>)</span>{</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//获取姓名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span></span>{</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="关于字符串"><a href="#关于字符串" class="headerlink" title="关于字符串"></a>关于字符串</h4><p>统一使用单引号而不是双引号</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'jack'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'jack'</span></span><br></pre></td></tr></tbody></table></figure><p>用字符串模板而不是 ‘+’ 来拼接字符串</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'How are you, '</span> + name + <span class="string">'?'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`How are you, <span class="subst">${name}</span>?`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h4><p>用字面量赋值</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> items = []</span><br></pre></td></tr></tbody></table></figure><p>用扩展运算符做数组浅拷贝</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> len = arr.length</span><br><span class="line"><span class="keyword">const</span> copyArr = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">1</span>) {</span><br><span class="line">  copyArr[i] = arr[i]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> copyArr = [...arr]</span><br></pre></td></tr></tbody></table></figure><p>用 Array.from 去将一个类数组对象转成一个数组。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrLike = { <span class="number">0</span>: <span class="string">'foo'</span>, <span class="number">1</span>: <span class="string">'bar'</span>, <span class="number">2</span>: <span class="string">'baz'</span>, <span class="attr">length</span>: <span class="number">3</span> }</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrLike)</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Array</span>.from(arrLike)</span><br></pre></td></tr></tbody></table></figure><p>使用数组解构</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> first = arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> second = arr[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> [first, second] = arr</span><br></pre></td></tr></tbody></table></figure><h4 id="关于对象"><a href="#关于对象" class="headerlink" title="关于对象"></a>关于对象</h4><p>创建对象和数组推荐使用字面量，因为这不仅是性能最优也有助于节省代码量。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> obj = {</span><br><span class="line">  name: <span class="string">'Tom'</span>,</span><br><span class="line">  age: <span class="number">15</span>,</span><br><span class="line">  sex: <span class="string">'男'</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> obj = {}</span><br><span class="line">obj.name = <span class="string">'Tom'</span></span><br><span class="line">obj.age = <span class="number">15</span></span><br><span class="line">obj.sex = <span class="string">'男'</span></span><br></pre></td></tr></tbody></table></figure><p>ES6 使用属性值缩写</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lukeSkywalker = <span class="string">'Luke Skywalker'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> obj = {</span><br><span class="line">  lukeSkywalker: lukeSkywalker,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> obj = {</span><br><span class="line">  lukeSkywalker,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将属性的缩写放在对象声明的开头</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> anakinSkywalker = <span class="string">'Anakin Skywalker'</span></span><br><span class="line"><span class="keyword">const</span> lukeSkywalker = <span class="string">'Luke Skywalker'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> obj = {</span><br><span class="line">  episodeOne: <span class="number">1</span>,</span><br><span class="line">  twoJediWalkIntoACantina: <span class="number">2</span>,</span><br><span class="line">  lukeSkywalker,</span><br><span class="line">  episodeThree: <span class="number">3</span>,</span><br><span class="line">  mayTheFourth: <span class="number">4</span>,</span><br><span class="line">  anakinSkywalker,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> obj = {</span><br><span class="line">  lukeSkywalker,</span><br><span class="line">  anakinSkywalker,</span><br><span class="line">  episodeOne: <span class="number">1</span>,</span><br><span class="line">  twoJediWalkIntoACantina: <span class="number">2</span>,</span><br><span class="line">  episodeThree: <span class="number">3</span>,</span><br><span class="line">  mayTheFourth: <span class="number">4</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对象浅拷贝时，更推荐使用扩展运算符 …，而不是 Object.assign。解构赋值获取对象指定的几个属性时，推荐用 rest 运算符，也是 …。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// very bad</span></span><br><span class="line"><span class="keyword">const</span> original = { <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> }</span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(original, { <span class="attr">c</span>: <span class="number">3</span> })</span><br><span class="line"><span class="keyword">delete</span> copy.a <span class="comment">//  改变了 original</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> original = { <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> }</span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign({}, original, { <span class="attr">c</span>: <span class="number">3</span> }) <span class="comment">// copy =&gt; { a: 1, b: 2, c: 3 }</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> original = { <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> }</span><br><span class="line"><span class="keyword">const</span> copy = { ...original, <span class="attr">c</span>: <span class="number">3</span> } <span class="comment">// copy =&gt; { a: 1, b: 2, c: 3 }</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> { a, ...noA } = copy <span class="comment">// noA =&gt; { b: 2, c: 3 }</span></span><br></pre></td></tr></tbody></table></figure><h4 id="关于函数"><a href="#关于函数" class="headerlink" title="关于函数"></a>关于函数</h4><p>函数参数使用默认值替代使用条件语句进行赋值。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMicrobrewery</span>(<span class="params">name = <span class="string">'Jack'</span></span>) </span>{</span><br><span class="line">   ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMicrobrewery</span>(<span class="params">name</span>) </span>{</span><br><span class="line">  <span class="keyword">const</span> userNameName = name || <span class="string">'Jack'</span></span><br><span class="line">   ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>函数参数使用结构语法，函数参数越少越好，如果参数超过两个，要使用 ES6 的解构语法，不用考虑参数的顺序。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMenu</span>(<span class="params">{ title, body, buttonText, cancellable }</span>) </span>{</span><br><span class="line">   ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">createMenu({</span><br><span class="line">  title: <span class="string">'Foo'</span>,</span><br><span class="line">  body: <span class="string">'Bar'</span>,</span><br><span class="line">  buttonText: <span class="string">'Baz'</span>,</span><br><span class="line">  cancellable: <span class="literal">true</span>,</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMenu</span>(<span class="params">title, body, buttonText, cancellable</span>) </span>{</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>优先使用 rest 语法…，而不是 arguments</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> args.join(<span class="string">''</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params">...args</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> args.join(<span class="string">''</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>把默认参数赋值放在最后</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts = {}, name</span>) </span>{</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">name, opts = {}</span>) </span>{</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>尽量使用箭头函数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  .map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>{</span><br><span class="line">    <span class="keyword">const</span> y = x + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line">  })</span><br><span class="line"></span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// good</span></span><br><span class="line">    (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">  ].map(<span class="function">(<span class="params">x</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">const</span> y = x + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line">  })</span><br></pre></td></tr></tbody></table></figure><h4 id="关于模块"><a href="#关于模块" class="headerlink" title="关于模块"></a>关于模块</h4><p>在非标准模块系统上使用(import/export)</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> AirbnbStyleGuide = <span class="built_in">require</span>(<span class="string">'./AirbnbStyleGuide'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = AirbnbStyleGuide.es6</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">import</span> AirbnbStyleGuide <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> AirbnbStyleGuide.es6</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="keyword">import</span> { es6 } <span class="keyword">from</span> <span class="string">'./AirbnbStyleGuide'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6</span><br></pre></td></tr></tbody></table></figure><p>一个入口只 import 一次</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'foo'</span></span><br><span class="line"><span class="comment">// … some other imports … //</span></span><br><span class="line"><span class="keyword">import</span> { named1, named2 } <span class="keyword">from</span> <span class="string">'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> foo, { named1, named2 } <span class="keyword">from</span> <span class="string">'foo'</span></span><br></pre></td></tr></tbody></table></figure><p>在只有一个导出的模块里，用 export default 更好</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>{}</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>{</span><br></pre></td></tr></tbody></table></figure><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>使用 for 循环过程中，数组的长度，使用一个变量来接收，这样有利于代码执行效率得到提高，而不是每走一次循环，都得重新计算数组长度</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length,i++){</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length,i++){</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Vue-篇"><a href="#Vue-篇" class="headerlink" title="Vue 篇"></a>Vue 篇</h2><h4 id="Prop-定义尽量详细。"><a href="#Prop-定义尽量详细。" class="headerlink" title="Prop 定义尽量详细。"></a>Prop 定义尽量详细。</h4><p><code>prop</code> 的定义应该尽量详细，至少需要指定其类型。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">props: [<span class="string">'status'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">props: {</span><br><span class="line">  status: <span class="built_in">String</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line">props: {</span><br><span class="line">  status: {</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    required: <span class="literal">true</span>,</span><br><span class="line">    validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>{</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">'syncing'</span>,<span class="string">'synced'</span>,<span class="string">'version-conflict'</span>,<span class="string">'error'</span>].indexOf(value) !== -<span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="v-for-遍历必须添加-key"><a href="#v-for-遍历必须添加-key" class="headerlink" title="v-for 遍历必须添加 key"></a>v-for 遍历必须添加 key</h4><p>在列表数据进行遍历渲染时，需要为每一项 <code>item</code> 设置唯一 <code>key</code> 值，方便 Vue.js 内部机制精准找到该条列表数据。当 <code>state</code> 更新时，新的状态值和旧的状态值对比，较快地定位到 <code>diff</code> 。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span>{{ todo.text }}<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span> <span class="attr">:key</span>=<span class="string">"todo.id"</span>&gt;</span>{{ todo.text }}<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="v-if-和-v-for-不要用在同一个元素上。"><a href="#v-if-和-v-for-不要用在同一个元素上。" class="headerlink" title="v-if 和 v-for 不要用在同一个元素上。"></a>v-if 和 v-for 不要用在同一个元素上。</h4><p><code>v-for</code> 比 <code>v-if</code> 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"user in users"</span> <span class="attr">v-if</span>=<span class="string">"shouldShowUsers"</span> <span class="attr">:key</span>=<span class="string">"user.id"</span>&gt;</span>{{ user.name }}<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">"shouldShowUsers"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"user in users"</span> <span class="attr">:key</span>=<span class="string">"user.id"</span>&gt;</span>{{ user.name }}<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="组件的-data-必须是一个函数"><a href="#组件的-data-必须是一个函数" class="headerlink" title="组件的 data 必须是一个函数"></a>组件的 data 必须是一个函数</h4><p>JS 中的实例是通过构造函数来创建的，每个构造函数可以 new 出很多个实例，那么每个实例都会继承原型上的方法或属性。Vue 的 data 数据其实是 Vue 原型上的属性，数据存在于内存当中。</p><p>同一个组件被复用多次，会创建多个实例。这些实例用的是同一个构造函数，如果 data 是一个对象的话。那么所有组件都共享了同一个对象。为了保证组件的数据独立性，要求每个组件必须通过 data 函数返回一个对象作为组件的状态，这样每复用一次组件，就会返回一份新的 data。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">Vue.component(<span class="string">'some-comp'</span>, {</span><br><span class="line">  data: {</span><br><span class="line">    foo: <span class="string">'bar'</span>,</span><br><span class="line">  },</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">Vue.component(<span class="string">'some-comp'</span>, {</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      foo: <span class="string">'bar'</span>,</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="组件模板应该书写简洁"><a href="#组件模板应该书写简洁" class="headerlink" title="组件模板应该书写简洁"></a>组件模板应该书写简洁</h4><p>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">{{</span><br><span class="line">  fullName.split(<span class="string">' '</span>).map(<span class="function"><span class="keyword">function</span> (<span class="params">word</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> word[<span class="number">0</span>].toUpperCase() + word.slice(<span class="number">1</span>)</span><br><span class="line">  }).join(<span class="string">' '</span>)</span><br><span class="line">}}</span><br><span class="line"></span><br><span class="line"><span class="comment">//  good</span></span><br><span class="line"><span class="comment">//  在模板中</span></span><br><span class="line">{{ normalizedFullName }}</span><br><span class="line"><span class="comment">// 复杂表达式已经移入一个计算属性</span></span><br><span class="line">computed: {</span><br><span class="line">  normalizedFullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.fullName.split(<span class="string">' '</span>).map(<span class="function"><span class="keyword">function</span> (<span class="params">word</span>) </span>{</span><br><span class="line">      <span class="keyword">return</span> word[<span class="number">0</span>].toUpperCase() + word.slice(<span class="number">1</span>)</span><br><span class="line">    }).join(<span class="string">' '</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="指令缩写"><a href="#指令缩写" class="headerlink" title="指令缩写"></a>指令缩写</h4><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">"newTodoText"</span> <span class="attr">:placeholder</span>=<span class="string">"newTodoInstructions"</span> <span class="attr">v-on:input</span>=<span class="string">"onInput"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">"newTodoText"</span> <span class="attr">:placeholder</span>=<span class="string">"newTodoInstructions"</span> @<span class="attr">input</span>=<span class="string">"onInput"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="组件名为多个单词"><a href="#组件名为多个单词" class="headerlink" title="组件名为多个单词"></a>组件名为多个单词</h4><p>我们开发过程中自定义的组件的名称需要为多个单词，这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line">Vue.component(<span class="string">'todo-item'</span>, {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">})</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  name: <span class="string">'TodoItem'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">Vue.component(<span class="string">'todo'</span>, {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">  name: <span class="string">'Todo'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="多个属性进行分行"><a href="#多个属性进行分行" class="headerlink" title="多个属性进行分行"></a>多个属性进行分行</h4><p>在 JavaScript 中，用多行分隔对象的多个属性是很常见的最佳实践，因为这样更易读。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">foo</span>=<span class="string">"a"</span> <span class="attr">bar</span>=<span class="string">"b"</span> <span class="attr">baz</span>=<span class="string">"c"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">foo</span>=<span class="string">"a"</span> <span class="attr">bar</span>=<span class="string">"b"</span> <span class="attr">baz</span>=<span class="string">"c"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="元素特性的顺序"><a href="#元素特性的顺序" class="headerlink" title="元素特性的顺序"></a>元素特性的顺序</h4><p>原生属性放前面，指令其次，传参和方法放最后</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- class, id, ref</span><br><span class="line">- name, data-*, src, alt, for, type, href, value, max, min</span><br><span class="line">- title, placeholder, aria-*, role</span><br><span class="line">- required, readonly, disabled</span><br><span class="line">- v-model, v-for, key, v-if, v-show, v-bind,:</span><br><span class="line">- foo="a" bar="b" baz="c"</span><br></pre></td></tr></tbody></table></figure><h4 id="关于组件内样式"><a href="#关于组件内样式" class="headerlink" title="关于组件内样式"></a>关于组件内样式</h4><p>为组件样式设置作用域</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad  */</span></span><br><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-class">.btn-close</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">}</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good  */</span></span><br><span class="line">&lt;<span class="selector-tag">style</span> <span class="selector-tag">scoped</span>&gt;</span><br><span class="line"><span class="selector-class">.button-close</span> {</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">}</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br></pre></td></tr></tbody></table></figure><p>若要改变第三方组件库的样式，需要加上顶级作用域。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.ivu-input</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">254px</span> <span class="meta">!important</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.customerForm</span> <span class="selector-class">.ivu-input</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">254px</span> <span class="meta">!important</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* .customerForm为当前组件的顶级dom  */</span></span><br></pre></td></tr></tbody></table></figure><h4 id="关于组件结构"><a href="#关于组件结构" class="headerlink" title="关于组件结构"></a>关于组件结构</h4><p>组件结构遵循从上往下 template，script，style 的结构。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> {}</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span> <span class="attr">scoped</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>script 部分各方法成员遵循以下顺序放置。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- name</span><br><span class="line">- components</span><br><span class="line">- props</span><br><span class="line">- data</span><br><span class="line">- methods</span><br><span class="line">- computed</span><br><span class="line">- watch</span><br><span class="line">- created</span><br><span class="line">- mounted</span><br><span class="line">- update</span><br></pre></td></tr></tbody></table></figure><h4 id="清除定时器或者事件监听"><a href="#清除定时器或者事件监听" class="headerlink" title="清除定时器或者事件监听"></a>清除定时器或者事件监听</h4><p>由于项目中有些页面难免会碰到需要定时器或者事件监听。但是在离开当前页面的时候，定时器如果不及时合理地清除，会造成业务逻辑混乱甚至应用卡死的情况，这个时就需要清除定时器事件监听，即在页面卸载（关闭）的生命周期函数里，清除定时器。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">methods:{</span><br><span class="line">  resizeFun () {</span><br><span class="line">    <span class="built_in">this</span>.tableHeight = <span class="built_in">window</span>.innerHeight - <span class="built_in">document</span>.getElementById(<span class="string">'table'</span>).offsetTop - <span class="number">128</span></span><br><span class="line">  },</span><br><span class="line">  <span class="function"><span class="title">setTimer</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> { })</span><br><span class="line">  },</span><br><span class="line">  <span class="function"><span class="title">clearTimer</span>(<span class="params"></span>)</span> {</span><br><span class="line"><span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer)</span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="literal">null</span></span><br><span class="line">}</span><br><span class="line">},</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">this</span>.setTimer()</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="built_in">this</span>.resizeFun)</span><br><span class="line">},</span><br><span class="line"><span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, <span class="built_in">this</span>.resizeFun)</span><br><span class="line">  <span class="built_in">this</span>.clearTimer()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h4><p>Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  path: <span class="string">'/Home'</span>,</span><br><span class="line">  component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/Home.vue'</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="职责单一"><a href="#职责单一" class="headerlink" title="职责单一"></a>职责单一</h4><p>任何时候尽量是的一个函数就做一件事情，而不是将各种逻辑全部耦合在一起，提高单个函数的复用性和可读性。比如：每个页面都会在加载完成时进行数据的请求并展示到页面。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">methods: {</span><br><span class="line">  <span class="function"><span class="title">getList1</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="comment">// to do ...</span></span><br><span class="line">  },</span><br><span class="line">  <span class="function"><span class="title">getList2</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="comment">// to do ...</span></span><br><span class="line">  }</span><br><span class="line">},</span><br><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">this</span>.getList1()</span><br><span class="line">  <span class="built_in">this</span>.getList2()</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">methods: {</span><br><span class="line">  <span class="comment">// 将全部的请求行为聚合在init函数中</span></span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.getList1()</span><br><span class="line">    <span class="built_in">this</span>.getList2()</span><br><span class="line">  },</span><br><span class="line">  <span class="function"><span class="title">getList1</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="comment">// to do ...</span></span><br><span class="line">  },</span><br><span class="line">  <span class="function"><span class="title">getList2</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="comment">// to do ...</span></span><br><span class="line">  }</span><br><span class="line">},</span><br><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">this</span>.init();</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><h4 id="第三方-UI-组件按需引入"><a href="#第三方-UI-组件按需引入" class="headerlink" title="第三方 UI 组件按需引入"></a>第三方 UI 组件按需引入</h4><p>我们在项目中使用的第三方 UI 组件，如果我们直接引入整个组件库，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 vant 为例：</p><p>1、首先，安装 babel-plugin-component</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-component -D</span><br></pre></td></tr></tbody></table></figure><p>2、修改 .babelrc</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"import"</span>, {</span><br><span class="line">      <span class="string">"libraryName"</span>: <span class="string">"vant"</span>,</span><br><span class="line">      <span class="string">"libraryDirectory"</span>: <span class="string">"es"</span>,</span><br><span class="line">      <span class="string">"style"</span>: <span class="literal">true</span></span><br><span class="line">    }]</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3、引入部分组件：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> { Button } <span class="keyword">from</span> <span class="string">'vant'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Button)</span><br></pre></td></tr></tbody></table></figure><h2 id="图片篇："><a href="#图片篇：" class="headerlink" title="图片篇："></a>图片篇：</h2><h4 id="使用恰当的图片格式。"><a href="#使用恰当的图片格式。" class="headerlink" title="使用恰当的图片格式。"></a>使用恰当的图片格式。</h4><ul><li>jpg：适用于内容图片多为照片之类的。</li><li>png：适用于而饰图片，通常更适合用无损压缩。</li><li>gif： 基本上除了 gif 动画外不要使用。</li><li>webP：大大减小图片的体积，但是移动端有兼容性问题。</li></ul><h4 id="使用雪碧图"><a href="#使用雪碧图" class="headerlink" title="使用雪碧图"></a>使用雪碧图</h4><p>雪碧图，<code>CSS Sprites</code>，国内也叫 CSS 精灵，是一种 CSS 图像合成技术，主要用于小图片显示。</p><p>雪碧图的优点是把诸多小图片合成一张大图，利用<code>backround-position</code>属性值来确定图片呈现的位置，这样就能减少 http 请求，到达性能优化的效果。</p><h4 id="使用-iconfont"><a href="#使用-iconfont" class="headerlink" title="使用 iconfont"></a>使用 iconfont</h4><p><code>iconfont</code>(字体图标)，即通过字体的方式展示图标，多用于渲染图标、简单图形、特殊字体等。</p><p>使用 <code>iconfont</code> 时，由于只需要引入对应的字体文件即可，这种方法可有效减少 HTTP 请求次数，而且一般字体体积较小，所以请求传输数据量较少。与直接引入图片不同，<code>iconfont</code> 可以像使用字体一样，设置大小、颜色及其他样式，且不存在失真的情况。</p><h4 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h4><p>图片懒加载的原理就是暂时不设置图片的 <code>src</code> 属性，而是将图片的 <code>url</code> 隐藏起来，比如先写在 <code>data-src</code> 里面，等某些事件触发的时候(比如滚动到底部，点击加载图片)再将图片真实的 <code>url</code> 放进 <code>src</code> 属性里面，从而实现图片的延迟加载。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> images = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>)</span><br><span class="line">  <span class="keyword">var</span> len = images.length</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">0</span> <span class="comment">//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> seeHeight = <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = n; i &lt; len; i++) {</span><br><span class="line">      <span class="keyword">if</span> (images[i].getBoundingClientRect().top &lt; seeHeight) {</span><br><span class="line">        <span class="comment">//方法二: 当图片的视口top出现在视口中</span></span><br><span class="line">        <span class="keyword">if</span> (images[i].getAttribute(<span class="string">'src'</span>) === <span class="string">'images/default.jpg'</span>) {</span><br><span class="line">          images[i].src = images[i].getAttribute(<span class="string">'data-src'</span>)</span><br><span class="line">        }</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>vue 项目可以 <code>vue-lazyload</code> 插件实现图片懒加载</p><p><code>main.js</code> 中全局引入：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueLazyLoad <span class="keyword">from</span> <span class="string">'vue-lazyload'</span></span><br><span class="line">Vue.use(VueLazyLoad, {</span><br><span class="line">  preLoad: <span class="number">1</span>,</span><br><span class="line">  error: <span class="built_in">require</span>(<span class="string">'./assets/img/error.jpg'</span>),</span><br><span class="line">  loading: <span class="built_in">require</span>(<span class="string">'./assets/img/homePage_top.jpg'</span>),</span><br><span class="line">  attempt: <span class="number">2</span>,</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>页面中使用</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in imgList"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-lazy</span>=<span class="string">"item"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
      <url>2020/12/29/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="前端优化代码"><a href="#前端优化代码" class="headerlink" title="前端优化代码"></a>前端优化代码</h1><p>所谓无规矩不成方圆，前端时间在团队 code-review 中发现，不同时期不同开发人员写的代码可谓五花八门。因此我们提出了一些相关代码方面的规范，希望日后能形成团队的编码规范。</p><p>本文主要针对一些 JavaScript 进行优化，使之更加健壮，可读性更强，更以维护。gitthub地址：<a href="https://github.com/Michael-lzg/my--article/blob/master/other/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.md">https://github.com/Michael-lzg/my--article/blob/master/other/前端代码优化.md</a></p><p>上一篇：<a href="https://juejin.im/post/5f02c8eff265da22c058e050" target="blank">code-review之前端代码规范</a></p><h2 id="if-判断的优化"><a href="#if-判断的优化" class="headerlink" title="if 判断的优化"></a>if 判断的优化</h2><p>JavaScript 条件语句在我们平时的开发中是不可避免要用到的，但是很多时候我们的代码写的并不好，一连串的 <code>if-else</code> 或者多重嵌套判断都会使得代码很臃肿，下面举例进行优化。</p><p>需求：现在有 4 个产品，分别是手机、电脑、电视机、游戏机，当然每个产品显示的价格不一样。</p><p>1、最简单的方法：if 判断</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> commodity = {</span><br><span class="line">  phone: <span class="string">'手机'</span>,</span><br><span class="line">  computer: <span class="string">'电脑'</span>,</span><br><span class="line">  television: <span class="string">'电视'</span>,</span><br><span class="line">  gameBoy: <span class="string">'游戏机'</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">price</span>(<span class="params">name</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (name === commodity.phone) {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1999</span>)</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (name === commodity.computer) {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9999</span>)</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (name === commodity.television) {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2999</span>)</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (name === commodity.gameBoy) {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3999</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">price(<span class="string">'手机'</span>) <span class="comment">// 9999</span></span><br></pre></td></tr></tbody></table></figure><p>缺点：代码太长了,维护和阅读都很不友好</p><p>2、好一点的方法：<code>Switch</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> commodity = {</span><br><span class="line">  phone: <span class="string">'手机'</span>,</span><br><span class="line">  computer: <span class="string">'电脑'</span>,</span><br><span class="line">  television: <span class="string">'电视'</span>,</span><br><span class="line">  gameBoy: <span class="string">'游戏机'</span>,</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> price = <span class="function">(<span class="params">name</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">switch</span> (name) {</span><br><span class="line">    <span class="keyword">case</span> commodity.phone:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">1999</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> commodity.computer:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">9999</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> commodity.television:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">2999</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> commodity.gameBoy:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">3999</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">price(<span class="string">'手机'</span>) <span class="comment">// 9999</span></span><br></pre></td></tr></tbody></table></figure><p>3、更优的方法: 策略模式  </p><p>策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。它提供了对开放—封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，易于理解，易于扩展。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> commodity = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'phone'</span>, <span class="number">1999</span>],</span><br><span class="line">  [<span class="string">'computer'</span>, <span class="number">9999</span>],</span><br><span class="line">  [<span class="string">'television'</span>, <span class="number">2999</span>],</span><br><span class="line">  [<span class="string">'gameBoy'</span>, <span class="number">3999</span>],</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> price = <span class="function">(<span class="params">name</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> commodity.get(name)</span><br><span class="line">}</span><br><span class="line">price(<span class="string">'phone'</span>) <span class="comment">// 1999</span></span><br></pre></td></tr></tbody></table></figure><h2 id="includes-的优化"><a href="#includes-的优化" class="headerlink" title="includes 的优化"></a>includes 的优化</h2><p><code>includes</code> 是 ES7 新增的 API，与 <code>indexOf</code> 不同的是 <code>includes</code> 直接返回的是 <code>Boolean</code> 值，<code>indexOf</code> 则 返回的索引值, 数组和字符串都有 <code>includes</code> 方法。</p><p>需求：我们来实现一个身份认证方法，通过传入身份 Id 返回对应的验证结果</p><p>传统方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">verifyIdentity</span>(<span class="params">identityId</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (identityId == <span class="number">1</span> || identityId == <span class="number">2</span> || identityId == <span class="number">3</span> || identityId == <span class="number">4</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'你的身份合法，请通行！'</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'你的身份不合法'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>includes</code> 优化</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">verifyIdentity</span>(<span class="params">identityId</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].includes(identityId)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'你的身份合法，请通行！'</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'你的身份不合法'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>在 JavaScript 中，我们可以使用 <code>for()</code>， <code>while()</code>， <code>for(in)</code>，<code>for(in)</code>几种循环，事实上，这三种循环中 <code>for(in)</code> 的效率极差，因为他需要查询散列键，所以应该尽量少用。</p><p>for 循环是最传统的语句，它以变量 i 作为索引，以跟踪访问的位置，对数组进行操作。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]) <span class="comment">//结果依次a,b,c</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上的方法有一个问题：就是当数组的长度到达百万级时，<code>arr.length</code> 就要计算一百万次，这是相当耗性能的。所以可以采用以下方法就行改良。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = arr.length; i &lt; length; i++) {</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]) <span class="comment">//结果依次a,b,c</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时 <code>arr.length</code> 只需要计算一次，优化了性能。</p><p><code>for-in</code> 一般用来来遍历对象的属性的，不过属性需要 <code>enumerable</code>（可枚举）才能被读取到。同时 <code>for-in</code> 也可以遍历数组，遍历数组的时候遍历的是数组的下标值。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = { <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="number">2</span>: <span class="string">'c'</span> }</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) {</span><br><span class="line">  <span class="built_in">console</span>.log(key) <span class="comment">//结果为依次为0，1，2</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> a) {</span><br><span class="line">  <span class="built_in">console</span>.log(key) <span class="comment">//结果为依次为0，1，2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>for-of</code> 语句看着有点像 <code>for-in</code> 语句，但是和 <code>for-of</code> 语句不同的是它不可以循环对象，只能循环数组。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> arr) {</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">// 结果依次为a,b,c</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>for-of</code> 比 <code>for-in</code> 循环遍历数组更好。<code>for-of</code> 只要具有 <code>Iterator</code> 接口的数据结构，都可以使用它迭代成员。它直接读取的是键值。<code>for-in</code> 需要穷举对象的所有属性，包括自定义的添加的属性也能遍历到。且 <code>for-in</code> 的 <code>key</code> 是 <code>String</code> 类型，有转换过程，开销比较大。</p><p>所以在开发过程中循环数组尽量避免使用 <code>for-in</code>。</p><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>数组去重是实际开发处理数据中经常遇到的，方法有很多，这里就不一一例举了。</p><p>1、最传统的方法：利用数组的 <code>indexOf</code> 下标属性来查询。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique4</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">    <span class="keyword">if</span> (newArr.indexOf(arr[i]) === -<span class="number">1</span>) {</span><br><span class="line">      newArr.push(arr[i])</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(unique4([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]))</span><br><span class="line"><span class="comment">// [1, 2, 3, 5, 6, 7, 4]</span></span><br></pre></td></tr></tbody></table></figure><p>2、优化：利用 ES6 的 <code>Set</code> 方法。  </p><p><code>Set</code> 本身是一个构造函数，用来生成 <code>Set</code> 数据结构。<code>Set</code> 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。<code>Set</code> 对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique4</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)) <span class="comment">// 利用Array.from将Set结构转换成数组</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(unique4([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]))</span><br><span class="line"><span class="comment">// [1, 2, 3, 5, 6, 7, 4]</span></span><br></pre></td></tr></tbody></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数表达式的语法比函数表达式更简洁。所以在开发中更推荐使用箭头函数。特别是在 <code>vue</code> 项目中，使用箭头函数不需要在更 <code>this</code> 重新赋一个变量。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用functions</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">var</span> arrFunc = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> x * x</span><br><span class="line">})</span><br><span class="line"><span class="built_in">console</span>.log(arrFunc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">var</span> arrFunc = arr.map(<span class="function">(<span class="params">x</span>) =&gt;</span> x * x)</span><br></pre></td></tr></tbody></table></figure><p>要注意的是，箭头函数不绑定 <code>arguments</code>，取而代之用 <code>rest</code> 参数…解决。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能使用 arguments</span></span><br><span class="line"><span class="keyword">let</span> fun1 = <span class="function">(<span class="params">b</span>) =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">}</span><br><span class="line">fun1(<span class="number">2</span>, <span class="number">92</span>, <span class="number">32</span>, <span class="number">32</span>) <span class="comment">// Uncaught ReferenceError: arguments is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用rest 参数</span></span><br><span class="line"><span class="keyword">let</span> fun2 = <span class="function">(<span class="params">...c</span>) =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">}</span><br><span class="line">fun2(<span class="number">3</span>, <span class="number">82</span>, <span class="number">32</span>, <span class="number">11323</span>) <span class="comment">// [3, 82, 32, 11323]</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Dom-的创建"><a href="#Dom-的创建" class="headerlink" title="Dom 的创建"></a>Dom 的创建</h2><p>创建多个 dom 元素时，先将元素 <code>append</code> 到 <code>DocumentFragment</code> 中，最后统一将 <code>DocumentFragment</code> 添加到页面。</p><p>常规方法；</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">  <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>)</span><br><span class="line">  el.innerHTML = i</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(el)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用 <code>DocumentFragment</code> 优化多次 <code>append</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> frag = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">  <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>)</span><br><span class="line">  el.innerHTML = i</span><br><span class="line">  frag.appendChild(el)</span><br><span class="line">}</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(frag)</span><br></pre></td></tr></tbody></table></figure><p>更优的方法:使用一次 <code>innerHTML</code> 赋值代替构建 dom 元素</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">  html.push(<span class="string">'&lt;p&gt;'</span> + i + <span class="string">'&lt;/p&gt;'</span>)</span><br><span class="line">}</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = html.join(<span class="string">''</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>系统进程不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。当内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。  </p><p>引起内存泄漏的原因</p><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>1、未声明变量或者使用 <code>this</code> 创建的变量(<code>this</code> 的指向是 <code>window</code>)都会引起内存泄漏</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>{</span><br><span class="line">  a = <span class="string">"Actually, I'm a global variable"</span></span><br><span class="line">}</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="string">"Actually, I'm a global variable"</span></span><br><span class="line">}</span><br><span class="line">fn()</span><br></pre></td></tr></tbody></table></figure><p>解决方法：</p><ul><li>避免创建全局变量</li><li>使用严格模式,在 JavaScript 文件头部或者函数的顶部加上 <code>use strict</code>。</li></ul><p>2、在 vue 单页面应用，声明的全局变量在切换页面的时候没有清空</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"home"</span>&gt;</span><br><span class="line">    这里是首页</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> {</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> {</span><br><span class="line">      <span class="built_in">window</span>.test = {</span><br><span class="line">        <span class="comment">// 此处在全局window对象中引用了本页面的dom对象</span></span><br><span class="line">        name: <span class="string">'home'</span>,</span><br><span class="line">        node: <span class="built_in">document</span>.getElementById(<span class="string">'home'</span>)</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>解决方案: 在页面卸载的时候顺便处理掉该引用。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">destroyed () {</span><br><span class="line">  <span class="built_in">window</span>.test = <span class="literal">null</span> <span class="comment">// 页面卸载的时候解除引用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包引起的内存泄漏原因：闭包可以维持函数内局部变量，使其得不到释放。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">"I'm a"</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对 dom 的引用。</p><h4 id="定时器或事件监听"><a href="#定时器或事件监听" class="headerlink" title="定时器或事件监听"></a>定时器或事件监听</h4><p>由于项目中有些页面难免会碰到需要定时器或者事件监听。但是在离开当前页面的时候，定时器如果不及时合理地清除，会造成业务逻辑混乱甚至应用卡死的情况，这个时就需要清除定时器事件监听，即在页面卸载（关闭）的生命周期函数里，清除定时器。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">methods:{</span><br><span class="line">  resizeFun () {</span><br><span class="line">    <span class="built_in">this</span>.tableHeight = <span class="built_in">window</span>.innerHeight - <span class="built_in">document</span>.getElementById(<span class="string">'table'</span>).offsetTop - <span class="number">128</span></span><br><span class="line">  },</span><br><span class="line">  <span class="function"><span class="title">setTimer</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> { })</span><br><span class="line">  },</span><br><span class="line">  <span class="function"><span class="title">clearTimer</span>(<span class="params"></span>)</span> {<span class="comment">//清除定时器</span></span><br><span class="line"><span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer)</span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="literal">null</span></span><br><span class="line">}</span><br><span class="line">},</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">this</span>.setTimer()</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="built_in">this</span>.resizeFun)</span><br><span class="line">},</span><br><span class="line"><span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, <span class="built_in">this</span>.resizeFun)</span><br><span class="line">  <span class="built_in">this</span>.clearTimer()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h2><p>在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 <code>resize</code>、<code>scroll</code>、<code>mousemove</code> 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。这时候就用到防抖与节流。</p><p>案例 1：远程搜索时需要通过接口动态的获取数据，若是每次用户输入都接口请求，是浪费带宽和性能的。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Select</span> <span class="attr">:remote-method</span>=<span class="string">"remoteMethod"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Option</span> <span class="attr">v-for</span>=<span class="string">"item in temoteList"</span> <span class="attr">:value</span>=<span class="string">"item.value"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span>{{item.label}}<span class="tag">&lt;/<span class="name">Option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>{</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> timeout = <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (timeout !== <span class="literal">null</span>) <span class="built_in">clearTimeout</span>(timeout)</span></span><br><span class="line"><span class="javascript">    timeout = <span class="built_in">setTimeout</span>(fn, wait)</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> {</span></span><br><span class="line">  methods：{</span><br><span class="line"><span class="javascript">    remoteMethod：debounce(<span class="function"><span class="keyword">function</span> (<span class="params">query</span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="comment">// to do ...</span></span></span><br><span class="line">    }, 200),</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span></span><br></pre></td></tr></tbody></table></figure><p>案例 2：持续触发 <code>scroll</code> 事件时，并不立即执行 <code>handle</code> 函数，当 1000 毫秒内没有触发 <code>scroll</code> 事件时，才会延时触发一次 <code>handle</code> 函数。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (timeout !== <span class="literal">null</span>) <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(fn, wait)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random())</span><br><span class="line">}</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, debounce(handle, <span class="number">1000</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="异步加载-js"><a href="#异步加载-js" class="headerlink" title="异步加载 js"></a>异步加载 js</h2><p>默认情况下，浏览器是同步加载 js 脚本，解析 html 过程中，遇到 <code>&lt;script&gt;</code> 标签就会停下来，等脚本下载、解析、执行完后，再继续向下解析渲染。</p><p>如果 js 文件体积比较大，下载时间就会很长，容易造成浏览器堵塞，浏览器页面会呈现出“白屏”效果，用户会感觉浏览器“卡死了”，没有响应。此时，我们可以让 js 脚本异步加载、执行。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"path/to/home.js"</span> defer&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"path/to/home.js"</span> <span class="keyword">async</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，<code>&lt;script&gt;</code> 标签分别有 <code>defer</code> 和 <code>async</code> 属性，浏览器识别到这 2 个属性时 js 就会异步加载。也就是说，浏览器不会等待这个脚本下载、执行完毕后再向后执行，而是直接继续向后执行</p><p>defer 与 async 区别:</p><ul><li>defer：DOM 结构完全生成，以及其他脚本执行完成，才会执行（渲染完再执行）。有多个 <code>defer</code> 脚本时，会按照页面出现的顺序依次加载、执行。</li><li>async：一旦下载完成，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染（下载完就执行）。有多个 <code>async</code> 脚本时，不能保证按照页面出现顺序加载、执行</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/canvas%E5%9F%BA%E7%A1%80/"/>
      <url>2020/12/29/canvas%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h1><p>Canvas 是 HTML5 提供的一个用于展示绘图效果的标签. Canvas 原意为画布, 在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现。</p><p>canvas 的使用领域</p><ul><li>游戏</li><li>大数据可视化数据</li><li>banner 广告</li><li>多媒体</li><li>模拟仿真</li><li>远程操作</li><li>图形编辑</li></ul><p>判断浏览器是否支持 canvas 标签</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">if</span> (canvas.getContext) {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'你的浏览器支持Canvas!'</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'你的浏览器不支持Canvas!'</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="canvas-的基本用法"><a href="#canvas-的基本用法" class="headerlink" title="canvas 的基本用法"></a>canvas 的基本用法</h3><p>1、使用 canvas 标签, 即可在页面中开辟一格区域，可以设置其宽高，宽高为 300 和 150</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>2、获取 dom 元素 canvas</p><p>canvas 本身不能绘图. 是使用 JavaScript 来完成绘图. canvas 对象提供了各种绘图用的 api。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>)</span><br></pre></td></tr></tbody></table></figure><p>3、通过 cas 获取上下文对象(画布对象!)</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = cas.getContext(<span class="string">'2d'</span>)</span><br></pre></td></tr></tbody></table></figure><p>4、通过 ctx 开始画画（设置起点 设置终点 连线-描边 ）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.moveTo(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">ctx.lineTo(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">ctx.stroke()</span><br></pre></td></tr></tbody></table></figure><h3 id="绘制线条"><a href="#绘制线条" class="headerlink" title="绘制线条"></a>绘制线条</h3><ul><li>设置开始位置: context.moveTo( x, y ).</li><li>设置终点位置: context.lineTo( x, y ).</li><li>描边绘制: context.stroke().</li><li>填充绘制: context.fill().</li><li>闭合路径: context.closePath().</li></ul><p>canvas 还可以设置线条的相关属性，如下：</p><ul><li>CanvasRenderingContext2D.lineWidth 设置线宽.</li><li>CanvasRenderingContext2D.strokeStyle 设置线条颜色.</li><li>CanvasRenderingContext2D.lineCap 设置线末端类型，’butt’( 默认 ), ‘round’, ‘square’.</li><li>CanvasRenderingContext2D.lineJoin 设置相交线的拐点， ‘miter’(默认)，’round’, ‘bevel’,</li><li>CanvasRenderingContext2D.getLineDash() 获得线段样式数组.</li><li>CanvasRenderingContext2D.setLineDash() 设置线段样式.</li><li>CanvasRenderingContext2D.lineDashOffset 绘制线段偏移量.</li></ul><p>封装一个画矩形的方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myRect</span>(<span class="params">ctxTmp, x, y, w, h</span>) </span>{</span><br><span class="line">  ctxTmp.moveTo(x, y)</span><br><span class="line">  ctxTmp.lineTo(x + w, y)</span><br><span class="line">  ctxTmp.lineTo(x + w, y + h)</span><br><span class="line">  ctxTmp.lineTo(x, y + h)</span><br><span class="line">  ctxTmp.lineTo(x, y)</span><br><span class="line">  ctxTmp.stroke()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">var</span> ctx = cas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">myRect(ctx, <span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><ul><li>fillRect( x , y , width , height) 填充以(x,y)为起点宽高分别为 width、height 的矩形 默认为黑色</li><li>stokeRect( x , y , width , height) 绘制一个空心以(x,y)为起点宽高分别为 width、height 的矩形</li><li>clearRect( x, y , width , height ) 清除以(x,y)为起点宽高分别为 width、height 的矩形 为透明</li></ul><h3 id="绘制圆弧"><a href="#绘制圆弧" class="headerlink" title="绘制圆弧"></a>绘制圆弧</h3><p>绘制圆弧的方法有</p><ul><li>CanvasRenderingContext2D.arc()</li><li>CanvasRenderingContext2D.arcTo()</li></ul><p>6 个参数: x，y(圆心的坐标)，半径，起始的弧度(不是角度 deg)，结束的弧度，(bool 设置方向 ! )</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">var</span> ctx = cas.getContext(<span class="string">'2d'</span>)</span><br><span class="line"></span><br><span class="line">ctx.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">0</span>, degToArc(<span class="number">360</span>))</span><br><span class="line">ctx.stroke()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 角度转弧度</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">degToArc</span>(<span class="params">num</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">Math</span>.PI / <span class="number">180</span>) * num</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="绘制扇形"><a href="#绘制扇形" class="headerlink" title="绘制扇形"></a>绘制扇形</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">var</span> ctx = cas.getContext(<span class="string">'2d'</span>)</span><br><span class="line"></span><br><span class="line">ctx.arc(<span class="number">300</span>, <span class="number">300</span>, <span class="number">200</span>, degToArc(<span class="number">125</span>), degToArc(<span class="number">300</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动连回原点</span></span><br><span class="line">ctx.closePath()</span><br><span class="line">ctx.stroke()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">degToArc</span>(<span class="params">num</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">Math</span>.PI / <span class="number">180</span>) * num</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="制作画笔"><a href="#制作画笔" class="headerlink" title="制作画笔"></a>制作画笔</h3><ol><li>声明一个变量作为标识</li><li>鼠标按下的时候，记录起点位置</li><li>鼠标移动的时候，开始描绘并连线</li><li>鼠标抬起的时候，关闭开关</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">var</span> ctx = cas.getContext(<span class="string">'2d'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isDraw = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 鼠标按下事件</span></span><br><span class="line">cas.addEventListener(<span class="string">'mousedown'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  isDraw = <span class="literal">true</span></span><br><span class="line">  ctx.beginPath()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标移动事件</span></span><br><span class="line">cas.addEventListener(<span class="string">'mousemove'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (!isDraw) {</span><br><span class="line">    <span class="comment">// 没有按下</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 获取相对于容器内的坐标</span></span><br><span class="line">  <span class="keyword">var</span> x = e.offsetX</span><br><span class="line">  <span class="keyword">var</span> y = e.offsetY</span><br><span class="line">  ctx.lineTo(x, y)</span><br><span class="line">  ctx.stroke()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">cas.addEventListener(<span class="string">'mouseup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="comment">// 关闭开关了!</span></span><br><span class="line">  isDraw = <span class="literal">false</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="手动涂擦"><a href="#手动涂擦" class="headerlink" title="手动涂擦"></a>手动涂擦</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">var</span> ctx = cas.getContext(<span class="string">'2d'</span>)</span><br><span class="line"></span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">600</span>, <span class="number">600</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开关</span></span><br><span class="line"><span class="keyword">var</span> isClear = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">cas.addEventListener(<span class="string">'mousedown'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  isClear = <span class="literal">true</span></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">cas.addEventListener(<span class="string">'mousemove'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (!isClear) {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">var</span> x = e.offsetX</span><br><span class="line">  <span class="keyword">var</span> y = e.offsetY</span><br><span class="line">  <span class="keyword">var</span> w = <span class="number">20</span></span><br><span class="line">  <span class="keyword">var</span> h = <span class="number">20</span></span><br><span class="line">  ctx.clearRect(x, y, w, h)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">cas.addEventListener(<span class="string">'mouseup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  isClear = <span class="literal">false</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="刮刮乐"><a href="#刮刮乐" class="headerlink" title="刮刮乐"></a>刮刮乐</h3><ol><li>首先需要设置奖品和画布，将画布置于图片上方盖住，</li><li>随机设置生成奖品。</li><li>当手触摸移动的时候，可以擦除部分画布，露出奖品区。<br>html</li></ol><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./images/2.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">"600"</span> <span class="attr">height</span>=<span class="string">"600"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>css</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30%</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">canvas</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>js</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">var</span> ctx = cas.getContext(<span class="string">'2d'</span>)</span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.querySelector(<span class="string">'img'</span>)</span><br><span class="line"><span class="comment">// 加一个遮罩层</span></span><br><span class="line">ctx.fillStyle = <span class="string">'#ccc'</span></span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, cas.width, cas.height)</span><br><span class="line">setImgUrl()</span><br><span class="line"><span class="comment">// 开关</span></span><br><span class="line"><span class="keyword">var</span> isClear = <span class="literal">false</span></span><br><span class="line">cas.addEventListener(<span class="string">'mousedown'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  isClear = <span class="literal">true</span></span><br><span class="line">})</span><br><span class="line">cas.addEventListener(<span class="string">'mousemove'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (!isClear) {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">var</span> x = e.offsetX</span><br><span class="line">  <span class="keyword">var</span> y = e.offsetY</span><br><span class="line">  ctx.clearRect(x, y, <span class="number">30</span>, <span class="number">30</span>)</span><br><span class="line">})</span><br><span class="line">cas.addEventListener(<span class="string">'mouseup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  isClear = <span class="literal">false</span></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setImgUrl</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> arr = [<span class="string">'./images/1.jpg'</span>, <span class="string">'./images/2.jpg'</span>, <span class="string">'./images/3.jpg'</span>, <span class="string">'./images/4.jpg'</span>]</span><br><span class="line">  <span class="comment">// 0-3</span></span><br><span class="line">  <span class="keyword">var</span> random = <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * <span class="number">3</span>)</span><br><span class="line">  img.src = arr[random]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="在线画图"><a href="#在线画图" class="headerlink" title="在线画图"></a>在线画图</h3><p>drawImage() 方法在画布上绘制图像、画布或视频。drawImage() 方法也能够绘制图像的某些部分，以及/或者增加或减少图像的尺寸。参数如下</p><ul><li>img    规定要使用的图像、画布或视频。</li><li>sx    可选。开始剪切的 x 坐标位置。</li><li>sy    可选。开始剪切的 y 坐标位置。</li><li>swidth    可选。被剪切图像的宽度。</li><li>sheight    可选。被剪切图像的高度。</li><li>x    在画布上放置图像的 x 坐标位置。</li><li>y    在画布上放置图像的 y 坐标位置。</li><li>width    可选。要使用的图像的宽度。（伸展或缩小图像）</li><li>height    可选。要使用的图像的高度。（伸展或缩小图像）</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">var</span> ctx = cas.getContext(<span class="string">'2d'</span>)</span><br><span class="line"><span class="comment">// 先创建图片对象</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.src = <span class="string">'./images/1.jpg'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片加载完之后</span></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  ctx.drawImage(img, <span class="number">206</span>, <span class="number">111</span>, <span class="number">32</span>, <span class="number">38</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">32</span>, <span class="number">38</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/canvas%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"/>
      <url>2020/12/29/canvas%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="图片上传压缩"><a href="#图片上传压缩" class="headerlink" title="图片上传压缩"></a>图片上传压缩</h1><p>我们通常在做图片上传的时候都会遇上这样的情况，一是后端接口限制上传图片的大小，或者是即使后端没有限制大小，因为图片太大在前端渲染时太慢，造成页面加载体验较差。因此我们很有必要对上传的图片进行压缩。</p><p>本文主要包括以下流程：</p><ul><li>用户通过 <code>input</code> 框选择图片</li><li>使用 <code>FileReader</code> 进行图片预览</li><li>将图片绘制到 <code>canvas</code> 画布上</li><li>使用 <code>canvas</code> 画布的能力进行图片压缩</li><li>将压缩后的 <code>Base64(DataURL)</code> 格式的数据转换成 <code>Blob</code> 对象进行上传</li></ul><h3 id="Input-标签来获取图片"><a href="#Input-标签来获取图片" class="headerlink" title="Input 标签来获取图片"></a>Input 标签来获取图片</h3><p>通过设置 <code>input</code> 标签的 <code>type</code> 属性为 <code>file</code>，来让用户可以选择文件，设置 <code>accept</code> 限制选择的文件类型，绑定 <code>onchange</code> 事件，来获取确认选择后的文件</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"file"</span> accept=<span class="string">"image/*"</span> onchange=<span class="string">"loadFile(event)"</span></span><br></pre></td></tr></tbody></table></figure><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p><code>FileReader</code> 是什么，我们先来看看官方文档的介绍</p><blockquote><p>FileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。</p></blockquote><p><code>FileReader</code> 常用的两个方法如下：</p><ul><li><code>FileReader.onload</code>:处理 <code>load</code> 事件。即该钩子在读取操作完成时触发，通过该钩子函数可以完成例如读取完图片后进行预览的操作，或读取完图片后对图片内容进行二次处理等操作。</li><li><code>FileReader.readAsDataURL</code>：读取方法，并且读取完成后，<code>result</code> 属性将返回 <code>Data URL</code> 格式（Base64 编码）的字符串，代表图片内容。</li></ul><p>在图片上传中，我们可以通过 <code>readAsDataURL()</code> 方法进行了文件的读取，并且通过 <code>result</code> 属性拿到了图片的 <code>Base64(DataURL)</code> 格式的数据，然后通过该数据实现了图片预览的功能</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span> <span class="attr">onchange</span>=<span class="string">"loadFile(event)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> loadFile = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>{</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> file =  event.target.files[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader()</span></span><br><span class="line"><span class="javascript">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(reader.result)</span></span><br><span class="line">      ...</span><br><span class="line">    }</span><br><span class="line">    reader.readAsDataURL(file)</span><br><span class="line">  }</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="canvas-压缩图片"><a href="#canvas-压缩图片" class="headerlink" title="canvas 压缩图片"></a>canvas 压缩图片</h3><p>这是图片上传压缩的核心所在，我们先使用 <code>CanvasRenderingContext2D.drawImage()</code> 方法将上传的图片文件在画布上绘制出来，再使用 <code>Canvas.toDataURL()</code> 将画布上的图片信息转换成 <code>base64(DataURL)</code> 格式的数据。</p><p><code>drawImage()</code> 方法在画布上绘制图像、画布或视频。<code>drawImage()</code> 方法也能够绘制图像的某些部分，以及/或者增加或减少图像的尺寸。参数如下</p><ul><li>img 规定要使用的图像、画布或视频。</li><li>sx 可选。开始剪切的 x 坐标位置。</li><li>sy 可选。开始剪切的 y 坐标位置。</li><li>swidth 可选。被剪切图像的宽度。</li><li>sheight 可选。被剪切图像的高度。</li><li>x 在画布上放置图像的 x 坐标位置。</li><li>y 在画布上放置图像的 y 坐标位置。</li><li>width 可选。要使用的图像的宽度。（伸展或缩小图像）</li><li>height 可选。要使用的图像的高度。（伸展或缩小图像）</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cas = <span class="built_in">document</span>.querySelector(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">var</span> ctx = cas.getContext(<span class="string">'2d'</span>)</span><br><span class="line"><span class="comment">// 先创建图片对象</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.src = <span class="string">'./images/1.jpg'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片加载完之后</span></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  ctx.drawImage(img, <span class="number">206</span>, <span class="number">111</span>, <span class="number">32</span>, <span class="number">38</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">32</span>, <span class="number">38</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Canvas-toDataURl"><a href="#Canvas-toDataURl" class="headerlink" title="Canvas.toDataURl()"></a>Canvas.toDataURl()</h4><p><code>Canvas.toDataURl()</code> 方法可以将 <code>canvas</code> 画布上的信息转换为 <code>base64(DataURL)</code> 格式的图像信息，纯字符的图片表示形式。该方法接收 2 个参数：</p><ul><li><code>mimeType</code>(可选): 表示需要转换的图像的 <code>mimeType</code> 类型。默认值是 <code>image/png</code>，还可以是 <code>image/jpeg</code>， <code>image/webp</code> 等。</li><li><code>quailty</code>(可选)：quality 表示转换的图片质量。范围是 0 到 1。图片的 <code>mimeType</code> 需要是 <code>image/jpeg</code> 或者 <code>image/webp</code>，其他 <code>mimeType</code> 值无效。默认压缩质量是 0.92。</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line">canvas.toDataURL(<span class="string">"image/jpeg"</span> <span class="number">0.8</span>)</span><br></pre></td></tr></tbody></table></figure><p>到这里，我们先来上 canvas 压缩图片的代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compress</span>(<span class="params">base64, quality, mimeType</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line">  <span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">  img.crossOrigin = <span class="string">'anonymous'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    img.src = base64</span><br><span class="line">    img.onload = <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="keyword">let</span> targetWidth, targetHeight</span><br><span class="line">      <span class="keyword">if</span> (img.width &gt; MAX_WIDTH) {</span><br><span class="line">        targetWidth = MAX_WIDTH</span><br><span class="line">        targetHeight = (img.height * MAX_WIDTH) / img.width</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        targetWidth = img.width</span><br><span class="line">        targetHeight = img.height</span><br><span class="line">      }</span><br><span class="line">      canvas.width = targetWidth</span><br><span class="line">      canvas.height = targetHeight</span><br><span class="line">      <span class="keyword">let</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">      ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, targetWidth, targetHeight) <span class="comment">// 清除画布</span></span><br><span class="line">      ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height)</span><br><span class="line">      <span class="keyword">let</span> imageData = canvas.toDataURL(mimeType, quality / <span class="number">100</span>)</span><br><span class="line">      resolve(imageData)</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="将-base64-转化为文件"><a href="#将-base64-转化为文件" class="headerlink" title="将 base64 转化为文件"></a>将 base64 转化为文件</h3><ul><li>通过 <code>window.atob</code> 将 <code>base-64</code> 字符串解码为 <code>binaryString</code>（二进制文本）；</li><li>将 <code>binaryString</code> 构造为 <code>multipart/form-data</code> 格式；</li><li>用 <code>Uint8Array</code> 将 <code>multipart</code> 格式的二进制文本转换为 <code>ArrayBuffer</code>。</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataUrlToBlob</span>(<span class="params">base64, mimeType</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> bytes = <span class="built_in">window</span>.atob(base64.split(<span class="string">','</span>)[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">let</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(bytes.length)</span><br><span class="line">  <span class="keyword">let</span> ia = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(ab)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) {</span><br><span class="line">    ia[i] = bytes.charCodeAt(i)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Blob([ab], { <span class="attr">type</span>: mimeType })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="将图片上传到服务端"><a href="#将图片上传到服务端" class="headerlink" title="将图片上传到服务端"></a>将图片上传到服务端</h3><ul><li>创建一个 <code>FormData</code>，把 <code>blob</code> append 到 <code>FormData</code> 里面</li><li>请求服务端接口，提交图片</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadFile</span>(<span class="params">url, blob</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">  <span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  formData.append(<span class="string">'image'</span>, blob)</span><br><span class="line">  request.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>)</span><br><span class="line">  request.send(formData)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ps：在实际开发中，我们要不要把图片转化为 <code>FormData</code> 形式上传到服务端，这就看具体的业务需要了。我们可以上图片上传到腾讯云，直接返回一个<code>'https.xxx.jgp'</code>的图片 url 用于上传。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3ES6%E7%9A%84Set%E5%92%8CMap%E5%90%97/"/>
      <url>2020/12/29/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3ES6%E7%9A%84Set%E5%92%8CMap%E5%90%97/</url>
      
        <content type="html"><![CDATA[<h1 id="map-set"><a href="#map-set" class="headerlink" title="map/set"></a>map/set</h1><p>之前在学习 ES6 的时候，看到 <code>Set</code> 和 <code>Map</code>，不知道其应用场景有哪些，只觉得很多时候会用在数组去重和数据存储，后来慢慢才领悟到 <code>Set</code> 是一种叫做集合的数据结构，<code>Map</code> 是一种叫做字典的数据结构。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><code>Set</code> 本身是一个构造函数，用来生成 <code>Set</code> 数据结构。<code>Set</code> 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。<code>Set</code> 对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function">(<span class="params">x</span>) =&gt;</span> s.add(x))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) {</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Set-中的特殊值"><a href="#Set-中的特殊值" class="headerlink" title="Set 中的特殊值"></a>Set 中的特殊值</h4><p><code>Set</code> 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p><ul><li>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复</li><li><code>undefined</code> 与 <code>undefined</code> 是恒等的，所以不重复</li><li><code>NaN</code> 与 <code>NaN</code> 是不恒等的，但是在 <code>Set</code> 中认为 <code>NaN</code> 与 <code>NaN</code> 相等，所有只能存在一个，不重复。</li></ul><h4 id="Set-的属性："><a href="#Set-的属性：" class="headerlink" title="Set 的属性："></a>Set 的属性：</h4><ul><li><code>size</code>：返回集合所包含元素的数量</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">items.size <span class="comment">// 5</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Set-实例对象的方法"><a href="#Set-实例对象的方法" class="headerlink" title="Set 实例对象的方法"></a>Set 实例对象的方法</h4><ul><li><code>add(value)</code>：添加某个值，返回 <code>Set</code> 结构本身(可以链式调用)。</li><li><code>delete(value)</code>：删除某个值，删除成功返回 <code>true</code>，否则返回 <code>false</code>。</li><li><code>has(value)</code>：返回一个布尔值，表示该值是否为 <code>Set</code> 的成员。</li><li><code>clear()</code>：清除所有成员，没有返回值。</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line"></span><br><span class="line">s.size <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.has(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">3</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s.delete(<span class="number">2</span>)</span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h4><ul><li><code>keys()</code>：返回键名的遍历器。</li><li><code>values()</code>：返回键值的遍历器。</li><li><code>entries()</code>：返回键值对的遍历器。</li><li><code>forEach()</code>：使用回调函数遍历每个成员。</li></ul><p>由于 <code>Set</code> 结构没有键名，只有键值（或者说键名和键值是同一个值），所以 <code>keys</code> 方法和 <code>values</code> 方法的行为完全一致。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) {</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) {</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) {</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// ["red", "red"]</span></span><br><span class="line"><span class="comment">// ["green", "green"]</span></span><br><span class="line"><span class="comment">// ["blue", "blue"]</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Array-和-Set-对比"><a href="#Array-和-Set-对比" class="headerlink" title="Array 和 Set 对比"></a>Array 和 Set 对比</h4><ul><li><code>Array</code> 的 <code>indexOf</code> 方法比 <code>Set</code> 的 <code>has</code> 方法效率低下</li><li><code>Set</code> 不含有重复值（可以利用这个特性实现对一个数组的去重）</li><li><code>Set</code> 通过 <code>delete</code> 方法删除某个值，而 <code>Array</code> 只能通过 <code>splice</code>。两者的使用方便程度前者更优</li><li><code>Array</code> 的很多新方法 <code>map</code>、<code>filter</code>、<code>some</code>、<code>every</code> 等是 <code>Set</code> 没有的（但是通过两者可以互相转换来使用）</li></ul><h4 id="Set-的应用"><a href="#Set-的应用" class="headerlink" title="Set 的应用"></a>Set 的应用</h4><p>1、<code>Array.from</code> 方法可以将 <code>Set</code> 结构转为数组。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(items)</span><br></pre></td></tr></tbody></table></figure><p>2、数组去重</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">;[...new <span class="built_in">Set</span>(array)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array))</span><br></pre></td></tr></tbody></table></figure><p>3、数组的 <code>map</code> 和 <code>filter</code> 方法也可以间接用于 <code>Set</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">2</span>))</span><br><span class="line"><span class="comment">// 返回Set结构：{2, 4, 6}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> x % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line"><span class="comment">// 返回Set结构：{2, 4}</span></span><br></pre></td></tr></tbody></table></figure><p>4、实现并集 <code>(Union)</code>、交集 <code>(Intersect)</code> 和差集</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b])</span><br><span class="line"><span class="comment">// Set {1, 2, 3, 4}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> b.has(x)))</span><br><span class="line"><span class="comment">// set {2, 3}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> !b.has(x)))</span><br><span class="line"><span class="comment">// Set {1}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="weakSet"><a href="#weakSet" class="headerlink" title="weakSet"></a>weakSet</h3><p><code>WeakSet</code> 结构与 <code>Set</code> 类似，也是不重复的值的集合。</p><ul><li>成员都是数组和类似数组的对象，若调用 <code>add()</code> 方法时传入了非数组和类似数组的对象的参数，就会抛出错误。</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">WeakSet</span>(b) <span class="comment">// Uncaught TypeError: Invalid value used in weak set</span></span><br></pre></td></tr></tbody></table></figure><ul><li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏。</li><li><code>WeakSet</code> 不可迭代，因此不能被用在 <code>for-of</code> 等循环中。</li><li><code>WeakSet</code> 没有 <code>size</code> 属性。</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code> 中存储的是 <code>key-value</code> 形式的键值对, 其中的 <code>key</code> 和 <code>value</code> 可以是任何类型的, 即对象也可以作为 <code>key</code>。 <code>Map</code> 的出现，就是让各种类型的值都可以当作键。<code>Map</code> 提供的是 “值-值”的对应。</p><h4 id="Map-和-Object-的区别"><a href="#Map-和-Object-的区别" class="headerlink" title="Map 和 Object 的区别"></a>Map 和 Object 的区别</h4><ol><li><code>Object</code> 对象有原型， 也就是说他有默认的 <code>key</code> 值在对象上面， 除非我们使用 <code>Object.create(null)</code>创建一个没有原型的对象；</li><li>在 <code>Object</code> 对象中， 只能把 <code>String</code> 和 <code>Symbol</code> 作为 <code>key</code> 值， 但是在 <code>Map</code> 中，<code>key</code> 值可以是任何基本类型(<code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>undefined</code>, <code>NaN</code>….)，或者对象(<code>Map</code>, <code>Set</code>, <code>Object</code>, <code>Function</code> , <code>Symbol</code> , <code>null</code>….);</li><li>通过 <code>Map</code> 中的 <code>size</code> 属性， 可以很方便地获取到 <code>Map</code> 长度， 要获取 <code>Object</code> 的长度， 你只能手动计算</li></ol><h4 id="Map-的属性"><a href="#Map-的属性" class="headerlink" title="Map 的属性"></a>Map 的属性</h4><ul><li>size: 返回集合所包含元素的数量</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">'foo'</span>, ture)</span><br><span class="line">map.set(<span class="string">'bar'</span>, <span class="literal">false</span>)</span><br><span class="line">map.size <span class="comment">// 2</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Map-对象的方法"><a href="#Map-对象的方法" class="headerlink" title="Map 对象的方法"></a>Map 对象的方法</h4><ul><li><code>set(key, val)</code>: 向 <code>Map</code> 中添加新元素</li><li><code>get(key)</code>: 通过键值查找特定的数值并返回</li><li><code>has(key)</code>: 判断 <code>Map</code> 对象中是否有 <code>Key</code> 所对应的值，有返回 <code>true</code>，否则返回 <code>false</code></li><li><code>delete(key)</code>: 通过键值从 <code>Map</code> 中移除对应的数据</li><li><code>clear()</code>: 将这个 <code>Map</code> 中的所有元素删除</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">const</span> o = { <span class="attr">p</span>: <span class="string">'Hello World'</span> }</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">'content'</span>)</span><br><span class="line">m.get(o) <span class="comment">// "content"</span></span><br><span class="line"></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><h4 id="遍历方法-1"><a href="#遍历方法-1" class="headerlink" title="遍历方法"></a>遍历方法</h4><ul><li><code>keys()</code>：返回键名的遍历器</li><li><code>values()</code>：返回键值的遍历器</li><li><code>entries()</code>：返回键值对的遍历器</li><li><code>forEach()</code>：使用回调函数遍历每个成员</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'a'</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">'b'</span>, <span class="number">2</span>],</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) {</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// "a"</span></span><br><span class="line"><span class="comment">// "b"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) {</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) {</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// ["a", 1]</span></span><br><span class="line"><span class="comment">// ["b", 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) {</span><br><span class="line">  <span class="built_in">console</span>.log(key, value)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// "a" 1</span></span><br><span class="line"><span class="comment">// "b" 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of...遍历map等同于使用map.entries()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) {</span><br><span class="line">  <span class="built_in">console</span>.log(key, value)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// "a" 1</span></span><br><span class="line"><span class="comment">// "b" 2</span></span><br></pre></td></tr></tbody></table></figure><h4 id="数据类型转化"><a href="#数据类型转化" class="headerlink" title="数据类型转化"></a>数据类型转化</h4><p>Map 转为数组</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">let</span> arr = [...map]</span><br></pre></td></tr></tbody></table></figure><p>数组转为 Map</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>: map = <span class="keyword">new</span> <span class="built_in">Map</span>(arr)</span><br></pre></td></tr></tbody></table></figure><p>Map 转为对象</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = {}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> map) {</span><br><span class="line">  obj[k] = v</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对象转为 Map</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)）{</span><br><span class="line">  map.set(k,obj[k])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Map的应用"><a href="#Map的应用" class="headerlink" title="Map的应用"></a>Map的应用</h4><p>在一些 Admin 项目中我们通常都对个人信息进行展示，比如将如下信息展示到页面上。传统方法如下。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info-item"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>{{info.name}}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info-item"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>{{info.age}}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info-item"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>{{info.sex}}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info-item"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>手机号<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>{{info.phone}}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info-item"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>家庭住址<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>{{info.address}}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info-item"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>家庭住址<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>{{info.duty}}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>js 代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> {</span><br><span class="line">  <span class="built_in">this</span>.info = {</span><br><span class="line">    name: <span class="string">'jack'</span>,</span><br><span class="line">    sex: <span class="string">'男'</span>,</span><br><span class="line">    age: <span class="string">'28'</span>,</span><br><span class="line">    phone: <span class="string">'13888888888'</span>,</span><br><span class="line">    address: <span class="string">'广东省广州市'</span>,</span><br><span class="line">    duty: <span class="string">'总经理'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们通过 Map 来改造，将我们需要显示的 label 和 value 存到我们的 Map 后渲染到页面，这样减少了大量的html代码</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info-item"</span> <span class="attr">v-for</span>=<span class="string">"[label, value] in infoMap"</span> <span class="attr">:key</span>=<span class="string">"value"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>{{label}}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>{{value}}<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>js 代码</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">data: <span class="function">() =&gt;</span> ({</span><br><span class="line">  info: {},</span><br><span class="line">  infoMap: {}</span><br><span class="line">}),</span><br><span class="line">mounted () {</span><br><span class="line">  <span class="built_in">this</span>.info = {</span><br><span class="line">    name: <span class="string">'jack'</span>,</span><br><span class="line">    sex: <span class="string">'男'</span>,</span><br><span class="line">    age: <span class="string">'28'</span>,</span><br><span class="line">    phone: <span class="string">'13888888888'</span>,</span><br><span class="line">    address: <span class="string">'广东省广州市'</span>,</span><br><span class="line">    duty: <span class="string">'总经理'</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">const</span> mapKeys = [<span class="string">'姓名'</span>, <span class="string">'性别'</span>, <span class="string">'年龄'</span>, <span class="string">'电话'</span>, <span class="string">'家庭地址'</span>, <span class="string">'身份'</span>]</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">this</span>.info) {</span><br><span class="line">    result.set(mapKeys[i], <span class="built_in">this</span>.info[key])</span><br><span class="line">    i++</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">this</span>.infoMap = result</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p><code>WeakMap</code> 结构与 <code>Map</code> 结构类似，也是用于生成键值对的集合。</p><ul><li>只接受对象作为键名（<code>null</code> 除外），不接受其他类型的值作为键名</li><li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的</li><li>不能遍历，方法有 <code>get</code>、<code>set</code>、<code>has</code>、<code>delete</code></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Set</p><ul><li>是一种叫做集合的数据结构(ES6新增的)</li><li>成员唯一、无序且不重复</li><li><code>[value, value]</code>，键值与键名是一致的（或者说只有键值，没有键名）</li><li>允许储存任何类型的唯一值，无论是原始值或者是对象引用</li><li>可以遍历，方法有：<code>add</code>、<code>delete</code>、<code>has</code>、<code>clear</code></li></ul><p>WeakSet</p><ul><li>成员都是对象</li><li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 <code>DOM</code> 节点，不容易造成内存泄漏</li><li>不能遍历，方法有 <code>add</code>、<code>delete</code>、<code>has</code></li></ul><p>Map</p><ul><li>是一种类似于字典的数据结构，本质上是键值对的集合</li><li>可以遍历，可以跟各种数据格式转换</li><li>操作方法有:<code>set</code>、<code>get</code>、<code>has</code>、<code>delete</code>、<code>clear</code></li></ul><p>WeakMap</p><ul><li>只接受对象作为键名（<code>null</code> 除外），不接受其他类型的值作为键名</li><li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的</li><li>不能遍历，方法有 <code>get</code>、<code>set</code>、<code>has</code>、<code>delete</code></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
      <url>2020/12/29/this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h1><p>使用 JavaScript 开发的时候，很多开发者多多少少会被 this 的指向搞蒙圈，但是实际上，关于 this 的指向，记住最核心的一句话：<strong>哪个对象调用函数，函数里面的 this 指向哪个对象。</strong></p><h3 id="1、普通函数：谁调用指向谁"><a href="#1、普通函数：谁调用指向谁" class="headerlink" title="1、普通函数：谁调用指向谁"></a>1、普通函数：谁调用指向谁</h3><p>全局变量指向全局对象-window</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> username = <span class="string">'cn'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>{</span><br><span class="line">  alert(<span class="built_in">this</span>.username) <span class="comment">//cn</span></span><br><span class="line">}</span><br><span class="line">fu()</span><br></pre></td></tr></tbody></table></figure><p>有一点需要注意，let 声明的全局变量，不是指向 window 对象</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> username = <span class="string">'cn'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>{</span><br><span class="line">  alert(<span class="built_in">this</span>.username) <span class="comment">//undefined</span></span><br><span class="line">}</span><br><span class="line">fn()</span><br></pre></td></tr></tbody></table></figure><h3 id="2、对象函数调用"><a href="#2、对象函数调用" class="headerlink" title="2、对象函数调用"></a>2、对象函数调用</h3><p>就是那个函数调用，this 指向哪里</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.b = <span class="number">2222</span></span><br><span class="line"><span class="keyword">let</span> obj = {</span><br><span class="line">  a: <span class="number">111</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    alert(<span class="built_in">this</span>.a) <span class="comment">//111</span></span><br><span class="line">    alert(<span class="built_in">this</span>.b) <span class="comment">//undefined</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">obj.fn()</span><br></pre></td></tr></tbody></table></figure><h3 id="3-构造函数中调用"><a href="#3-构造函数中调用" class="headerlink" title="3.构造函数中调用"></a>3.构造函数中调用</h3><p>JS里的普通函数可以使用new操作符来创建一个对象，此时该函数就是一个构造函数，箭头函数不能作为构造函数。执行new操作符，其实JS内部完成了以下事情：</p><ol><li>创建一个空的简单JavaScript对象（即{}）；</li><li>将构造函数的prototype绑定为新对象的原型对象 ；</li><li>将步骤1新创建的对象作为this的上下文并执行函数 ；</li><li>如果该函数没有返回对象，则返回this。</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span></span><br><span class="line">  <span class="built_in">this</span>.func = <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> A()</span><br><span class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.func() === obj) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h3 id="4-箭头函数中调用"><a href="#4-箭头函数中调用" class="headerlink" title="4.箭头函数中调用"></a>4.箭头函数中调用</h3><p>箭头函数的this指向，和箭头函数定义所在上下文的this相同。对于普通函数，this在函数调用时才确定；而对于箭头函数，this在箭头函数定义时就已经确定了，并且不能再被修改。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = {</span><br><span class="line">  A () {</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  B () {</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = obj.A()</span><br><span class="line"><span class="built_in">console</span>.log(func() === obj) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">func = obj.B()</span><br><span class="line"><span class="built_in">console</span>.log(func() === obj) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(func() === <span class="built_in">window</span>) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h3 id="apply、call、bind"><a href="#apply、call、bind" class="headerlink" title="apply、call、bind"></a>apply、call、bind</h3><p>在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。<br>举个例子</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fruits</span>(<span class="params"></span>) </span>{}</span><br><span class="line"></span><br><span class="line">fruits.prototype = {</span><br><span class="line">  color: <span class="string">'red'</span>,</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'My color is '</span> + <span class="built_in">this</span>.color)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> fruits()</span><br><span class="line">apple.say() <span class="comment">//My color is red</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是如果我们有一个对象banana= {color : "yellow"} ,我们不想对它重新定义 say 方法，</span></span><br><span class="line"><span class="comment">//那么我们可以通过 call 或 apply 用 apple 的 say 方法：</span></span><br><span class="line">banana = {</span><br><span class="line">  color: <span class="string">'yellow'</span></span><br><span class="line">}</span><br><span class="line">apple.say.call(banana) <span class="comment">//My color is yellow</span></span><br><span class="line">apple.say.apply(banana) <span class="comment">//My color is yellow</span></span><br></pre></td></tr></tbody></table></figure><h4 id="apply、call-区别"><a href="#apply、call-区别" class="headerlink" title="apply、call 区别"></a>apply、call 区别</h4><p>对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func.call(<span class="built_in">this</span>, arg1, arg2)</span><br><span class="line">func.apply(<span class="built_in">this</span>, [arg1, arg2])</span><br></pre></td></tr></tbody></table></figure><p>apply、call 实例</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组追加</span></span><br><span class="line"><span class="keyword">var</span> array1 = [<span class="number">12</span> , <span class="string">"foo"</span> , {<span class="attr">name</span>:<span class="string">"Joe"</span>} , -<span class="number">2458</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="string">"Doe"</span> , <span class="number">555</span> , <span class="number">100</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(array1, array2);</span><br><span class="line"><span class="comment">// array1 值为  [12 , "foo" , {name:"Joe"} , -2458 , "Doe" , 555 , 100]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组中的最大值和最小值</span></span><br><span class="line"><span class="keyword">var</span>  numbers = [<span class="number">5</span>, <span class="number">458</span> , <span class="number">120</span> , -<span class="number">215</span> ];</span><br><span class="line"><span class="keyword">var</span> maxInNumbers = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, numbers),   <span class="comment">//458</span></span><br><span class="line"><span class="keyword">var</span> maxInNumbers = <span class="built_in">Math</span>.max.call(<span class="built_in">Math</span>,<span class="number">5</span>, <span class="number">458</span> , <span class="number">120</span> , -<span class="number">215</span>); <span class="comment">//458</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证是否是数组</span></span><br><span class="line"><span class="function"><span class="title">functionisArray</span>(<span class="params">obj</span>)</span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>bind()最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的 this 值。<br>bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.num = <span class="number">9</span></span><br><span class="line"><span class="keyword">var</span> mymodule = {</span><br><span class="line">  num: <span class="number">81</span>,</span><br><span class="line">  getNum: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.num)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">mymodule.getNum() <span class="comment">// 81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getNum = mymodule.getNum</span><br><span class="line">getNum() <span class="comment">// 9, 因为在这个例子中，"this"指向全局对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boundGetNum = getNum.bind(mymodule)</span><br><span class="line">boundGetNum() <span class="comment">// 81</span></span><br></pre></td></tr></tbody></table></figure><p>当调用 bind 函数后，bind 函数的第一个参数就是原函数作用域中 this 指向的值</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newFunc = func.bind({ <span class="attr">a</span>: <span class="number">1</span> })</span><br><span class="line">newFunc() <span class="comment">// 打印：{a:1}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newFunc2 = func.bind([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">newFunc2() <span class="comment">// 打印：[1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newFunc3 = func.bind(<span class="number">1</span>)</span><br><span class="line">newFunc3() <span class="comment">// 打印：Number:{1}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newFunc4 = func.bind(<span class="literal">undefined</span> / <span class="literal">null</span>)</span><br><span class="line">newFunc4() <span class="comment">// 打印：window</span></span><br></pre></td></tr></tbody></table></figure><ul><li>当传入为 null 或者 undefined 时，在非严格模式下，this 指向为 window。</li><li>当传入为简单值时，内部会将简单的值包装成对应类型的对象，数字就调用 Number 方法包装；字符串就调用 String 方法包装；true/false 就调用 Boolean 方法包装。要想取到原始值，可以调用 valueOf 方法。</li></ul><p>传递的参数的顺序问题</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a, b, c</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c) <span class="comment">// 打印传入的实参</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newFunc = func.bind({}, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">newFunc(<span class="number">3</span>) <span class="comment">//1,2,3</span></span><br><span class="line"><span class="comment">// 可以看到，在 bind 中传递的参数要先传入到原函数中。</span></span><br></pre></td></tr></tbody></table></figure><p>返回的新函数被当成构造函数</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">name</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// 打印：通过{name:'wy'}</span></span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">}</span><br><span class="line">func.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> obj = { <span class="attr">a</span>: <span class="number">1</span> }</span><br><span class="line"><span class="comment">// 调用bind,返回新函数</span></span><br><span class="line"><span class="keyword">let</span> newFunc = func.bind(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把新函数作为构造函数,创建实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> newFunc(<span class="string">'seven'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.hello()) <span class="comment">// 打印：'seven'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// 打印：{a:1}</span></span><br></pre></td></tr></tbody></table></figure><p>新函数被当成了构造函数，原函数 func 中的 this 不再指向传入给 bind 的第一个参数，而是指向用 new 创建的实例。在通过实例 o 找原型上的方法 hello 时，能够找到原函数 func 原型上的方法。</p><h4 id="apply、call、bind-比较"><a href="#apply、call、bind-比较" class="headerlink" title="apply、call、bind 比较"></a>apply、call、bind 比较</h4><ul><li>apply 、call 、bind 三者都是用来改变函数的 this 对象的指向的；</li><li>apply 、call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文；</li><li>apply 、call 、bind 三者都可以利用后续参数传参；</li><li>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = {</span><br><span class="line">  x: <span class="number">81</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = {</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.x</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.bind(obj)()) <span class="comment">//81</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.call(obj)) <span class="comment">//81</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.apply(obj)) <span class="comment">//81</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/js%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0/"/>
      <url>2020/12/29/js%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>高阶函数是对其他函数进行操作的函数，可以将它们作为参数或通过返回它们。简单来说，高阶函数是一个函数，它接收函数作为参数或将函数作为输出返回。</p><p>例如<code>Array.prototype.map</code>，<code>Array.prototype.filter</code>，<code>Array.prototype.reduce</code> 都是一些高阶函数。</p><h2 id="尾调用和尾递归"><a href="#尾调用和尾递归" class="headerlink" title="尾调用和尾递归"></a>尾调用和尾递归</h2><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚。就是指某个函数的最后一步是调用另一个函数。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">x</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> g(x)</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>))</span><br><span class="line"><span class="comment">//上面代码中，函数f的最后一步是调用函数g，这就是尾调用。</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，函数 f 的最后一步是调用函数 g，这就是尾调用。尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生栈溢出错误。但是队伍尾递归来说，由于只存在一个调用帧，所以永远不会发生栈溢出错误。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码是一个阶乘函数，计算 n 的阶乘，最多需要保存 n 个调用数据，复杂度为 O（n），如果改写成尾调用，只保留一个调用记录，复杂度为 O（1）。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factor</span>(<span class="params">n, total</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) {</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> factor(n - <span class="number">1</span>, n * total)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>斐波拉切数列也是可以用于尾调用。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//尾递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibona</span>(<span class="params">n, ac1 = <span class="number">1</span>, ac2 = <span class="number">1</span></span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) {</span><br><span class="line">    <span class="keyword">return</span> ac2</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> Fibona(n - <span class="number">1</span>, ac2, ac1 + ac2)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="柯理化函数"><a href="#柯理化函数" class="headerlink" title="柯理化函数"></a>柯理化函数</h2><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。<strong>所谓柯里化就是把具有较多参数的函数转换成具有较少参数的函数的过程。</strong><br>举个例子</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, c, d, e</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c, d, e)</span><br><span class="line">}</span><br><span class="line"><span class="comment">//生成的柯里化函数</span></span><br><span class="line"><span class="keyword">let</span> _fn = curry(fn)</span><br><span class="line"></span><br><span class="line">_fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line">_fn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line">_fn(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>) <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line">_fn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>) <span class="comment">// print: 1,2,3,4,5</span></span><br></pre></td></tr></tbody></table></figure><p>柯理化函数的实现</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对求和函数做curry化</span></span><br><span class="line"><span class="keyword">let</span> f1 = curry(add, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'复杂版'</span>, f1()) <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对求和函数做curry化</span></span><br><span class="line"><span class="keyword">let</span> f2 = curry(add, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'复杂版'</span>, f2(<span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对求和函数做curry化</span></span><br><span class="line"><span class="keyword">let</span> f3 = curry(add)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'复杂版'</span>, f3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复杂版curry函数可以多次调用，如下：</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'复杂版'</span>, f3(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'复杂版'</span>, f3(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'复杂版'</span>, f3(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复杂版(每次可传入不定数量的参数，当所传参数总数不少于函数的形参总数时，才会执行)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>{</span><br><span class="line">  <span class="comment">// 闭包</span></span><br><span class="line">  <span class="comment">// 缓存除函数fn之外的所有参数</span></span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">// 连接已缓存的老的参数和新传入的参数(即把每次传入的参数全部先保存下来，但是并不执行)</span></span><br><span class="line">    <span class="keyword">let</span> newArgs = args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>))</span><br><span class="line">    <span class="keyword">if</span> (newArgs.length &lt; fn.length) {</span><br><span class="line">      <span class="comment">// 累积的参数总数少于fn形参总数</span></span><br><span class="line">      <span class="comment">// 递归传入fn和已累积的参数</span></span><br><span class="line">      <span class="keyword">return</span> curry.call(<span class="built_in">this</span>, fn, ...newArgs)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// 调用</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, newArgs)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="柯里化的用途"><a href="#柯里化的用途" class="headerlink" title="柯里化的用途"></a>柯里化的用途</h3><p>柯里化实际是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。 而这里对于函数参数的自由处理，正是柯里化的核心所在。 柯里化本质上是降低通用性，提高适用性。来看一个例子：</p><p>我们工作中会遇到各种需要通过正则检验的需求，比如校验电话号码、校验邮箱、校验身份证号、校验密码等， 这时我们会封装一个通用函数 checkByRegExp ,接收两个参数，校验的正则对象和待校验的字符串</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkByRegExp</span>(<span class="params">regExp, string</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> regExp.text(string)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">checkByRegExp(<span class="regexp">/^1\d{10}$/</span>, <span class="string">'18642838455'</span>) <span class="comment">// 校验电话号码</span></span><br><span class="line">checkByRegExp(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>, <span class="string">'test@163.com'</span>) <span class="comment">// 校验邮箱</span></span><br></pre></td></tr></tbody></table></figure><p>我们每次进行校验的时候都需要输入一串正则，再校验同一类型的数据时，相同的正则我们需要写多次， 这就导致我们在使用的时候效率低下，并且由于 checkByRegExp 函数本身是一个工具函数并没有任何意义。此时，我们可以借助柯里化对 checkByRegExp 函数进行封装，以简化代码书写，提高代码可读性。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行柯里化</span></span><br><span class="line"><span class="keyword">let</span> _check = curry(checkByRegExp)</span><br><span class="line"><span class="comment">//生成工具函数，验证电话号码</span></span><br><span class="line"><span class="keyword">let</span> checkCellPhone = _check(<span class="regexp">/^1\d{10}$/</span>)</span><br><span class="line"><span class="comment">//生成工具函数，验证邮箱</span></span><br><span class="line"><span class="keyword">let</span> checkEmail = _check(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>)</span><br><span class="line"></span><br><span class="line">checkCellPhone(<span class="string">'18642838455'</span>) <span class="comment">// 校验电话号码</span></span><br><span class="line">checkCellPhone(<span class="string">'13109840560'</span>) <span class="comment">// 校验电话号码</span></span><br><span class="line">checkCellPhone(<span class="string">'13204061212'</span>) <span class="comment">// 校验电话号码</span></span><br><span class="line"></span><br><span class="line">checkEmail(<span class="string">'test@163.com'</span>) <span class="comment">// 校验邮箱</span></span><br><span class="line">checkEmail(<span class="string">'test@qq.com'</span>) <span class="comment">// 校验邮箱</span></span><br><span class="line">checkEmail(<span class="string">'test@gmail.com'</span>) <span class="comment">// 校验邮箱</span></span><br></pre></td></tr></tbody></table></figure><h3 id="柯里化函数参数-length"><a href="#柯里化函数参数-length" class="headerlink" title="柯里化函数参数 length"></a>柯里化函数参数 length</h3><p>函数 currying 的实现中，使用了 fn.length 来表示函数参数的个数，那 fn.length 表示函数的所有参数个数吗？并不是。</p><p>函数的 length 属性获取的是形参的个数，但是形参的数量不包括剩余参数个数，而且仅包括第一个具有默认值之前的参数个数，看下面的例子。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function">(<span class="params">a, b, c</span>) =&gt;</span> {})</span><br><span class="line">  .length(</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    (a, b, c = <span class="number">3</span>) =&gt; {}</span><br><span class="line">  )</span><br><span class="line">  .length(</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    (a, b = <span class="number">2</span>, c) =&gt; {}</span><br><span class="line">  )</span><br><span class="line">  .length(</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    (a = <span class="number">1</span>, b, c) =&gt; {}</span><br><span class="line">  )</span><br><span class="line">  .length(</span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    (...args) =&gt; {}</span><br><span class="line">  ).length</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">...args</span>) =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(args.length)</span><br><span class="line">}</span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure><h2 id="compose-函数"><a href="#compose-函数" class="headerlink" title="compose 函数"></a>compose 函数</h2><p>compose 就是组合函数，将子函数串联起来执行，一个函数的输出结果是另一个函数的输入参数，一旦第一个函数开始执行，会像多米诺骨牌一样推导执行后续函数。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greeting = <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`Hello <span class="subst">${name}</span>`</span></span><br><span class="line"><span class="keyword">const</span> toUpper = <span class="function">(<span class="params">str</span>) =&gt;</span> str.toUpperCase()</span><br><span class="line"></span><br><span class="line">toUpper(greeting(<span class="string">'Onion'</span>)) <span class="comment">// HELLO ONION</span></span><br></pre></td></tr></tbody></table></figure><p>compose 函数的特点</p><ul><li>compose 接受函数作为参数，从右向左执行，返回类型函数</li><li>fn()全部参数传给最右边的函数，得到结果后传给倒数第二个，依次传递</li></ul><p>compose 的实现</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compose = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> len = args.length <span class="comment">// args函数的个数</span></span><br><span class="line">  <span class="keyword">var</span> count = len - <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">...args1</span>) </span>{</span><br><span class="line">    <span class="comment">// func函数的args1参数枚举</span></span><br><span class="line">    result = args[count].call(<span class="built_in">this</span>, args1)</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">      count--</span><br><span class="line">      <span class="keyword">return</span> func.call(<span class="literal">null</span>, result) <span class="comment">// result 上一个函数的返回结果</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">//回复count初始状态</span></span><br><span class="line">      count = len - <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>举个例子</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`Hello <span class="subst">${name}</span>`</span></span><br><span class="line"><span class="keyword">var</span> toUpper = <span class="function">(<span class="params">str</span>) =&gt;</span> str.toUpperCase()</span><br><span class="line"><span class="keyword">var</span> fn = compose(toUpper, greeting)</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="string">'jack'</span>))</span><br></pre></td></tr></tbody></table></figure><p>大家熟悉的 webpack 里面的 loader 执行顺序是从右到左，是因为 webpack 选择的是 compose 方式，从右到左依次执行 loader，每个 loader 是一个函数。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rules: [{ <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] }]</span><br></pre></td></tr></tbody></table></figure><p>如上，webpack 使用了 style-loader 和 css-loader，它是先用 css-loader 加载.css 文件，然后 style-loader 将内部样式注入到我们的 html 页面。</p><p>webpack 里面的 compose 代码如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> fns.reduce(</span><br><span class="line">    (prevFn, nextFn) =&gt; {</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">value</span>) =&gt;</span> prevFn(nextFn(value))</span><br><span class="line">    },</span><br><span class="line">    (value) =&gt; value</span><br><span class="line">  )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/js%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
      <url>2020/12/29/js%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h1><p>应用场景：在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。这时候就用到防抖与节流。</p><h3 id="函数防抖（debounce）："><a href="#函数防抖（debounce）：" class="headerlink" title="函数防抖（debounce）："></a>函数防抖（debounce）：</h3><p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p><p>非立即执行版</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);      </span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        }, wait);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p><p>立即执行版</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait</span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">        }, wait)</span><br><span class="line">        <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果</p><h4 id="防抖应用场景"><a href="#防抖应用场景" class="headerlink" title="防抖应用场景"></a>防抖应用场景</h4><ol><li>搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。</li><li>表单验证</li><li>按钮提交事件。</li><li>浏览器窗口缩放，resize事件(如窗口停止改变大小之后重新计算布局)等。</li></ol><h3 id="函数节流（throttle）："><a href="#函数节流（throttle）：" class="headerlink" title="函数节流（throttle）："></a>函数节流（throttle）：</h3><p>当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。函数节流主要有两种实现方法：时间戳和定时器</p><p>时间戳版:</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) {</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>定时器版:</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) {</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> {</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            }, wait)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="节流应用场景"><a href="#节流应用场景" class="headerlink" title="节流应用场景"></a>节流应用场景</h4><ol><li>按钮点击事件</li><li>拖拽事件</li><li>onScoll</li><li>计算鼠标移动的距离(mousemove)</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p><p>函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p><p>区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/js%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>2020/12/29/js%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-继承"><a href="#JS-继承" class="headerlink" title="JS 继承"></a>JS 继承</h1><h3 id="1、属性拷贝"><a href="#1、属性拷贝" class="headerlink" title="1、属性拷贝"></a>1、属性拷贝</h3><p>如果继承过来的成员是引用类型的话, 那么这个引用类型的成员在父对象和子对象之间是共享的, 也就是说修改了之后, 父子对象都会受到影响.</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建父对象</span></span><br><span class="line"><span class="keyword">var</span> superObj = {</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">  friends: { <span class="attr">age</span>: <span class="number">33</span> },</span><br><span class="line">  showName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建需要继承的子对象</span></span><br><span class="line"><span class="keyword">var</span> subObj = {}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始拷贝属性(使用for...in...循环)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> superObj) {</span><br><span class="line">  subObj[i] = superObj[i]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">subObj.age = <span class="number">20</span></span><br><span class="line">subObj.friends.age = <span class="number">44</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(subObj) <span class="comment">//  {age:20,friends: { age: 44 }}</span></span><br><span class="line"><span class="built_in">console</span>.log(superObj) <span class="comment">//  {age:25,friends: { age: 44 }}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="2、原型式继承"><a href="#2、原型式继承" class="headerlink" title="2、原型式继承"></a>2、原型式继承</h3><ul><li>父构造函数的原型对象和子构造函数的原型对象上的成员有共享问题</li><li>只能继承父构造函数的原型对象上的成员, 不能继承父构造函数的实例对象的成员</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>{</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    alert(<span class="built_in">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置父构造器的原型对象</span></span><br><span class="line">SuperClass.prototype.showAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>{}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置子构造函数的原型对象实现继承</span></span><br><span class="line">SubClass.prototype = SuperClass.prototype</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> SubClass()</span><br></pre></td></tr></tbody></table></figure><h3 id="3、原型链继承"><a href="#3、原型链继承" class="headerlink" title="3、原型链继承"></a>3、原型链继承</h3><p>不能给父构造函数传递参数，父子构造函数的原型对象之间有共享问题</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">'liyajie'</span></span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">25</span></span><br><span class="line">  <span class="built_in">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 设置父构造函数的原型</span></span><br><span class="line">SuperClass.prototype.friends = [<span class="string">'小名'</span>, <span class="string">'小强'</span>]</span><br><span class="line">SuperClass.prototype.showAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 创建子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>{}</span><br><span class="line"><span class="comment">// 实现继承</span></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass()</span><br><span class="line"><span class="comment">// 修改子构造函数的原型的构造器属性</span></span><br><span class="line">SubClass.prototype.constructor = SubClass</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> SubClass()</span><br><span class="line"><span class="built_in">console</span>.log(child.name) <span class="comment">// liyajie</span></span><br><span class="line"><span class="built_in">console</span>.log(child.age) <span class="comment">// 25</span></span><br><span class="line">child.showName() <span class="comment">// liyajie</span></span><br><span class="line">child.showAge() <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(child.friends) <span class="comment">// ['小名','小强']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当我们改变friends的时候, 父构造函数的原型对象的也会变化</span></span><br><span class="line">child.friends.push(<span class="string">'小王八'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child.friends) <span class="comment">//[('小名', '小强', '小王八')]</span></span><br><span class="line"><span class="keyword">var</span> father = <span class="keyword">new</span> SuperClass()</span><br><span class="line"><span class="built_in">console</span>.log(father.friends) <span class="comment">//[('小名', '小强', '小王八')]</span></span><br></pre></td></tr></tbody></table></figure><h3 id="4、借用构造函数"><a href="#4、借用构造函数" class="headerlink" title="4、借用构造函数"></a>4、借用构造函数</h3><p>使用 call 和 apply 借用其他构造函数的成员, 可以解决给父构造函数传递参数的问题, 但是获取不到父构造函数原型上的成员.也不存在共享问题</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>{</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.friends = [<span class="string">'小王'</span>, <span class="string">'小强'</span>]</span><br><span class="line">  <span class="built_in">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">Person.prototype.showAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>{</span><br><span class="line">  <span class="comment">// 使用call借用Person的构造函数</span></span><br><span class="line">  Person.call(<span class="built_in">this</span>, name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试是否有了 Person 的成员</span></span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">'Li'</span>)</span><br><span class="line">stu.showName() <span class="comment">// Li</span></span><br><span class="line"><span class="built_in">console</span>.log(stu.friends) <span class="comment">// ['小王','小强']</span></span><br><span class="line">stu.showAge()  <span class="comment">// stu.showAge is not a function</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5、组合继承-借用构造函数-原型式继承"><a href="#5、组合继承-借用构造函数-原型式继承" class="headerlink" title="5、组合继承 (借用构造函数 + 原型式继承)"></a>5、组合继承 (借用构造函数 + 原型式继承)</h3><ul><li>解决了父构造函数的属性继承到了子构造函数的实例对象上了,</li><li>并且继承了父构造函数原型对象上的成员</li><li>解决了给父构造函数传递参数问题</li><li>存在共享的问题</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>{</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  <span class="built_in">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 设置父构造函数的原型对象</span></span><br><span class="line">Person.prototype.showAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 创建子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>{</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name)</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 设置继承</span></span><br><span class="line">Student.prototype = Person.prototype</span><br><span class="line">Student.prototype.constructor = Student</span><br></pre></td></tr></tbody></table></figure><h3 id="6、借用构造函数-深拷贝"><a href="#6、借用构造函数-深拷贝" class="headerlink" title="6、借用构造函数 + 深拷贝"></a>6、借用构造函数 + 深拷贝</h3><p>这样就将 Person 的原型对象上的成员拷贝到了 Student 的原型上了, 这种方式没有属性共享的问题.</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>{</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">Person.prototype.friends = [<span class="string">'小王'</span>,<span class="string">'小强'</span>,<span class="string">'小王八'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,<span class="number">25</span></span>)</span>{</span><br><span class="line">    <span class="comment">// 借用构造函数(Person)</span></span><br><span class="line">    Person.call(<span class="built_in">this</span>,name,<span class="number">25</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 使用深拷贝实现继承</span></span><br><span class="line">deepCopy(Student.prototype,Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/js%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/"/>
      <url>2020/12/29/js%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><p>递归算法，是将问题转化为规模缩小的同类问题的子问题，每一个子问题都用一个同样的算法去解决。一个递归算法就是<strong>函数调用自身去解决它的子问题</strong>。</p><p><strong>递归算法的特点</strong>：</p><ul><li>在函数过程中调用自身。</li><li>必须有一个明确的条件判断递归的结束，既递归出口。</li></ul><p><strong>递归算法的步骤</strong></p><ul><li>假设递归函数已经写好</li><li>寻找递推关系</li><li>将递推关系的结构转换为递归体</li><li>将临界条件加入到递归体中</li></ul><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><p>阶乘，定义为 n！，表示从 1 到 n 的整数的乘积。</p><p>方法 1： for 循环</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = <span class="function">(<span class="params">n</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &gt; <span class="number">1</span>; i--) {</span><br><span class="line">    total = total * i</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> total</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)) <span class="comment">// 120</span></span><br></pre></td></tr></tbody></table></figure><p>方法 2：递归</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = <span class="function">(<span class="params">n</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)) <span class="comment">// 120</span></span><br></pre></td></tr></tbody></table></figure><p>这种递归方法写起来很方便，但是也存在缺点，就是会保存很多个调用帧，比如上边的 factorial(5)，这个方法要执行 5 次，才能返回最终的计算表达式，这样每次都要保存这个方法，就容易造成栈溢出。为了解决这个问题，我们可以使用<strong>尾递归</strong>。</p><p>当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = <span class="function">(<span class="params">n, total = <span class="number">1</span></span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> total</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, total * n)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>)) <span class="comment">// 120</span></span><br></pre></td></tr></tbody></table></figure><p>这样，每一次返回的就是一个新的函数，不带上一个函数的参数，也就不需要储存上一个函数了。只需要一个帧即可。</p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>斐波那契数列从第三项开始，每一项都等于前两项之和。0, 1, 1, 2, 3, 5, 8, 13…</p><p>方法 1: 非递归，时间复杂度为 O(n)</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> c = a + b</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt; n; i++) {</span><br><span class="line">    a = b</span><br><span class="line">    b = c</span><br><span class="line">    c = a + b</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">10</span>)) <span class="comment">// 34</span></span><br></pre></td></tr></tbody></table></figure><p>方法 2：递归。时间复杂度为 O(2^n)</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>) <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">10</span>)) <span class="comment">// 34</span></span><br></pre></td></tr></tbody></table></figure><p>方法 3：尾递归</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n, ac1 = <span class="number">1</span>, ac2 = <span class="number">1</span></span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) {</span><br><span class="line">    <span class="keyword">return</span> ac2</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> fib(n - <span class="number">1</span>, ac2, ac1 + ac2)</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">10</span>)) <span class="comment">// 34</span></span><br></pre></td></tr></tbody></table></figure><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p>问题描述：一共 10 级楼梯，每次可以走一步或两步，求一共多少种走法。</p><p>要想走到 N(N=10)级,可以分为 2 种情况。</p><ul><li>从 n-2 级迈两步</li><li>从 n-1 级迈一步</li></ul><p>那么对于 n-2 和 n-1 的情况也是各自分为两种，以此类推。那么走法的和就是 n-2 的走法和 n-1 的走法之和。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">climbStairs</span>(<span class="params">n</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><p>方法 1：短除法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">a, b</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= a &amp;&amp; i &lt;= b; i++) {</span><br><span class="line">    <span class="keyword">if</span> (a % i == <span class="number">0</span> &amp;&amp; b % i == <span class="number">0</span>) {</span><br><span class="line">      result = i</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>方法 2：辗转相除法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">m, n</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">Math</span>.max(m, n)</span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">Math</span>.min(m, n)</span><br><span class="line">  <span class="keyword">if</span> (a % b == <span class="number">0</span>) <span class="keyword">return</span> b</span><br><span class="line">  <span class="keyword">return</span> gcd(b, a % b)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="二分法排序"><a href="#二分法排序" class="headerlink" title="二分法排序"></a>二分法排序</h3><p>二分法排序的原理如下</p><ul><li>取数组一个随机索引值作为比较值</li><li>数组每一项与比较值做大小比较，比之小的放在左边数组，比之大的放在右边数组</li><li>依次递归直到执行的数组长度为 1</li><li>concat() 方法连接两个或多个数组</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">var</span> leftArr = []</span><br><span class="line">  <span class="keyword">var</span> rightArr = []</span><br><span class="line">  <span class="keyword">var</span> pivot = <span class="built_in">Math</span>.random(arr.length / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">var</span> baseNum = arr.splice(pivot, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (num &lt; baseNum) {</span><br><span class="line">      leftArr.push(num)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      rightArr.push(num)</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">  <span class="keyword">return</span> quickSort(leftArr).concat(baseNum, quickSort(rightArr))</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(quickSort([<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"/>
      <url>2020/12/29/js%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="js-数组操作"><a href="#js-数组操作" class="headerlink" title="js 数组操作"></a>js 数组操作</h1><p>在开发中，数组的使用场景非常多，平日中也涉及到很多数组相关操作，对一些常见的操作方法进行总结和收藏，在开发中就能信手拈来，大大提高开发效率。</p><h2 id="随机排序"><a href="#随机排序" class="headerlink" title="随机排序"></a>随机排序</h2><p>1、生成随机数</p><p>遍历数组，每次循环都随机一个在数组长度范围内的数，并交换本次循环的位置和随机数位置上的元素</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort1</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = arr.length; i &lt; l; i++) {</span><br><span class="line">    <span class="keyword">let</span> rc = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * l)</span><br><span class="line">    <span class="comment">// 让当前循环的数组元素和随机出来的数组元素交换位置</span></span><br><span class="line">    <span class="keyword">const</span> empty = arr[i]</span><br><span class="line">    arr[i] = arr[rc]</span><br><span class="line">    arr[rc] = empty</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment">// 下面两次的结果肯定是不一样的；</span></span><br><span class="line"><span class="built_in">console</span>.log(randomSort1(arr1))</span><br><span class="line"><span class="built_in">console</span>.log(randomSort1(arr1))</span><br></pre></td></tr></tbody></table></figure><p>2、生成新数组</p><ol><li>申明一个新的空数组,利用 while 循环，如果数组长度大于 0，就继续循环；</li><li>每次循环都随机一个在数组长度范围内的数，将随机数位置上的元素 push 到新数组里，</li><li>并利用 splice（对 splice 不太理解的同学可以看这里）截取出随机数位置上的元素，同时也修改了原始数组的长度；</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort2</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> mixedArr = []</span><br><span class="line">  <span class="keyword">while</span> (arr.length &gt; <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">let</span> rc = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * arr.length)</span><br><span class="line">    mixedArr.push(arr[rc])</span><br><span class="line">    arr.splice(rc, <span class="number">1</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> mixedArr</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(randomSort2(arr1))</span><br></pre></td></tr></tbody></table></figure><p>3、 arr.sort</p><ol><li>如果 compareFunction(a, b)的返回值 小于 0 ，那么 a 会被排列到 b 之前；</li><li>如果 compareFunction(a, b)的返回值 等于 0 ，那么 a 和 b 的相对位置不变；</li><li>如果 compareFunction(a, b)的返回值 大于 0 ，那么 b 会被排列到 a 之前；</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort3</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span></span><br><span class="line">  })</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(randomSort3(arr1))</span><br></pre></td></tr></tbody></table></figure><h2 id="数组对象排序"><a href="#数组对象排序" class="headerlink" title="数组对象排序"></a>数组对象排序</h2><p>1、单个属性排序</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">property</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> value1 = a[property]</span><br><span class="line">    <span class="keyword">let</span> value2 = b[property]</span><br><span class="line">    <span class="keyword">return</span> value1 - value2</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  { <span class="attr">name</span>: <span class="string">'zopp'</span>, <span class="attr">age</span>: <span class="number">10</span> },</span><br><span class="line">  { <span class="attr">name</span>: <span class="string">'gpp'</span>, <span class="attr">age</span>: <span class="number">18</span> },</span><br><span class="line">  { <span class="attr">name</span>: <span class="string">'yjj'</span>, <span class="attr">age</span>: <span class="number">8</span> },</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(compare(<span class="string">'age'</span>)))</span><br></pre></td></tr></tbody></table></figure><p>2、多个属性排序</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">by</span>(<span class="params">name, minor</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">o, p</span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> a, b</span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp; p &amp;&amp; <span class="keyword">typeof</span> o === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> p === <span class="string">'object'</span>) {</span><br><span class="line">      a = o[name]</span><br><span class="line">      b = p[name]</span><br><span class="line">      <span class="keyword">if</span> (a === b) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> minor === <span class="string">'function'</span> ? minor(o, p) : <span class="number">0</span></span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="keyword">typeof</span> b) {</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? -<span class="number">1</span> : <span class="number">1</span></span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> a &lt; <span class="keyword">typeof</span> b ? -<span class="number">1</span> : <span class="number">1</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      thro(<span class="string">'error'</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><p>1、调用 ES6 中的 flat 方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ary = arr.flat(<span class="literal">Infinity</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]]]].flat(<span class="literal">Infinity</span>))</span><br></pre></td></tr></tbody></table></figure><p>2、普通递归</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"><span class="keyword">let</span> flatten = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">    <span class="keyword">let</span> item = arr[i]</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) {</span><br><span class="line">      flatten(item)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      result.push(item)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]]]</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br></pre></td></tr></tbody></table></figure><p>3、利用 reduce 函数迭代</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">return</span> pre.concat(<span class="built_in">Array</span>.isArray(cur) ? flatten(cur) : cur)</span><br><span class="line">  }, [])</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]]]</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br></pre></td></tr></tbody></table></figure><p>4、扩展运算符</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">while</span> (arr.some(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">Array</span>.isArray(item))) {</span><br><span class="line">    arr = [].concat(...arr)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>]]]</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br></pre></td></tr></tbody></table></figure><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>1、利用数组的 indexOf 下标属性来查询</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">    <span class="keyword">if</span> (newArr.indexOf(arr[i]) === -<span class="number">1</span>) {</span><br><span class="line">      newArr.push(arr[i])</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(unique([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure><p>2、先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> formArr = arr.sort()</span><br><span class="line">  <span class="keyword">var</span> newArr = [formArr[<span class="number">0</span>]]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; formArr.length; i++) {</span><br><span class="line">    <span class="keyword">if</span> (formArr[i] !== formArr[i - <span class="number">1</span>]) {</span><br><span class="line">      newArr.push(formArr[i])</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(unique([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure><p>3、利用对象属性存在的特性，如果没有该属性则存入新数组。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> obj = {}</span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">    <span class="keyword">if</span> (!obj[arr[i]]) {</span><br><span class="line">      obj[arr[i]] = <span class="number">1</span></span><br><span class="line">      newArr.push(arr[i])</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(unique([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure><p>4、利用数组原型对象上的 includes 方法。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">    <span class="keyword">if</span> (!newArr.includes(arr[i])) {</span><br><span class="line">      newArr.push(arr[i])</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(unique([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure><p>5、利用数组原型对象上的 filter 和 includes 方法。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> newArr = []</span><br><span class="line">  newArr = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> newArr.includes(item) ? <span class="string">''</span> : newArr.push(item)</span><br><span class="line">  })</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(unique([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure><p>6、利用 ES6 的 set 方法。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)) <span class="comment">// 利用Array.from将Set结构转换成数组</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(unique([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="根据属性去重"><a href="#根据属性去重" class="headerlink" title="根据属性去重"></a>根据属性去重</h2><p>方法一</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> !res.has(item.productName) &amp;&amp; res.set(item.productName, <span class="number">1</span>))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>方法二</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> result = {}</span><br><span class="line">  <span class="keyword">let</span> obj = {}</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">    <span class="keyword">if</span> (!obj[arr[i].key]) {</span><br><span class="line">      result.push(arr[i])</span><br><span class="line">      obj[arr[i].key] = <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="交集-并集-差集"><a href="#交集-并集-差集" class="headerlink" title="交集/并集/差集"></a>交集/并集/差集</h2><p>1、includes 方法结合 filter 方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = a.concat(b.filter(<span class="function">(<span class="params">v</span>) =&gt;</span> !a.includes(v)))</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersection = a.filter(<span class="function">(<span class="params">v</span>) =&gt;</span> b.includes(v))</span><br><span class="line"><span class="comment">// [2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = a.concat(b).filter(<span class="function">(<span class="params">v</span>) =&gt;</span> !a.includes(v) || !b.includes(v))</span><br><span class="line"><span class="comment">// [1,3,4,5]</span></span><br></pre></td></tr></tbody></table></figure><p>2、ES6 的 Set 数据结构</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b])</span><br><span class="line"><span class="comment">// Set {1, 2, 3, 4,5}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> b.has(x)))</span><br><span class="line"><span class="comment">// set {2}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> !b.has(x)))</span><br><span class="line"><span class="comment">// Set {1, 3, 4, 5}</span></span><br></pre></td></tr></tbody></table></figure><h2 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h2><p>1、万能的 for 循环</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> s = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">    s += arr[i]</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment">// 15</span></span><br></pre></td></tr></tbody></table></figure><p>2、递归方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> len = arr.length</span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">1</span>) {</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>] + sum(arr.slice(<span class="number">1</span>))</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment">// 15</span></span><br></pre></td></tr></tbody></table></figure><p>3、ES6 的 reduce 方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, curr</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> prev + curr</span><br><span class="line">  }, <span class="number">0</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment">// 15</span></span><br></pre></td></tr></tbody></table></figure><h2 id="类数组转化"><a href="#类数组转化" class="headerlink" title="类数组转化"></a>类数组转化</h2><p>1、Array 的 slice 方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br></pre></td></tr></tbody></table></figure><p>2、ES6 的 Array.from()</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br></pre></td></tr></tbody></table></figure><p>3、扩展运算符…</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...arguments]</span><br></pre></td></tr></tbody></table></figure><h2 id="数组上下移动"><a href="#数组上下移动" class="headerlink" title="数组上下移动"></a>数组上下移动</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swapItems</span>(<span class="params">arr, index1, index2</span>) </span>{</span><br><span class="line">  arr[index1] = arr.splice(index2, <span class="number">1</span>, arr[index1])[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">up</span>(<span class="params">arr, index</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (index === <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">this</span>.swapItems(arr, index, index - <span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">down</span>(<span class="params">arr, index</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (index === <span class="built_in">this</span>.list.length - <span class="number">1</span>) {</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">this</span>.swapItems(arr, index, index + <span class="number">1</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="数组转化为树形结构"><a href="#数组转化为树形结构" class="headerlink" title="数组转化为树形结构"></a>数组转化为树形结构</h2><p>将如下数据转化为树状结构</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  {</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">'1'</span>,</span><br><span class="line">    pid: <span class="number">0</span>,</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">    name: <span class="string">'1-1'</span>,</span><br><span class="line">    pid: <span class="number">1</span>,</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    id: <span class="number">3</span>,</span><br><span class="line">    name: <span class="string">'1-1-1'</span>,</span><br><span class="line">    pid: <span class="number">2</span>,</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    id: <span class="number">4</span>,</span><br><span class="line">    name: <span class="string">'1-2'</span>,</span><br><span class="line">    pid: <span class="number">1</span>,</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    id: <span class="number">5</span>,</span><br><span class="line">    name: <span class="string">'1-2-2'</span>,</span><br><span class="line">    pid: <span class="number">4</span>,</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    id: <span class="number">6</span>,</span><br><span class="line">    name: <span class="string">'1-1-1-1'</span>,</span><br><span class="line">    pid: <span class="number">3</span>,</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    id: <span class="number">7</span>,</span><br><span class="line">    name: <span class="string">'2'</span>,</span><br><span class="line">  },</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>实现方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toTree</span>(<span class="params">data, parentId = <span class="number">0</span></span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> itemArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) {</span><br><span class="line">    <span class="keyword">var</span> node = data[i]</span><br><span class="line">    <span class="keyword">if</span> (node.pid === parentId) {</span><br><span class="line">      <span class="keyword">var</span> newNode = {</span><br><span class="line">        ...node,</span><br><span class="line">        name: node.name,</span><br><span class="line">        id: node.id,</span><br><span class="line">        children: toTree(data, node.id),</span><br><span class="line">      }</span><br><span class="line">      itemArr.push(newNode)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> itemArr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(toTree(arr))</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>2020/12/29/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-数据类型"><a href="#JS-数据类型" class="headerlink" title="JS 数据类型"></a>JS 数据类型</h1><p><strong>JavaScript 是弱类型语言</strong>，而且 JavaScript 声明变量的时候并没有预先确定的类型，变量的类型就是其值的类型，也就是说变量当前的类型由其值所决定,夸张点说上一秒种的 String，下一秒可能就是个 Number 类型了，这个过程可能就进行了某些操作发生了强制类型转换。</p><p>js 数据分为两种类型：原始数据类型和引用数据类型。</p><ul><li>基本数据类型有：string、number、boolean、undefined、null 和 symbol（符号）</li><li>引用数据类型有：Object、Function、Date、RegExp 等。</li></ul><h3 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h3><p>堆和栈的概念存在于数据结构中和操作系统内存中。</p><p>在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全<br>二叉树是堆的一种实现方式。</p><p>在操作系统中，内存被分为栈区和堆区。<br>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。</p><p>基本数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p><p>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在<br>栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实<br>体。</p><h3 id="基本数据类型的特点"><a href="#基本数据类型的特点" class="headerlink" title="基本数据类型的特点"></a>基本数据类型的特点</h3><ol><li>基本数据类型是按值访问的，就是说我们可以操作保存在变量中的实际的值；</li><li>基本数据类型的值是不可变的，任何方法都无法改变一个基本数据类型的值</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'zhangsan'</span></span><br><span class="line">name.substr()</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// 输出：zhangsan</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="string">'firstblood'</span></span><br><span class="line">age.toUpperCase()</span><br><span class="line"><span class="built_in">console</span>.log(age) <span class="comment">// 输出：firstblood</span></span><br></pre></td></tr></tbody></table></figure><p>substr()和 toUpperCase()方法后返回的是一个新的字符串，跟原来定义的变量 name 并没有什么关系。</p><ol start="3"><li>基本数据类型不可以添加属性和方法</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="string">'zhangsan'</span></span><br><span class="line">user.age = <span class="number">18</span></span><br><span class="line">user.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'12345'</span>)</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(user.age) <span class="comment">// 输出：undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(user.method) <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>基本数据类型的赋值是简单的赋值(不影响原变量的值)</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">18</span></span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 输出：19</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 输出：18</span></span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>基本数据类型的比较是值的比较</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'{}'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'{}'</span></span><br><span class="line"><span class="built_in">console</span>.log(a === b) <span class="comment">// 输出：true</span></span><br></pre></td></tr></tbody></table></figure><ol start="6"><li>基本类型的值在内存中占据固定大小的空间，被保存在栈内存中</li></ol><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>引用类型是存放在堆内存中的对象，变量其实是保存的在栈内存中的一个指针（保存的是堆内存中的引用地址），这个指针指向堆内存。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1</span><br><span class="line">obj2.name = <span class="string">'我有名字了'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1.name) <span class="comment">// 我有名字了</span></span><br></pre></td></tr></tbody></table></figure><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><h4 id="转为字符串"><a href="#转为字符串" class="headerlink" title="转为字符串"></a>转为字符串</h4><p>1、toString()方法：注意，不可以转 null 和 underfined<br>2、String()方法：都能转</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = <span class="string">'zhangsan'</span></span><br><span class="line"><span class="keyword">let</span> bc = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> cd = <span class="literal">undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(ab.toString()) <span class="comment">// 输出：zhangsan</span></span><br><span class="line"><span class="built_in">console</span>.log(bc.toString()) <span class="comment">// error 报错</span></span><br><span class="line"><span class="built_in">console</span>.log(cd.toString()) <span class="comment">// error 报错</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(ab)) <span class="comment">// 输出：zhangsan</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(bc)) <span class="comment">// 输出：null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(cd)) <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></tbody></table></figure><p>3、隐式转换：num + “”，当 + 两边一个操作符是字符串类型，一个操作符是其它类型的时候，会先把其它类型转换成字符串再进行字符串拼接，返回字符串</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> str = a + <span class="string">''</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str'</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="转为数值类型"><a href="#转为数值类型" class="headerlink" title="转为数值类型"></a>转为数值类型</h4><p>1、Number()：可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回 NaN</p><p>2、parseInt()/parseFloat():parseFloat()把字符串转换成浮点数,parseFloat()和 parseInt 非常相似，不同之处在与 parseFloat 会解析第一个. 遇到第二个.或者非数字结束如果解析的内容里只有整数，解析成整数。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'12.3px'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(a)) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(a)) <span class="comment">// 12.3</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'abc2.3'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(b)) <span class="comment">//NAN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(b)) <span class="comment">//NAN</span></span><br></pre></td></tr></tbody></table></figure><p>3、隐式转换</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'123'</span></span><br><span class="line"><span class="keyword">var</span> num = str - <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 122</span></span><br></pre></td></tr></tbody></table></figure><p>4、isNaN()函数用于判断是否是一个非数字类型，如果传入的参数是一个非数字类型，那么返回 true，否则返回 false</p><h4 id="转换为-Boolean"><a href="#转换为-Boolean" class="headerlink" title="转换为 Boolean()"></a>转换为 Boolean()</h4><p>除了 0 ‘’(空字符串) null undefined NaN 会转换成 false 其它都会转换成 true</p><h3 id="判断-JS-数据类型"><a href="#判断-JS-数据类型" class="headerlink" title="判断 JS 数据类型"></a>判断 JS 数据类型</h3><h4 id="1、typeof-函数"><a href="#1、typeof-函数" class="headerlink" title="1、typeof()函数"></a>1、typeof()函数</h4><p>对于原始数据类型，我们可以使用 typeof()函数来判断他的数据类型。但他是没法用来区分引用数据类型的，因为所有的引用数据类型都会返回”object”。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">'seymoe'</span> <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">10</span> <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// 'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// 'object' 无法判定是否为 null</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// 'undefined'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> {} <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> (<span class="function">() =&gt;</span> {}) <span class="comment">// 'function'</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2、instanceof"><a href="#2、instanceof" class="headerlink" title="2、instanceof"></a>2、instanceof</h4><p>对于引用类型我们使用 instanceof 来进行类型判断。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = {}</span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure><h4 id="3、Object-prototype-toString-call"><a href="#3、Object-prototype-toString-call" class="headerlink" title="3、Object.prototype.toString.call()"></a>3、Object.prototype.toString.call()</h4><p>在 javascript 高级程序设计中提供了另一种方法，可以通用的来判断原始数据类型和引用数据类型</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr) == <span class="string">'[object Array]'</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{}</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(func) == <span class="string">'[object Function]'</span> <span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure><h4 id="4、constructor"><a href="#4、constructor" class="headerlink" title="4、constructor"></a>4、constructor</h4><p>constructor 作用和 instanceof 非常相似。但 constructor 检测 Object 与 instanceof 不一样，还可以处理基本数据类型的检测。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aa = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(aa.constructor === <span class="built_in">Array</span>) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(aa.constructor === <span class="built_in">RegExp</span>) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>).constructor === <span class="built_in">Number</span>) <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^$/</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.constructor === <span class="built_in">RegExp</span>) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.constructor === <span class="built_in">Object</span>) <span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure><h3 id="javascript-的内置方法"><a href="#javascript-的内置方法" class="headerlink" title="javascript 的内置方法"></a>javascript 的内置方法</h3><ul><li>toString()方法返回一个表示该对象的字符串。</li><li>valueOf()方法返回指定对象的原始值。</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'123'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str.valueOf()) <span class="comment">//123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">console</span>.log(num.valueOf()) <span class="comment">//123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="built_in">console</span>.log(date.valueOf()) <span class="comment">//1526990889729</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bool = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">'123'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(bool.valueOf()) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>({</span><br><span class="line">  valueOf: <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"><span class="built_in">console</span>.log(obj.valueOf()) <span class="comment">//1</span></span><br></pre></td></tr></tbody></table></figure><p><strong>valueOf() 和 toString()在特定的场合下会自行调用。</strong></p><h3 id="包装对象（wrapper-object）"><a href="#包装对象（wrapper-object）" class="headerlink" title="包装对象（wrapper object）"></a>包装对象（wrapper object）</h3><p>先来看一个例子</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'marko'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name) <span class="comment">// "string"</span></span><br><span class="line"><span class="built_in">console</span>.log(name.toUpperCase()) <span class="comment">// "MARKO"</span></span><br></pre></td></tr></tbody></table></figure><p>name 类型是 string，属于基本类型，所以它没有属性和方法，但是在这个例子中，我们调用了一个 toUpperCase()方法，它不会抛出错误，还返回了对象的变量值。 原因是基本类型的值被临时转换或强制转换为对象，因此 name 变量的行为类似于对象。name.toUpperCase()在幕后看起来如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">String</span>(name).toUpperCase()) <span class="comment">// "MARKO"</span></span><br></pre></td></tr></tbody></table></figure><p>除 null 和 undefined 之外的每个基本类型都有自己包装对象。也就是：String，Number，Boolean，Symbol 和 BigInt。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%8F%8AeventLoop/"/>
      <url>2020/12/29/js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%8F%8AeventLoop/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-执行机制"><a href="#JS-执行机制" class="headerlink" title="JS 执行机制"></a>JS 执行机制</h1><p>js 是一门<strong>单线程语言</strong>。所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。     </p><p>js 引擎有一个主线程（main thread）用来解释和执行 js 程序，还存在其他的线程。例如：处理 ajax 请求的线程、处理 DOM 事件的线程、定时器线程、读写文件的线程(例如在 node.js 中)等等。这些线程可能存在于 js 引擎之内，也可能存在于 js 引擎之外，在此我们不做区分。不妨叫它们工作线程。  </p><p>为什么是 js 是单线程的呢？这是因为 JavaScript 可以修改 DOM 结构，如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都修改 DOM，那么就会出现 DOM 冲突。为了避免 DOM 渲染的冲突，可以采用单线程或者死锁，JavaScript 采用了单线程方案。  </p><p>但单线程有一个问题：如果任务队列里有一个任务耗时很长，导致这个任务后面的任务一直排队等待，就会发生页面卡死，严重影响用户体验。</p><h2 id="JS-执行上下文"><a href="#JS-执行上下文" class="headerlink" title="JS 执行上下文"></a>JS 执行上下文</h2><p>当代码运行时，会产生一个对应的执行环境，在这个环境中，所有变量会被事先提出来（变量提升），有的直接赋值，有的为默认值 undefined，代码从上往下开始执行，就叫做执行上下文。</p><p>例子 1:变量提升</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foo <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo1'</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// foo1，foo赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo2'</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// foo2，foo重新赋值</span></span><br></pre></td></tr></tbody></table></figure><p>例子 2：函数提升</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foo() <span class="comment">// foo2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo1'</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// foo2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo2'</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// foo2</span></span><br></pre></td></tr></tbody></table></figure><p>例子 3：声明优先级，函数 &gt; 变量</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foo() <span class="comment">// foo2</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo1'</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// foo1，foo重新赋值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo2'</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// foo1</span></span><br></pre></td></tr></tbody></table></figure><h4 id="执行上下文类型。"><a href="#执行上下文类型。" class="headerlink" title="执行上下文类型。"></a>执行上下文类型。</h4><ul><li><p>全局执行上下文  </p><p>这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</p></li><li><p>函数执行上下文  </p><p>每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。</p></li><li><p>Eval 函数执行上下文  </p><p>执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。</p></li></ul><h4 id="执行上下文特点"><a href="#执行上下文特点" class="headerlink" title="执行上下文特点"></a>执行上下文特点</h4><ol><li>单线程，在主进程上运行</li><li>同步执行，从上往下按顺序执行</li><li>全局上下文只有一个，浏览器关闭时会被弹出栈</li><li>函数的执行上下文没有数目限制</li><li>函数每被调用一次，都会产生一个新的执行上下文环境</li></ol><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>JavaScript 将任务的执行模式分为两种：同步和异步。同步任务都在主线程（这里的主线程就是 JavaScript 引擎线程）上执行，会形成一个 调用栈 ，又称<strong>执行栈</strong>。  </p><p>当JavaScript代码被运行的时候，会创建一个全局上下文，并push到当前执行栈。之后当发生函数调用的时候，引擎会为函数创建一个函数执行上下文并push到栈顶。引擎会先执行调用栈顶部的函数，当函数执行完成后，当前函数的执行上下文会被移除当前执行栈。并移动到下一个上下文。  </p><p>除了主线程外，还有一个任务队列（也称消息队列），用于管理异步任务的事件回调 ，在调用栈的任务执行完毕之后，系统会检查任务队列，看是否有可以执行的异步任务。</p><p>其实这是一个压栈出栈的过程——执行栈。</p><img src="../img/js1.png"><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="comment">// 1.进入全局上下文环境</span></span><br><span class="line">  a = <span class="number">10</span>,</span><br><span class="line">  fn,</span><br><span class="line">  bar = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line">    fn(x + b) <span class="comment">// 3.进入fn上下文环境</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">fn = <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">20</span></span><br><span class="line">  <span class="built_in">console</span>.log(y + c)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">bar(<span class="number">5</span>) <span class="comment">// 2.进入bar上下文环境</span></span><br></pre></td></tr></tbody></table></figure><h4 id="执行上下文生命周期"><a href="#执行上下文生命周期" class="headerlink" title="执行上下文生命周期"></a>执行上下文生命周期</h4><img src="../img/js2.png"><ul><li><p>创建阶段</p><ul><li>生成变量对</li><li>建立作用域</li><li>确定 this 指向</li></ul></li><li><p>执行阶段</p><ul><li>变量赋值</li><li>函数引用</li><li>执行其他代码</li></ul></li><li><p>销毁阶段</p><ul><li>执行完毕出栈，等待回收被销毁</li></ul></li></ul><h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><p>在我们执行 JavaScript 代码的时候，有时会出现栈溢出的情况：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught <span class="built_in">RangeError</span>: Maximum call stack size exceeded</span><br></pre></td></tr></tbody></table></figure><p>这是一个典型的栈溢出。调用栈是用来管理执行上下文的一种数据结构，它是有大小的，当入栈的上下文过多的时候，它就会报栈溢出。比如</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + add()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">add()</span><br></pre></td></tr></tbody></table></figure><p>add 函数不断的递归，不断的入栈，调用栈的容量有限，它就溢出了，所以，我们日常的开发中，一定要注意此类代码的出现。</p><h2 id="javascript-事件循环"><a href="#javascript-事件循环" class="headerlink" title="javascript 事件循环"></a>javascript 事件循环</h2><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入 <code>Event Table</code> 并注册函数。</li><li>当指定的事情完成时，<code>Event Table</code> 会将这个函数移入 <code>Event Queue</code>。</li><li>主线程内的任务执行完毕为空，会去 <code>Event Queue</code> 读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的 <code>Event Loop</code>(事件循环)。</li></ul><img src="../img/js3.png"><p>同步任务和异步任务，我们对任务有更精细的定义：</p><h4 id="macro-task-宏任务-："><a href="#macro-task-宏任务-：" class="headerlink" title="macro-task(宏任务)："></a>macro-task(宏任务)：</h4><p>每次执行栈执行的代码就是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)。浏览器为了能够使得 js 内部<code>(macro)task</code>与 DOM 任务能够有序执行，会在一个<code>(macro)task</code>执行结束后，在下一个<code>(macro)task</code>执行开始前，对页面进行重新渲染。宏任务主要包含：</p><ul><li>script(整体代码)</li><li>setTimeout / setInterval</li><li>setImmediate(Node.js 环境)</li><li>I/O</li><li>UI render</li><li>postMessage</li><li>MessageChannel</li></ul><h4 id="micro-task-微任务-："><a href="#micro-task-微任务-：" class="headerlink" title="micro-task(微任务)："></a>micro-task(微任务)：</h4><p>可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前。所以它的响应速度相比 setTimeout（setTimeout 是 task）会更快，因为无需等渲染。也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）。microtask 主要包含：</p><ul><li>process.nextTick(Node.js 环境)</li><li>Promise</li><li>Async/Await</li><li>MutationObserver(html5 新特性)</li></ul><img src="../img/eventLoop.png" width="80%"><p>总的结论就是，执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。</p><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>我们来分析一段较复杂的代码，看看你是否真的掌握了 js 的执行机制：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>)</span><br><span class="line">  })</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  }).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">  })</span><br><span class="line">})</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'6'</span>)</span><br><span class="line">})</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'7'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">}).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'9'</span>)</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'10'</span>)</span><br><span class="line">  })</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'11'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  }).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">  })</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1,7,8,2,4,5,6,3,9,11,12,10</span></span><br></pre></td></tr></tbody></table></figure><p>再来一段</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2'</span>)</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">}, <span class="number">0</span>)</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">}).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">})</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></tbody></table></figure><h3 id="node-的事件循环"><a href="#node-的事件循环" class="headerlink" title="node 的事件循环"></a>node 的事件循环</h3><ul><li>timers 定时器：本阶段执行已经安排的 setTimeout() 和 setInterval() 的回调函数。</li><li>pending callbacks 待定回调：执行延迟到下一个循环迭代的 I/O 回调。</li><li>idle, prepare：仅系统内部使用。</li><li>poll 轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate() 排定的之外），其余情况 node 将在此处阻塞。</li><li>check 检测：setImmediate() 回调函数在这里执行。</li><li>close callbacks 关闭的回调函数：一些准备关闭的回调函数，如：socket.on(‘close’, …)。</li></ul><h4 id="微任务和宏任务在-Node-的执行顺序"><a href="#微任务和宏任务在-Node-的执行顺序" class="headerlink" title="微任务和宏任务在 Node 的执行顺序"></a>微任务和宏任务在 Node 的执行顺序</h4><p>Node 10 以前：</p><ul><li>执行完一个阶段的所有任务</li><li>执行完 nextTick 队列里面的内容</li><li>然后执行完微任务队列的内容</li></ul><p>Node 11 以后：</p><ul><li>和浏览器的行为统一了，都是每执行一个宏任务就执行完微任务队列。</li></ul><h2 id="node-环境和浏览器的区别"><a href="#node-环境和浏览器的区别" class="headerlink" title="node 环境和浏览器的区别"></a>node 环境和浏览器的区别</h2><h4 id="1、全局环境下-this-的指向"><a href="#1、全局环境下-this-的指向" class="headerlink" title="1、全局环境下 this 的指向"></a>1、全局环境下 this 的指向</h4><ul><li>node 中 this 指向 global</li><li>浏览器中 this 指向 window</li><li>这就是为什么 underscore 中一上来就定义了一 root；</li></ul><p>浏览器中的 window 下封装了不少的 API 比如 alert 、document、location、history 等等还有很多, 我们就不能在 node 环境中 xxx();或 window.xxx();了。因为这些 API 是浏览器级别的封装，存 javascript 中是没有的。当然 node 中也提供了不少 node 特有的 API。</p><h4 id="2、js-引擎"><a href="#2、js-引擎" class="headerlink" title="2、js 引擎"></a>2、js 引擎</h4><ul><li><p>在浏览器中不同的浏览器厂商提供了不同的浏览器内核，浏览器依赖这些内核解释折我们编写的 js。但是考虑到不同内核的少量差异，我们需要对应兼容性好在有一些优秀的库帮助我们处理这个问题。比如 jquery、underscore 等等。</p></li><li><p>nodejs 是基于 Chrome’s JavaScript runtime，也就是说，实际上它是对 GoogleV8 引擎（应用于 Google Chrome 浏览器)进行了封装。V8 引 擎执行 Javascript 的速度非常快，性能非常好。</p></li></ul><h4 id="3、DOM-操作"><a href="#3、DOM-操作" class="headerlink" title="3、DOM 操作"></a>3、DOM 操作</h4><ul><li>浏览器中的 js 大多数情况下是在直接或间接（一些虚拟 DOM 的库和框架）的操作 DOM。因为浏览器中的代码主要是在表现层工作。</li><li>node 是一门服务端技术。没有一个前台页面，所以我们不会再 node 中操作 DOM。</li></ul><h4 id="4、I-O-读写"><a href="#4、I-O-读写" class="headerlink" title="4、I/O 读写"></a>4、I/O 读写</h4><p>与浏览器不同，我们需要像其他服务端技术一样读写文件，nodejs 提供了比较方便的组件。而浏览器（确保兼容性的）想在页面中直接打开一个本地的图片就麻烦了好多（别和我说这还不简单，相对路径。。。。。。试试就知道了要么找个库要么二进制流，要么上传上去有了网络地址在显示。不然人家为什么要搞一个 js 库呢），而这一切 node 都用一个组件搞定了。</p><h4 id="5、模块加载"><a href="#5、模块加载" class="headerlink" title="5、模块加载"></a>5、模块加载</h4><ul><li><p>javascript 有个特点，就是原生没提供包引用的 API 一次性把要加载的东西全执行一遍，这里就要看各位闭包的功力了。所用东西都在一起，没有分而治之，搞的特别没有逻辑性和复用性。如果页面简单或网站当然我们可以通过一些 AMD、CMD 的 js 库（比如 requireJS 和 seaJS）搞定事实上很多大型网站都是这么干的。</p></li><li><p>nodeJS 中提供了 CMD 的模块加载的 API，如果你用过 seaJS，那么应该上手很快。node 还提供了 npm 这种包管理工具，能更有效方便的管理我们饮用的库</p></li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://juejin.im/post/5c337ae06fb9a049bc4cd218">浏览器与Node的事件循环(Event Loop)有何区别?</a>  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/js%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"/>
      <url>2020/12/29/js%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>javascript语言的执行环境是<strong>单线程</strong>（single thread），就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。</p><p>这种模式的好处是实现起来比较简单，执行环境相对单纯；但是只要耗时比较多，假如有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。  </p><ul><li><strong>同步模式</strong>: 就是一个任务先执行，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；</li><li><strong>异步模式</strong>: 每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。  </li></ul><p>Javascript处理异步的方法有以下几种：</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调是一个函数被作为一个参数传递到另一个函数里，在那个函数执行完后再执行。回调函数是异步编程最基本的方法，其优点是简单、容易理解和部署；缺点是容易产生回调地狱。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'XXX1'</span>, <span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="comment">// callback 函数体</span></span><br><span class="line">  ajax(<span class="string">'XXX2'</span>, <span class="function">() =&gt;</span> {</span><br><span class="line">    <span class="comment">// callback 函数体</span></span><br><span class="line">    ajax(<span class="string">'XXX3'</span>, <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="comment">// callback 函数体</span></span><br><span class="line">    })</span><br><span class="line">  })</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>这就是所谓的回调地狱，回调地狱带来的负面作用有以下几点：</p><ul><li>代码臃肿，可读性差，可维护性差。</li><li>代码复用性差。</li><li>容易滋生 bug。</li><li>只能在回调里处理异常。</li></ul><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>这种方式，异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。  </p><ol><li><p>普通方式</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.on(<span class="string">'done'</span>, f2);</span><br></pre></td></tr></tbody></table></figure><p>上面这行代码的意思是，当f1发生done事件，就执行f2。</p></li><li><p>onclick方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">element.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">   <span class="comment">//处理函数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">element.onclick=handler1;</span><br><span class="line">element.onclick=handler2;</span><br><span class="line">element.onclick=handler3;</span><br><span class="line"><span class="comment">// 只有handler3会被添加执行</span></span><br></pre></td></tr></tbody></table></figure></li></ol><ul><li>优点：写法兼容到主流浏览器;</li><li>缺点：当同一个element元素绑定多个事件时，只有最后一个事件会被添加</li></ul><ol start="3"><li>addEvenListener<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">elment.addEvenListener(<span class="string">"click"</span>,handler1,<span class="literal">false</span>);</span><br><span class="line">elment.addEvenListener(<span class="string">"click"</span>,handler2,<span class="literal">false</span>);</span><br><span class="line">elment.addEvenListener(<span class="string">"click"</span>,handler3,<span class="literal">false</span>);</span><br></pre></td></tr></tbody></table></figure>该方法的第三个参数是一个布尔值：当为false时表示由里向外，true表示由外向里。</li></ol><h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h3><p>我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern）  </p><p>首先，f2向信号中心jQuery订阅done信号。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.subscribe(<span class="string">'done'</span>, f2);</span><br></pre></td></tr></tbody></table></figure><p>然后，f1进行如下改写：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    jQuery.publish(<span class="string">'done'</span>);</span><br><span class="line">  }, <span class="number">1000</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>f1执行完成后，向信号中心jQuery发布done信号，从而引发f2的执行。f2完成执行后，可以取消订阅（unsubscribe）</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.unsubscribe(<span class="string">'done'</span>, f2);</span><br></pre></td></tr></tbody></table></figure><p>这种方式的优点：可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>以上都是ES6之前的异步处理方式。ES6之后出现了promise。它是异步编程的一种解决方案，比传统的解决方案(回调函数)——更合理和更强大。  </p><p>Promise 对象有以下两个特点。</p><ol><li>对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果</li></ol><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ol><li>ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>){</span><br><span class="line">    resolve(success)</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    reject(error)</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>Promise接收一个函数作为参数，函数里有resolve和reject两个参数:  </p><ul><li><code>resolve</code>方法的作用是将<code>Promise</code>的<code>pending</code>状态变为<code>fullfilled</code>，在异步操作成功之后调用，可以将异步返回的结果作为参数传递出去。</li><li><code>reject</code>方法的作用是将<code>Promise</code>的<code>pending</code>状态变为<code>rejected</code>，在异步操作失败之后调用，可以将异步返回的结果作为参数传递出去。</li><li>他们之间只能有一个被执行，不会同时被执行，因为Promise只能保持一种状态。</li></ul><ol start="2"><li>Promise 实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function">(<span class="params">success</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 对应于上面的resolve(success)方法</span></span><br><span class="line">}, <span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 对应于上面的reject(error)方法</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以写成这样 (推荐使用这种写法)</span></span><br><span class="line">promise.then(<span class="function">(<span class="params">success</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 对应于上面的resolve(success)方法</span></span><br><span class="line">}).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 对应于上面的reject(error)方法</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><code>then(onfulfilled,onrejected)</code>方法中有两个参数，两个参数都是函数：</p><ul><li>第一个参数执行的是<code>resolve()</code>方法(即异步成功后的回调方法)</li><li>第二参数执行的是<code>reject()</code>方法(即异步失败后的回调方法)(第二个参数可选)。</li><li>它返回的是一个新的Promise对象。  </li></ul><ol start="3"><li>promise构造函数是同步执行的，then方法是异步执行的<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 1  2  4   3</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally()"></a>Promise.finally()</h4><code>Promise.finally()</code>用于指定不管 Promise 对象最后状态如何，都会执行的操作。<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> {···})</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> {···})</span><br><span class="line">.finally(<span class="function">() =&gt;</span> {···});</span><br></pre></td></tr></tbody></table></figure><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><code>Promise.all()</code>用于处理多个异步处理，比如说一个页面上需要等多个 ajax 的数据回来才执行相关逻辑。<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></tbody></table></figure>p的状态由p1、p2、p3决定，分成两种情况。</li></ol><ul><li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li><li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。  </li></ul><h4 id="Promse-race"><a href="#Promse-race" class="headerlink" title="Promse.race()"></a>Promse.race()</h4><p><code>Promse.race()</code>就是赛跑的意思，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3])</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>async/await是JavaScript为了解决异步问题而提出的一种解决方案，许多人将其称为异步的终极解决方案。<strong>async 函数，就是 Generator 函数的语法糖。</strong></p><p>相较于 Generator，Async 函数的改进在于下面四点：</p><ul><li>内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样。</li><li>更好的语义。async 和 await 相较于 * 和 yield 更加语义化。</li><li>更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise对象。而 async 函数的 await 命令后面可以是 Promise 或者原始类型（Number，string，boolean，但这时等同于同步）。</li><li>返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。  </li></ul><h4 id="async-await使用规则"><a href="#async-await使用规则" class="headerlink" title="async/await使用规则"></a>async/await使用规则</h4><ol><li>凡是在前面添加了async的函数在执行后都会自动返回一个Promise对象<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>{</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = test()</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">//即便代码里test函数什么都没返回，我们依然打出了Promise对象</span></span><br></pre></td></tr></tbody></table></figure></li><li>await必须在async函数里使用，不能单独使用<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'success'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">test()   <span class="comment">//执行以后会报错</span></span><br></pre></td></tr></tbody></table></figure><h4 id="await-在等什么"><a href="#await-在等什么" class="headerlink" title="await 在等什么"></a>await 在等什么</h4></li></ol><ul><li>如果await等到的不是一个promise对象，那跟着的表达式的运算结果就是它等到的东西；</li><li>如果是一个promise对象，await会阻塞后面的代码，等promise对象resolve，得到resolve的值作为await表达式的运算结果</li><li>虽然await阻塞了，但await在async中，async不会阻塞，它内部所有的阻塞都被封装在一个promise对象中异步执行</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/js%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
      <url>2020/12/29/js%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-对象创建与拷贝"><a href="#JS-对象创建与拷贝" class="headerlink" title="JS 对象创建与拷贝"></a>JS 对象创建与拷贝</h1><h3 id="五种创建对象的方法"><a href="#五种创建对象的方法" class="headerlink" title="五种创建对象的方法"></a>五种创建对象的方法</h3><p>1、对象字面量的方式</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person = { <span class="attr">firstname</span>: <span class="string">'Mark'</span>, <span class="attr">lastname</span>: <span class="string">'Yun'</span>, <span class="attr">age</span>: <span class="number">25</span>, <span class="attr">eyecolor</span>: <span class="string">'black'</span> }</span><br></pre></td></tr></tbody></table></figure><p>2、用 function 来模拟无参的构造函数</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>{}</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person() <span class="comment">//定义一个function，如果使用new"实例化",该function可以看作是一个Class</span></span><br><span class="line">person.name = <span class="string">'Mark'</span></span><br><span class="line">person.age = <span class="string">'25'</span></span><br><span class="line">person.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  alert(person.name + <span class="string">' hello...'</span>)</span><br><span class="line">}</span><br><span class="line">person.work()</span><br></pre></td></tr></tbody></table></figure><p>3、用 function 来模拟参构造函数来实现（用 this 关键字定义构造的上下文属性）</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pet</span>(<span class="params">name, age, hobby</span>) </span>{</span><br><span class="line">  <span class="built_in">this</span>.name = name <span class="comment">//this作用域：当前对象</span></span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  <span class="built_in">this</span>.hobby = hobby</span><br><span class="line">  <span class="built_in">this</span>.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    alert(<span class="string">'我叫'</span> + <span class="built_in">this</span>.name + <span class="string">',我喜欢'</span> + <span class="built_in">this</span>.hobby + <span class="string">',是个程序员'</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> maidou = <span class="keyword">new</span> Pet(<span class="string">'麦兜'</span>, <span class="number">25</span>, <span class="string">'coding'</span>) <span class="comment">//实例化、创建对象</span></span><br><span class="line">maidou.eat() <span class="comment">//调用eat方法</span></span><br></pre></td></tr></tbody></table></figure><p>4、用工厂方式来创建（内置对象）</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wcDog = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">wcDog.name = <span class="string">'旺财'</span></span><br><span class="line">wcDog.age = <span class="number">3</span></span><br><span class="line">wcDog.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  alert(<span class="string">'我是'</span> + wcDog.name + <span class="string">',汪汪汪......'</span>)</span><br><span class="line">}</span><br><span class="line">wcDog.work()</span><br></pre></td></tr></tbody></table></figure><p>5、用原型方式来创建</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>{}</span><br><span class="line">Dog.prototype.name = <span class="string">'旺财'</span></span><br><span class="line">Dog.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  alert(<span class="built_in">this</span>.name + <span class="string">'是个吃货'</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> wangcai = <span class="keyword">new</span> Dog()</span><br></pre></td></tr></tbody></table></figure><p>合并两个对象</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object1 = { <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> }</span><br><span class="line"><span class="keyword">let</span> object2 = { <span class="attr">b</span>: <span class="number">30</span>, <span class="attr">c</span>: <span class="number">40</span>, <span class="attr">d</span>: <span class="number">50</span> }</span><br><span class="line"><span class="keyword">let</span> merged = { ...object1, ...object2 } <span class="comment">//spread and re-add into merged</span></span><br><span class="line"><span class="built_in">console</span>.log(merged) <span class="comment">// {a:1, b:30, c:40, d:50}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>js 数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和引用数据类型。</p><ul><li>基本数据类型：直接存储在栈(stack)中的数据</li><li>引用数据类型点：存储的是该对象在栈中引用，真实的数据存放在堆内存里</li></ul><p>深拷贝和浅拷贝的主要区别就是在内存中的存储类型不同。堆和栈是内存中划分出来用来存储的区域。</p><ul><li>栈（stack）为自动分配的内存空间，它由系统自动释放。</li><li>堆（heap）则是动态分配的内存，大小不定也不会自动释放。</li></ul><h4 id="数据的比较"><a href="#数据的比较" class="headerlink" title="数据的比较"></a>数据的比较</h4><p>基本类型的比较是值的比较，只要它们的值相等就认为他们是相等的，例如：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(a === b) <span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure><p>而引用类型的比较是引用的比较，所以每次我们对 js 中的引用类型进行操作的时候，都是操作其对象的引用，所以比较两个引用类型，是看其的引用是否指向同一个对象。例如：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a === b) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><h4 id="传值与传址"><a href="#传值与传址" class="headerlink" title="传值与传址"></a>传值与传址</h4><p>基础数据类型的赋值都是属于传值，两个变量是两个独立相互不影响的变量。举个例子；</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line"></span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 10</span></span><br></pre></td></tr></tbody></table></figure><p>但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = {} <span class="comment">// a保存了一个空对象的实例</span></span><br><span class="line"><span class="keyword">var</span> b = a <span class="comment">// a和b都指向了这个空对象</span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">'jozo'</span></span><br><span class="line"><span class="built_in">console</span>.log(a.name) <span class="comment">// 'jozo'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.name) <span class="comment">// 'jozo'</span></span><br><span class="line"></span><br><span class="line">b.age = <span class="number">22</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 22</span></span><br><span class="line"><span class="built_in">console</span>.log(a.age) <span class="comment">// 22</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a == b) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p><p>区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制；</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = {</span><br><span class="line">  name: <span class="string">'Tom'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  hobbies: [<span class="string">'reading'</span>, <span class="string">'photography'</span>]</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> obj1 = obj</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign({}, obj)</span><br><span class="line"><span class="keyword">let</span> obj3 = { ...obj }</span><br><span class="line"><span class="keyword">let</span> obj4 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">'Jack'</span></span><br><span class="line">obj.hobbies.push(<span class="string">'coding'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">//{ name: 'Jack', age: 18,hobbies: [ 'reading', 'photography', 'coding' ] }</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1) <span class="comment">//{ name: 'Jack', age: 18,hobbies: [ 'reading', 'photography', 'coding' ] }</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">//{ name: 'Tom', age: 18,hobbies: [ 'reading', 'photography', 'coding' ] }</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3) <span class="comment">//{ name: 'Tom', age: 18,hobbies: [ 'reading', 'photography', 'coding' ] }</span></span><br><span class="line"><span class="built_in">console</span>.log(obj4) <span class="comment">//{ name: 'Tom', age: 18,hobbies: [ 'reading', 'photography' ] }</span></span><br></pre></td></tr></tbody></table></figure><p>从以上例子可以看出，当数据为引用数据类型时</p><ol><li>直接赋值属于浅拷贝</li><li>Object.assign，当数据第一层为基本数据类型时，新的对象和原对象互不影响，这属于深拷贝，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向的是同一块内存地址，这是浅拷贝。</li><li>扩展运算符和Object.assign原理一样。</li><li>JSON.parse(JSON.stringify(obj))可实现深拷贝</li></ol><h3 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h3><ol><li>JSON.parse(JSON.stringify(obj)) 但存在一些缺陷</li></ol><ul><li>对象的属性值是函数时，无法拷贝。</li><li>原型链上的属性无法拷贝</li><li>不能正确的处理 Date，RegExp 类型的数据</li><li>会忽略 undefined</li></ul><ol start="2"><li>实现一个 deepClone 函数</li></ol><ul><li>如果是基本数据类型，直接返回</li><li>如果是 RegExp 或者 Date 类型，返回对应类型</li><li>如果是复杂数据类型，递归。</li><li>考虑循环引用的问题</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>{</span><br><span class="line">  <span class="comment">//递归拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj)</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj)</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) {</span><br><span class="line">    <span class="comment">//如果不是复杂数据类型，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (hash.has(obj)) {</span><br><span class="line">    <span class="keyword">return</span> hash.get(obj)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果obj是数组，那么 obj.constructor 是 [Function: Array]</span></span><br><span class="line"><span class="comment">   * 如果obj是对象，那么 obj.constructor 是 [Function: Object]</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> t = <span class="keyword">new</span> obj.constructor()</span><br><span class="line">  hash.set(obj, t)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) {</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) {</span><br><span class="line">      <span class="comment">//是否是自身的属性</span></span><br><span class="line">      t[key] = deepClone(obj[key], hash)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> t</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>2020/12/29/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="JS原型和原型链"><a href="#JS原型和原型链" class="headerlink" title="JS原型和原型链"></a>JS原型和原型链</h1><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote><p>每个构造函数(constructor)都有一个原型对象(prototype), 原型对象都包含一个指向构造函数的指针, 而实例(instance)都包含一个指向原型对象的内部指针.</p></blockquote><p>我们先来看一个例子</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>{</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  <span class="built_in">this</span>.job = job</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    alert(<span class="built_in">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Zaxlct'</span>, <span class="number">28</span>, <span class="string">'Engineer'</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Mick'</span>, <span class="number">23</span>, <span class="string">'Doctor'</span>)</span><br></pre></td></tr></tbody></table></figure><p>上面的例子中 person1 和 person2 都是 Person 的实例。这两个实例都有一个 constructor （构造函数）属性，该属性（是一个指针）指向 Person。 即：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor == Person) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor == Person) <span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>每个构造函数都有一个 prototype 属性，指向调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>{}</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'Zaxlct'</span></span><br><span class="line">Person.prototype.age = <span class="number">28</span></span><br><span class="line">Person.prototype.job = <span class="string">'Engineer'</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  alert(<span class="built_in">this</span>.name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line">person1.sayName() <span class="comment">// 'Zaxlct'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</span><br><span class="line">person2.sayName() <span class="comment">// 'Zaxlct'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName) <span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure><h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>这是每一个 JavaScript 对象(除了 null )都具有的一个属性，叫<strong>proto</strong>，这个属性会指向该对象的原型。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>{}</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>每个原型都有一个 constructor 属性指向关联的构造函数</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>{}</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h3 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h3><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>{}</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'Kevin'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">'Daisy'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Daisy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p><p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.<strong>proto</strong> ，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>语法：<code>Object.create(proto, [propertiesObject])</code></p><p>方法创建一个新对象，使用现有的对象来提供新创建的对象的 proto。</p><ul><li>new Object() 通过构造函数来创建对象, 添加的属性是在自身实例下。</li><li>Object.create() es6 创建对象的另一种方式，可以理解为继承一个对象, 添加的属性是在原型下。</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new Object() 方式创建</span></span><br><span class="line"><span class="keyword">var</span> a = { <span class="attr">rep</span>: <span class="string">'apple'</span> }</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Object</span>(a)</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// {rep: "apple"}</span></span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__) <span class="comment">// {}</span></span><br><span class="line"><span class="built_in">console</span>.log(b.rep) <span class="comment">// {rep: "apple"}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.create() 方式创建</span></span><br><span class="line"><span class="keyword">var</span> a = { <span class="attr">rep</span>: <span class="string">'apple'</span> }</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a)</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// {}</span></span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__) <span class="comment">// {rep: "apple"}</span></span><br><span class="line"><span class="built_in">console</span>.log(b.rep) <span class="comment">// {rep: "apple"}</span></span><br></pre></td></tr></tbody></table></figure><p>经典面试题</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = { <span class="attr">name</span>: <span class="string">'one'</span> }</span><br><span class="line">obj2 = <span class="built_in">Object</span>.create(obj1)</span><br><span class="line">obj2.name = <span class="string">'two'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.name)</span><br><span class="line"><span class="comment">//one</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = { <span class="attr">prop</span>: { <span class="attr">name</span>: <span class="string">'one'</span> } }</span><br><span class="line">obj2 = <span class="built_in">Object</span>.create(obj1)</span><br><span class="line">obj2.prop.name = <span class="string">'two'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.prop.name)</span><br><span class="line"><span class="comment">//two</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = { <span class="attr">list</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>] }</span><br><span class="line">obj2 = <span class="built_in">Object</span>.create(obj1)</span><br><span class="line">obj2.list[<span class="number">0</span>] = <span class="string">'two'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.list[<span class="number">0</span>])</span><br><span class="line"><span class="comment">//two</span></span><br></pre></td></tr></tbody></table></figure><ul><li>第二题先计算 obj2.prop 的值，在原型链中被发现，然后再计算 obj2.prop 对应的对象(不检查原型链)中是否存在 name 属性。</li><li>第三题是先计算 obj2.list 属性的值，然后赋值给 obj2.list 属性下标为 0（属性名为“0”）的属性。</li></ul><h3 id="私有变量、函数"><a href="#私有变量、函数" class="headerlink" title="私有变量、函数"></a>私有变量、函数</h3><p>在函数内部定义的变量和函数如果不对外提供接口，那么外部将无法访问到，也就是变为私有变量和私有函数。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span> <span class="comment">//私有变量</span></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">//私有函数</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Obj()</span><br><span class="line"><span class="built_in">console</span>.log(o.a) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(o.fn) <span class="comment">//undefined</span></span><br></pre></td></tr></tbody></table></figure><h3 id="静态变量、函数"><a href="#静态变量、函数" class="headerlink" title="静态变量、函数"></a>静态变量、函数</h3><p>当定义一个函数后通过 “.”为其添加的属性和函数，通过对象本身仍然可以访问得到，但是其实例却访问不到，这样的变量和函数分别被称为静态变量和静态函数。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params"></span>) </span>{}</span><br><span class="line">  Obj.a = <span class="number">0</span> <span class="comment">//静态变量</span></span><br><span class="line">  Obj.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">//静态函数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Obj.a) <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Obj.fn) <span class="comment">//function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Obj()</span><br><span class="line"><span class="built_in">console</span>.log(o.a) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o.fn) <span class="comment">//undefined</span></span><br></pre></td></tr></tbody></table></figure><h3 id="实例变量、函数"><a href="#实例变量、函数" class="headerlink" title="实例变量、函数"></a>实例变量、函数</h3><p>在面向对象编程中除了一些库函数我们还是希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，JavaScript也能做到这样。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">this</span>.a=[]; <span class="comment">//实例变量</span></span><br><span class="line">    <span class="built_in">this</span>.fn=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ <span class="comment">//实例方法    </span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Obj.a); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Obj.fn); <span class="comment">//undefined</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> o=<span class="keyword">new</span> Obj();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o.a); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o.fn); <span class="comment">//function</span></span><br></pre></td></tr></tbody></table></figure><h3 id="一道综合面试题"><a href="#一道综合面试题" class="headerlink" title="一道综合面试题"></a>一道综合面试题</h3><p>题目如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>{</span><br><span class="line">  getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    alert(<span class="number">1</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">}</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  alert(<span class="number">2</span>)</span><br><span class="line">}</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  alert(<span class="number">3</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  alert(<span class="number">4</span>)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>{</span><br><span class="line">  alert(<span class="number">5</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//请写出以下输出结果：</span></span><br><span class="line">Foo.getName()</span><br><span class="line">getName()</span><br><span class="line">Foo().getName()</span><br><span class="line">getName()</span><br><span class="line"><span class="keyword">new</span> Foo.getName()</span><br><span class="line"><span class="keyword">new</span> Foo().getName()</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName()</span><br></pre></td></tr></tbody></table></figure><p>解读：首先定义了一个叫 Foo 的函数，之后为 Foo 创建了一个叫 getName 的静态属性存储了一个匿名函数，之后为 Foo 的原型对象新创建了一个叫 getName 的匿名函数。之后又通过函数变量表达式创建了一个 getName 的函数，最后再声明一个叫 getName 函数。</p><p>先来剧透一下答案，再来看看具体分析</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//答案：</span></span><br><span class="line">Foo.getName() <span class="comment">//2</span></span><br><span class="line">getName() <span class="comment">//4</span></span><br><span class="line">Foo().getName() <span class="comment">//1</span></span><br><span class="line">getName() <span class="comment">//1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName() <span class="comment">//2</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName() <span class="comment">//3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName() <span class="comment">//3</span></span><br></pre></td></tr></tbody></table></figure><ol><li>第一问:Foo.getName 自然是访问 Foo 函数上存储的静态属性，自然是 2</li><li>第二问，直接调用 getName 函数。既然是直接调用那么就是访问当前上文作用域内的叫 getName 的函数，所以跟 1 2 3 都没什么关系。但是此处有两个坑，一是变量声明提升，二是函数表达式。<br>关于函数变量提示，此处省略一万字。。。。题中代码最终执行时的是</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>{</span><br><span class="line">  getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    alert(<span class="number">1</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> getName <span class="comment">//只提升变量声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>{</span><br><span class="line">  alert(<span class="number">5</span>)</span><br><span class="line">} <span class="comment">//提升函数声明，覆盖var的声明</span></span><br><span class="line"></span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  alert(<span class="number">2</span>)</span><br><span class="line">}</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  alert(<span class="number">3</span>)</span><br><span class="line">}</span><br><span class="line">getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  alert(<span class="number">4</span>)</span><br><span class="line">} <span class="comment">//最终的赋值再次覆盖function getName声明</span></span><br><span class="line"></span><br><span class="line">getName() <span class="comment">//最终输出4</span></span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>第三问的 Foo().getName(); 先执行了 Foo 函数，然后调用 Foo 函数的返回值对象的 getName 属性函数。这里 Foo 函数的返回值是 this，this 指向 window 对象。所以第三问相当于执行 window.getName()。 然而这里 Foo 函数将此变量的值赋值为<code>function(){alert(1)}</code>。</li><li>第四问直接调用 getName 函数，相当于 window.getName()，答案和前面一样。</li><li>后面三问都是考察 js 的运算符优先级问题。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/29/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E9%97%AD%E5%8C%85/"/>
      <url>2020/12/29/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-作用域与闭包"><a href="#JS-作用域与闭包" class="headerlink" title="JS 作用域与闭包"></a>JS 作用域与闭包</h1><h3 id="JS-作用域"><a href="#JS-作用域" class="headerlink" title="JS 作用域"></a>JS 作用域</h3><p>Javascript 变量的作用域无非就是两种：<strong>全局变量和局部变量</strong>。Javascript 语言的特殊之处，就在于函数内部可以直接读取全局变量。</p><h4 id="全局作用域-Global-Scope"><a href="#全局作用域-Global-Scope" class="headerlink" title="全局作用域(Global Scope)"></a>全局作用域(Global Scope)</h4><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说一下几种情形拥有全局作用域：</p><ol><li>最外层函数和在最外层函数外面定义的变量拥有全局作用域</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Jack'</span> <span class="comment">// 全局定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">23</span> <span class="comment">// 局部定义</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">// 局部函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(age) <span class="comment">//age 23</span></span><br><span class="line">  }</span><br><span class="line">  inner()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// yuan</span></span><br><span class="line"><span class="built_in">console</span>.log(age) <span class="comment">// Uncaught ReferenceError: age is not defined，在外部没有这个变量</span></span><br><span class="line">foo() <span class="comment">// 内嵌函数的打印23</span></span><br><span class="line">inner() <span class="comment">// Uncaught ReferenceError: inner is not defined 因为内嵌函数，找不到这个函数</span></span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'yuan'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>{</span><br><span class="line">  age = <span class="number">23</span> <span class="comment">// 全局定义</span></span><br><span class="line">  <span class="keyword">var</span> sex = <span class="string">'male'</span> <span class="comment">// 局部定义</span></span><br><span class="line">}</span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">console</span>.log(age) <span class="comment">//  23</span></span><br><span class="line"><span class="built_in">console</span>.log(sex) <span class="comment">// sex is not defined</span></span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>所有 window 对象的属性拥有全局作用域<br>一般情况下，window 对象的内置属性都都拥有全局作用域，例如 window.alert()、window.location、window.top 等等。</li></ol><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（作用域形成的链条）</p><ol><li>作用域链的前端，始终都是当前执行的代码所在环境的变量对象</li><li>作用域链中的下一个对象来自于外部环境，而在下一个变量对象则来自下一个外部环境，一直到全局执行环境</li><li>全局执行环境的变量对象始终都是作用域链上的最后一个对象</li></ol><p>当在内部函数中，需要访问一个变量的时候，首先会访问函数本身的变量对象，是否有这个变量，如果没有，那么会继续沿作用域链往上查找，直到全局作用域。如果在某个变量对象中找到则使用该变量对象中的变量值。</p><h4 id="内部环境可以通过作用域链访问所有外部环境，但外部环境不能访问内部环境的任何变量和函数。"><a href="#内部环境可以通过作用域链访问所有外部环境，但外部环境不能访问内部环境的任何变量和函数。" class="headerlink" title="内部环境可以通过作用域链访问所有外部环境，但外部环境不能访问内部环境的任何变量和函数。"></a>内部环境可以通过作用域链访问所有外部环境，但外部环境不能访问内部环境的任何变量和函数。</h4><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>ES6 之前我们一般使用 var 来声明变量，变量提升如下例子：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">//undefined</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 它的实际执行顺序如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> a</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  a = <span class="number">123</span></span><br><span class="line">}</span><br><span class="line">test()</span><br></pre></td></tr></tbody></table></figure><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>javascript 中不仅仅是变量声明有提升的现象，函数的声明也是一样。具名函数的声明有两种方式：</p><ul><li>函数声明式</li><li>函数字面量式</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>{}</span><br><span class="line"><span class="comment">//函数字面量式</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{}</span><br></pre></td></tr></tbody></table></figure><p>函数提升是整个代码块提升到它所在的作用域的最开始执行</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(bar)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>) <span class="comment">//ƒ bar () { console.log(1)}</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际执行顺序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(bar)</span><br></pre></td></tr></tbody></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包就是能够读取其他函数内部变量的函数，函数没有被释放，整条作用域链上的局部变量都将得到保留。由于在 javascript 语言中，只有函数内部的子函数才能读取局部变量，<strong>因此可以把闭包简单理解成“定义在一个函数内部的函数”</strong>。</p><h4 id="产生一个闭包"><a href="#产生一个闭包" class="headerlink" title="产生一个闭包"></a>产生一个闭包</h4><p>创建闭包最常见方式，就是在一个函数内部创建另一个函数。闭包的作用域链包含着它自己的作用域，以及包含它的函数的作用域和全局作用域。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> f1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面例子中的 f1 就是一个闭包</p><h4 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h4><ol><li><p>设计私有的方法和变量。<br>任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数外部访问这些变量。私有变量包括函数的参数、局部变量和函数内定义的其他函数。</p><p>把有权访问私有变量的公有方法称为特权方法（privileged method）。</p></li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="comment">// 私有变量</span></span><br><span class="line">  <span class="keyword">var</span> series = <span class="string">'哺乳动物'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Run!!!'</span>)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 特权方法</span></span><br><span class="line">  <span class="built_in">this</span>.getSeries = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> series</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>匿名函数最大的用途是创建闭包。减少全局变量的使用。从而使用闭包模块化代码，减少全局变量的污染。</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objEvent = objEvent || {}</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  }</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  objEvent.addEvent = addEvent</span><br><span class="line">  objEvent.removeEvent = removeEvent</span><br><span class="line">})()</span><br></pre></td></tr></tbody></table></figure><p>addEvent 和 removeEvent 都是局部变量，但我们可以通过全局变量 objEvent 使用它，这就大大减少了全局变量的使用，增强了网页的安全性。</p><ol start="3"><li><p>定义模块，我们将操作函数暴露给外部，而细节隐藏在模块内部。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module</span>(<span class="params"></span>) </span>{</span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">val</span>) </span>{</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> val == <span class="string">'number'</span>) {</span><br><span class="line">arr.push(val);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">index</span>) </span>{</span><br><span class="line"><span class="keyword">if</span> (index &lt; arr.length) {</span><br><span class="line"><span class="keyword">return</span> arr[index]</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> {</span><br><span class="line">add: add,</span><br><span class="line">get: get</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> mod1 = <span class="built_in">module</span>();</span><br><span class="line">mod1.add(<span class="number">1</span>);</span><br><span class="line">mod1.add(<span class="number">2</span>);</span><br><span class="line">mod1.add(<span class="string">'xxx'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mod1.get(<span class="number">2</span>));</span><br></pre></td></tr></tbody></table></figure><h4 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h4></li><li><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法时，在退出函数之前，将不使用的局部变量全部删除。</p></li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>)) <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)) <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放对闭包的引用</span></span><br><span class="line">add5 = <span class="literal">null</span></span><br><span class="line">add10 = <span class="literal">null</span></span><br></pre></td></tr></tbody></table></figure><p>add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。最后通过 null 释放了 add5 和 add10 对闭包的引用。</p><ol start="2"><li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象(object)使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这时一定要小心，不要随便改变父函数内部变量的值。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue 组件下拉加载更多</title>
      <link href="2020/12/29/Vue%20%E7%BB%84%E4%BB%B6%E4%B8%8B%E6%8B%89%20%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A/"/>
      <url>2020/12/29/Vue%20%E7%BB%84%E4%BB%B6%E4%B8%8B%E6%8B%89%20%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="一、新建一个loadingMessage组件"><a href="#一、新建一个loadingMessage组件" class="headerlink" title="一、新建一个loadingMessage组件"></a>一、新建一个loadingMessage组件</h2><h3 id="1-1-监听滑动"><a href="#1-1-监听滑动" class="headerlink" title="1.1 监听滑动"></a>1.1 监听滑动</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="1-1-挂载监听"><a href="#1-1-挂载监听" class="headerlink" title="1.1 挂载监听"></a>1.1 挂载监听</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mounted() {</span><br><span class="line">    this.$refs.content.scrollTag = 0; // 标记监听数</span><br><span class="line">    // 挂载监听</span><br><span class="line">    this.listenerScroll();</span><br><span class="line">  },</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2-加载数据时候设置高度"><a href="#1-2-加载数据时候设置高度" class="headerlink" title="1.2 加载数据时候设置高度"></a>1.2 加载数据时候设置高度</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updated() {</span><br><span class="line">  this.scrollHeight = this.$refs.content.scrollHeight; // 加载数据时设置滚动内容高</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3-离开页面销毁监听组件"><a href="#1-3-离开页面销毁监听组件" class="headerlink" title="1.3 离开页面销毁监听组件"></a>1.3 离开页面销毁监听组件</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeDestroy() {</span><br><span class="line">  this.destroyScroll()</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3-watch-监听，滑动到顶部事件"><a href="#1-3-watch-监听，滑动到顶部事件" class="headerlink" title="1.3 watch 监听，滑动到顶部事件"></a>1.3 watch 监听，滑动到顶部事件</h3>   <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">watch: {</span><br><span class="line">  scrollHeight: function(newHeight,oldHeight){ // 加载数据时设置滚动条</span><br><span class="line">    if(this.scrollTop === 0){ // scrollTop 为0时说明时下拉加载操作</span><br><span class="line">      this.$refs.content.scrollTop = newHeight - oldHeight;</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  interlocutor: function(){</span><br><span class="line">    this.scrollToBottom();  // 滚动条至底</span><br><span class="line">    this.listenerScroll();  // 重现挂载监听</span><br><span class="line">  },</span><br><span class="line">  loadingStatus: function(newStatus,oldStatus) { // 加载完全部数据时移除滚动条监听</span><br><span class="line">    if(newStatus === 2){</span><br><span class="line">      this.destroyScroll();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><h3 id="1-4-监听-滑动-滚动事件"><a href="#1-4-监听-滑动-滚动事件" class="headerlink" title="1.4  监听 滑动 滚动事件"></a>1.4  监听 滑动 滚动事件</h3>  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">methods: {</span><br><span class="line">  // 滚动监听处理</span><br><span class="line">  handleScroll(e){</span><br><span class="line">    this.scrollTop = e.srcElement.scrollTop; // 距离顶部</span><br><span class="line">    this.scrollHeight = e.srcElement.scrollHeight; // 滚动内容高</span><br><span class="line">    this.clientHeight = e.srcElement.clientHeight; // 滚动区域高</span><br><span class="line">    if(this.scrollTop ===  0) { // 滚动触顶调用</span><br><span class="line">      this.$emit('onTouchTop');</span><br><span class="line">    }</span><br><span class="line">    if(this.scrollHeight === this.scrollTop + this.clientHeight){ // 滚动触底调用</span><br><span class="line">      this.$emit('onTouchBottom');</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  // 添加滚动监听事件</span><br><span class="line">  listenerScroll() {</span><br><span class="line">    if(this.$refs.content.scrollTag !== 0) return;</span><br><span class="line">    this.$refs.content.scrollTag++;</span><br><span class="line">    this.$refs.content.addEventListener('scroll', this.handleScroll, true);</span><br><span class="line">  },</span><br><span class="line">  // 移除滚动监听事件</span><br><span class="line">  destroyScroll() {</span><br><span class="line">    if(this.$refs.content.scrollTag !== 1) return;</span><br><span class="line">    this.$refs.content.scrollTag--;</span><br><span class="line">    this.$refs.content.removeEventListener("scroll", this.handleScroll, true);</span><br><span class="line">  },</span><br><span class="line">  scrollToBottom() { //滚动条置底</span><br><span class="line">    this.$nextTick(function(){</span><br><span class="line">      this.$refs.content.scrollTop</span><br><span class="line">        = this.$refs.content.scrollHeight - this.$refs.content.clientHeight;</span><br><span class="line">    })</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="2020/12/26/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E7%AE%80%E7%89%88%E6%9C%AC/"/>
      <url>2020/12/26/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E7%AE%80%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="一、CSS相关"><a href="#一、CSS相关" class="headerlink" title="一、CSS相关"></a>一、CSS相关</h2><h3 id="1-1-左边定宽，右边自适应方案：float-margin，float-calc"><a href="#1-1-左边定宽，右边自适应方案：float-margin，float-calc" class="headerlink" title="1.1 左边定宽，右边自适应方案：float + margin，float + calc"></a>1.1 左边定宽，右边自适应方案：float + margin，float + calc</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方案1 */</span> </span><br><span class="line"><span class="selector-class">.left</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">120px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 方案2 */</span> </span><br><span class="line"><span class="selector-class">.left</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">120px</span>);</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2-左右两边定宽，中间自适应：float，float-calc-圣杯布局（设置BFC，margin负值法），flex"><a href="#1-2-左右两边定宽，中间自适应：float，float-calc-圣杯布局（设置BFC，margin负值法），flex" class="headerlink" title="1.2 左右两边定宽，中间自适应：float，float + calc, 圣杯布局（设置BFC，margin负值法），flex"></a>1.2 左右两边定宽，中间自适应：float，float + calc, 圣杯布局（设置BFC，margin负值法），flex</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.wrap</span> &gt; <span class="selector-tag">div</span> {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 方案1 */</span></span><br><span class="line"><span class="selector-class">.left</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">120px</span>; </span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 方案2 */</span></span><br><span class="line"><span class="selector-class">.left</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">240px</span>);</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">120px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 方案3 */</span></span><br><span class="line"><span class="selector-class">.wrap</span> {</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.left</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3-左右居中"><a href="#1-3-左右居中" class="headerlink" title="1.3 左右居中"></a>1.3 左右居中</h3><ul><li>行内元素: <code>text-align: center</code></li><li>定宽块状元素: 左右 <code>margin</code> 值为 <code>auto</code></li><li>不定宽块状元素: <code>table</code>布局，<code>position + transform</code></li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方案1 */</span></span><br><span class="line"><span class="selector-class">.wrap</span> {</span><br><span class="line">  <span class="attribute">text-align</span>: center</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">  <span class="comment">/* or */</span></span><br><span class="line">  <span class="comment">/* display: inline-block; */</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 方案2 */</span></span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 方案2 */</span></span><br><span class="line"><span class="selector-class">.wrap</span> {</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">position</span>: absulote;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-4-上下垂直居中"><a href="#1-4-上下垂直居中" class="headerlink" title="1.4 上下垂直居中"></a>1.4 上下垂直居中</h3><ul><li>定高：<code>margin</code>，<code>position + margin</code>(负值)</li><li>不定高：<code>position</code> + <code>transform</code>，<code>flex</code>，<code>IFC + vertical-align:middle</code></li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定高方案1 */</span></span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span> <span class="number">0</span>;   </span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 定高方案2 */</span></span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">25px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 不定高方案1 */</span></span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 不定高方案2 */</span></span><br><span class="line"><span class="selector-class">.wrap</span> {</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 不定高方案3 */</span></span><br><span class="line"><span class="comment">/* 设置 inline-block 则会在外层产生 IFC，高度设为 100% 撑开 wrap 的高度 */</span></span><br><span class="line"><span class="selector-class">.wrap</span><span class="selector-pseudo">::before</span> {</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.wrap</span> {</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">display</span>: inline-block;  </span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-5-盒模型：content（元素内容）-padding（内边距）-border（边框）-margin（外边距）"><a href="#1-5-盒模型：content（元素内容）-padding（内边距）-border（边框）-margin（外边距）" class="headerlink" title="1.5 盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距）"></a>1.5 盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距）</h3><blockquote><p>延伸： <code>box-sizing</code></p></blockquote><ul><li><code>content-box</code>：默认值，总宽度 = <code>margin</code> + <code>border</code> + <code>padding</code> + <code>width</code></li><li><code>border-box</code>：盒子宽度包含 <code>padding</code> 和 <code>border</code>，<code>总宽度 = margin + width</code></li><li><code>inherit</code>：从父元素继承 <code>box-sizing</code> 属性</li></ul><h3 id="1-6-BFC、IFC、GFC、FFC：FC（Formatting-Contexts），格式化上下文"><a href="#1-6-BFC、IFC、GFC、FFC：FC（Formatting-Contexts），格式化上下文" class="headerlink" title="1.6 BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文"></a>1.6 BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文</h3><blockquote><p><code>BFC</code>：块级格式化上下文，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此(按照这个理念来想，只要脱离文档流，肯定就能产生 <code>BFC</code>)。产生 <code>BFC</code> 方式如下</p></blockquote><ul><li><code>float</code> 的值不为 <code>none</code>。</li><li><code>overflow</code> 的值不为 <code>visible</code>。</li><li><code>position</code> 的值不为 <code>relative</code> 和 <code>static</code>。</li><li><code>display</code> 的值为 <code>table-cell</code>, <code>table-caption</code>, <code>inline-block</code>中的任何一个</li></ul><blockquote><p>用处？常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行</p></blockquote><blockquote><p><code>IFC</code>：内联格式化上下文，<code>IFC</code> 的 <code>line</code> <code>box</code>（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 <code>padding/margin</code> 影响)。</p></blockquote><blockquote><p><code>IFC</code>中的<code>line box</code>一般左右都贴紧整个 <code>IFC</code>，但是会因为 <code>float</code> 元素而扰乱。<code>float</code> 元素会位于 IFC 与 <code>line box</code> 之间，使得 <code>line box</code> 宽度缩短。 同个 <code>ifc</code> 下的多个 <code>line box</code> 高度会不同。 <code>IFC</code>中时不可能有块级元素的，当插入块级元素时（如 <code>p</code> 中插入 <code>div </code>）会产生两个匿名块与 <code>div</code> 分隔开，即产生两个 <code>IFC</code> ，每个 <code>IFC</code> 对外表现为块级元素，与 <code>div</code> 垂直排列。</p></blockquote><p>用处？</p><ul><li>水平居中：当一个块要在环境中水平居中时，设置其为 <code>inline-block</code> 则会在外层产生<code>IFC</code>，通过 <code>text-align</code> 则可以使其水平居中。</li><li>垂直居中：创建一个 <code>IFC</code>，用其中一个元素撑开父元素的高度，然后设置其 <code>vertical-align</code>: <code>middle</code>，其他行内元素则可以在此父元素下垂直居中</li></ul><blockquote><ul><li><strong>GFC</strong>：网格布局格式化上下文（<code>display: grid</code>）</li><li><strong>FFC</strong>：自适应格式化上下文（<code>display: flex</code>）</li></ul></blockquote><h2 id="二、JS-基础（ES5）"><a href="#二、JS-基础（ES5）" class="headerlink" title="二、JS 基础（ES5）"></a>二、JS 基础（ES5）</h2><h3 id="2-1-原型"><a href="#2-1-原型" class="headerlink" title="2.1 原型"></a>2.1 原型</h3><blockquote><p>这里可以谈很多，只要围绕 <code>[[ prototype ]]</code> 谈，都没啥问题</p></blockquote><h3 id="2-2-闭包"><a href="#2-2-闭包" class="headerlink" title="2.2 闭包"></a>2.2 闭包</h3><blockquote><p>牵扯作用域，可以两者联系起来一起谈</p></blockquote><h3 id="2-3-作用域"><a href="#2-3-作用域" class="headerlink" title="2.3 作用域"></a>2.3 作用域</h3><blockquote><p>词法作用域，动态作用域</p></blockquote><h3 id="2-4-this"><a href="#2-4-this" class="headerlink" title="2.4 this"></a>2.4 this</h3><blockquote><p>不同情况的调用，<code>this</code>指向分别如何。顺带可以提一下 <code>es6</code> 中箭头函数没有 <code>this</code>, <code>arguments</code>, <code>super</code> 等，这些只依赖包含箭头函数最接近的函数</p></blockquote><h3 id="2-5-call，apply，bind-三者用法和区别"><a href="#2-5-call，apply，bind-三者用法和区别" class="headerlink" title="2.5 call，apply，bind 三者用法和区别"></a>2.5 call，apply，bind 三者用法和区别</h3><blockquote><p>参数、绑定规则（显示绑定和强绑定），运行效率（最终都会转换成一个一个的参数去运行）、运行情况（<code>call</code>，<code>apply</code> 立即执行，<code>bind</code> 是<code>return</code> 出一个 <code>this</code> “固定”的函数，这也是为什么 <code>bind</code> 是强绑定的一个原因）</p></blockquote><blockquote><p>注：“固定”这个词的含义，它指的固定是指只要传进去了 <code>context</code>，则 <code>bind</code> 中 <code>return</code> 出来的函数 <code>this</code> 便一直指向 <code>context</code>，除非 <code>context</code> 是个变量</p></blockquote><h3 id="2-6-变量声明提升"><a href="#2-6-变量声明提升" class="headerlink" title="2.6 变量声明提升"></a>2.6 变量声明提升</h3><blockquote><p><code>js</code> 代码在运行前都会进行 <code>AST</code> 解析，函数申明默认会提到当前作用域最前面，变量申明也会进行提升。但赋值不会得到提升。关于 <code>AST</code> 解析，这里也可以说是形成词法作用域的主要原因</p></blockquote><h2 id="三、JS-基础（ES6）"><a href="#三、JS-基础（ES6）" class="headerlink" title="三、JS 基础（ES6）"></a>三、JS 基础（ES6）</h2><h3 id="3-1-let，const"><a href="#3-1-let，const" class="headerlink" title="3.1 let，const"></a>3.1 let，const</h3><blockquote><p><code>let</code> 产生块级作用域（通常配合 <code>for</code> 循环或者 <code>{}</code> 进行使用产生块级作用域），<code>const</code> 申明的变量是常量（内存地址不变）</p></blockquote><h3 id="3-2-Promise"><a href="#3-2-Promise" class="headerlink" title="3.2 Promise"></a>3.2 Promise</h3><blockquote><p>这里你谈 <code>promise</code>的时候，除了将他解决的痛点以及常用的 <code>API</code> 之外，最好进行拓展把 <code>eventloop</code> 带进来好好讲一下，<code>microtask</code>(微任务)、<code>macrotask</code>(任务) 的执行顺序，如果看过 <code>promise</code> 源码，最好可以谈一谈 原生 <code>Promise</code> 是如何实现的。<code>Promise</code> 的关键点在于<code>callback</code> 的两个参数，一个是 <code>resovle</code>，一个是 <code>reject</code>。还有就是 <code>Promise</code> 的链式调用（<code>Promise.then()</code>，每一个 <code>then</code> 都是一个责任人）</p></blockquote><h3 id="3-3-Generator"><a href="#3-3-Generator" class="headerlink" title="3.3 Generator"></a>3.3 Generator</h3><blockquote><p>遍历器对象生成函数，最大的特点是可以交出函数的执行权</p></blockquote><ul><li><code>function</code> 关键字与函数名之间有一个星号；</li><li>函数体内部使用 <code>yield</code>表达式，定义不同的内部状态；</li><li><code>next </code>指针移向下一个状态</li></ul><blockquote><p>这里你可以说说 <code>Generator</code>的异步编程，以及它的语法糖 <code>async</code> 和 <code>awiat</code>，传统的异步编程。<code>ES6</code> 之前，异步编程大致如下</p></blockquote><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li></ul><blockquote><p>传统异步编程方案之一：协程，多个线程互相协作，完成异步任务。</p></blockquote><h3 id="3-4-async、await"><a href="#3-4-async、await" class="headerlink" title="3.4 async、await"></a>3.4 async、await</h3><blockquote><p><code>Generator</code> 函数的语法糖。有更好的语义、更好的适用性、返回值是 <code>Promise</code>。</p></blockquote><ul><li><code>async =&gt; *</code></li><li><code>await =&gt; yield</code></li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span> (<span class="params">ms</span>) </span>{</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms)    </span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncConsole</span> (<span class="params">value, ms</span>) </span>{</span><br><span class="line">  <span class="keyword">await</span> timeout(ms)</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">}</span><br><span class="line">asyncConsole(<span class="string">'hello async and await'</span>, <span class="number">1000</span>)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注：最好把2，3，4 连到一起讲</p></blockquote><h3 id="3-5-AMD，CMD，CommonJs，ES6-Module：解决原始无模块化的痛点"><a href="#3-5-AMD，CMD，CommonJs，ES6-Module：解决原始无模块化的痛点" class="headerlink" title="3.5 AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点"></a>3.5 AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点</h3><ul><li><strong>AMD</strong>：<code>requirejs</code> 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置</li><li><strong>CMD</strong>：<code>seajs</code> 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近</li><li><strong>CommonJs</strong>：模块输出的是一个值的 <code>copy</code>，运行时加载，加载的是一个对象（<code>module.exports</code> 属性），该对象只有在脚本运行完才会生成</li><li><strong>ES6 Module</strong>：模块输出的是一个值的引用，编译时输出接口，<code>ES6</code>模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li></ul><h2 id="四、框架相关"><a href="#四、框架相关" class="headerlink" title="四、框架相关"></a>四、框架相关</h2><h3 id="4-1-数据双向绑定原理：常见数据绑定的方案"><a href="#4-1-数据双向绑定原理：常见数据绑定的方案" class="headerlink" title="4.1 数据双向绑定原理：常见数据绑定的方案"></a>4.1 数据双向绑定原理：常见数据绑定的方案</h3><ul><li><code>Object.defineProperty（vue）</code>：劫持数据的 <code>getter</code> 和 <code>setter</code></li><li>脏值检测（<code>angularjs</code>）：通过特定事件进行轮循<br>发布/订阅模式：通过消息发布并将消息进行订阅</li></ul><h3 id="4-2-VDOM：三个-part"><a href="#4-2-VDOM：三个-part" class="headerlink" title="4.2 VDOM：三个 part"></a>4.2 VDOM：三个 part</h3><ul><li>虚拟节点类，将真实 <code>DOM </code>节点用 <code>js</code> 对象的形式进行展示，并提供 <code>render</code> 方法，将虚拟节点渲染成真实 <code>DOM</code></li><li>节点 <code>diff</code> 比较：对虚拟节点进行 <code>js</code> 层面的计算，并将不同的操作都记录到 <code>patch</code> 对象</li><li><code>re-render</code>：解析 <code>patch</code> 对象，进行 <code>re-render</code></li></ul><p><strong>补充1：VDOM 的必要性？</strong></p><ul><li><strong>创建真实DOM的代价高</strong>：真实的 <code>DOM</code> 节点 <code>node</code> 实现的属性很多，而 <code>vnode</code> 仅仅实现一些必要的属性，相比起来，创建一个 <code>vnode</code> 的成本比较低。</li><li><strong>触发多次浏览器重绘及回流</strong>：使用 <code>vnode</code> ，相当于加了一个缓冲，让一次数据变动所带来的所有 <code>node</code> 变化，先在 <code>vnode</code> 中进行修改，然后 <code>diff</code> 之后对所有产生差异的节点集中一次对 <code>DOM tree</code> 进行修改，以减少浏览器的重绘及回流。</li></ul><p><strong>补充2：vue 为什么采用 vdom？</strong></p><blockquote><p>引入 <code>Virtual DOM</code> 在性能方面的考量仅仅是一方面。</p></blockquote><ul><li>性能受场景的影响是非常大的，不同的场景可能造成不同实现方案之间成倍的性能差距，所以依赖细粒度绑定及 <code>Virtual DOM</code> 哪个的性能更好还真不是一个容易下定论的问题。</li><li><code>Vue</code> 之所以引入了 <code>Virtual DOM</code>，更重要的原因是为了解耦 <code>HTML</code>依赖，这带来两个非常重要的好处是：</li></ul><blockquote><ul><li>不再依赖 <code>HTML</code> 解析器进行模版解析，可以进行更多的 <code>AOT</code> 工作提高运行时效率：通过模版 <code>AOT</code> 编译，<code>Vue</code> 的运行时体积可以进一步压缩，运行时效率可以进一步提升；</li><li>可以渲染到 <code>DOM</code> 以外的平台，实现 <code>SSR</code>、同构渲染这些高级特性，<code>Weex</code>等框架应用的就是这一特性。</li></ul></blockquote><blockquote><p>综上，<code>Virtual DOM</code> 在性能上的收益并不是最主要的，更重要的是它使得 <code>Vue</code> 具备了现代框架应有的高级特性。</p></blockquote><h3 id="4-3-vue-和-react-区别"><a href="#4-3-vue-和-react-区别" class="headerlink" title="4.3 vue 和 react 区别"></a>4.3 vue 和 react 区别</h3><ul><li>相同点：都支持 <code>ssr</code>，都有 <code>vdom</code>，组件化开发，实现 <code>webComponents</code> 规范，数据驱动等</li><li>不同点：<code>vue</code> 是双向数据流（当然为了实现单数据流方便管理组件状态，<code>vuex</code> 便出现了），<code>react</code> 是单向数据流。<code>vue </code>的 <code>vdom</code> 是追踪每个组件的依赖关系，不会渲染整个组件树，<code>react</code> 每当应该状态被改变时，全部子组件都会 <code>re-render</code></li></ul><h3 id="4-4-为什么用-vue"><a href="#4-4-为什么用-vue" class="headerlink" title="4.4 为什么用 vue"></a>4.4 为什么用 vue</h3><blockquote><p>简洁、轻快、舒服</p></blockquote><h2 id="五、网络基础类"><a href="#五、网络基础类" class="headerlink" title="五、网络基础类"></a>五、网络基础类</h2><h3 id="5-1-跨域"><a href="#5-1-跨域" class="headerlink" title="5.1 跨域"></a>5.1 跨域</h3><blockquote><p>很多种方法，但万变不离其宗，都是为了搞定同源策略。重用的有 <code>jsonp</code>、<code>iframe</code>、<code>cors</code>、<code>img</code>、H<code>TML5 postMessage</code>等等。其中用到 <code>html</code> 标签进行跨域的原理就是 <code>html</code> 不受同源策略影响。但只是接受 <code>Get</code> 的请求方式，这个得清楚。</p></blockquote><blockquote><p><strong>延伸1：img iframe script 来发送跨域请求有什么优缺点？</strong></p></blockquote><p><strong>1. <code>iframe</code></strong></p><ul><li>优点：跨域完毕之后<code>DOM</code>操作和互相之间的<code>JavaScript</code>调用都是没有问题的</li><li>缺点：1.若结果要以<code>URL</code>参数传递，这就意味着在结果数据量很大的时候需要分割传递，巨烦。2.还有一个是<code>iframe</code>本身带来的，母页面和<code>iframe</code>本身的交互本身就有安全性限制。</li></ul><p><strong>2. script</strong></p><ul><li>优点：可以直接返回<code>json</code>格式的数据，方便处理</li><li>缺点：只接受<code>GET</code>请求方式</li></ul><p><strong>3. 图片ping</strong></p><ul><li>优点：可以访问任何<code>url</code>，一般用来进行点击追踪，做页面分析常用的方法</li><li>缺点：不能访问响应文本，只能监听是否响应</li></ul><blockquote><p><strong>延伸2：配合 webpack 进行反向代理？</strong></p></blockquote><p><code>webpack</code> 在 <code>devServer</code> 选项里面提供了一个 <code>proxy</code> 的参数供开发人员进行反向代理</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'/api'</span>: {</span><br><span class="line">  target: <span class="string">'http://www.example.com'</span>, <span class="comment">// your target host</span></span><br><span class="line">  changeOrigin: <span class="literal">true</span>, <span class="comment">// needed for virtual hosted sites</span></span><br><span class="line">  pathRewrite: {</span><br><span class="line">    <span class="string">'^/api'</span>: <span class="string">''</span>  <span class="comment">// rewrite path</span></span><br><span class="line">  }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><blockquote><p>然后再配合 <code>http-proxy-middleware</code> 插件对 <code>api</code> 请求地址进行代理</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line"><span class="comment">// proxy api requests</span></span><br><span class="line"><span class="keyword">const</span> exampleProxy = proxy(options); <span class="comment">// 这里的 options 就是 webpack 里面的 proxy 选项对应的每个选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mount `exampleProxy` in web server</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(<span class="string">'/api'</span>, exampleProxy);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>然后再用 <code>nginx</code> 把允许跨域的源地址添加到报头里面即可</p></blockquote><blockquote><p>说到 <code>nginx</code> ，可以再谈谈 <code>CORS</code> 配置，大致如下</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location / {</span><br><span class="line">  <span class="keyword">if</span> ($request_method = <span class="string">'OPTIONS'</span>) {</span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">'*'</span>;  </span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'GET, POST, OPTIONS'</span>; </span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Credentials'</span> <span class="string">'true'</span>;</span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Headers'</span> <span class="string">'DNT, X-Mx-ReqToken, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type'</span>;  </span><br><span class="line">    add_header <span class="string">'Access-Control-Max-Age'</span> <span class="number">86400</span>;  </span><br><span class="line">    add_header <span class="string">'Content-Type'</span> <span class="string">'text/plain charset=UTF-8'</span>;  </span><br><span class="line">    add_header <span class="string">'Content-Length'</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span>;  </span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-http-无状态无连接"><a href="#5-2-http-无状态无连接" class="headerlink" title="5.2 http 无状态无连接"></a>5.2 http 无状态无连接</h3><ul><li><code>http</code> 协议对于事务处理没有记忆能力</li><li>对同一个<code>url</code>请求没有上下文关系</li><li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况</li><li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器</li><li>人生若只如初见，请求过的资源下一次会继续进行请求</li></ul><p><strong>http协议无状态中的 状态 到底指的是什么？！</strong></p><ul><li>【状态】的含义就是：客户端和服务器在某次会话中产生的数据</li><li>那么对应的【无状态】就意味着：这些数据不会被保留</li><li>通过增加<code>cookie</code>和<code>session</code>机制，现在的网络请求其实是有状态的</li><li>在没有状态的<code>http</code>协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话</li></ul><h3 id="5-3-http-cache：就是-http-缓存"><a href="#5-3-http-cache：就是-http-缓存" class="headerlink" title="5.3 http-cache：就是 http 缓存"></a>5.3 http-cache：就是 http 缓存</h3><p><strong>1. 首先得明确 http 缓存的好处</strong></p><ul><li>减少了冗余的数据传输，减少网费</li><li>减少服务器端的压力</li><li><code>Web</code> 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间</li><li>加快客户端加载网页的速度</li></ul><p><strong>2. 常见 http 缓存的类型</strong></p><ul><li>私有缓存（一般为本地浏览器缓存）</li><li>代理缓存</li></ul><p><strong>3. 然后谈谈本地缓存</strong></p><blockquote><p>本地缓存是指浏览器请求资源时命中了浏览器本地的缓存资源，浏览器并不会发送真正的请求给服务器了。它的执行过程是</p></blockquote><ul><li>第一次浏览器发送请求给服务器时，此时浏览器还没有本地缓存副本，服务器返回资源给浏览器，响应码是<code>200 OK</code>，浏览器收到资源后，把资源和对应的响应头一起缓存下来</li><li>第二次浏览器准备发送请求给服务器时候，浏览器会先检查上一次服务端返回的响应头信息中的<code>Cache-Control</code>，它的值是一个相对值，单位为秒，表示资源在客户端缓存的最大有效期，过期时间为第一次请求的时间减去<code>Cache-Control</code>的值，过期时间跟当前的请求时间比较，如果本地缓存资源没过期，那么命中缓存，不再请求服务器</li><li>如果没有命中，浏览器就会把请求发送给服务器，进入缓存协商阶段。</li></ul><blockquote><p>与本地缓存相关的头有：<code>Cache-Control</code>、<code>Expires</code>，<code>Cache-Control</code>有多个可选值代表不同的意义，而<code>Expires</code>就是一个日期格式的绝对值。</p></blockquote><p><strong>3.1 Cache-Control</strong></p><blockquote><p><code>Cache-Control</code>是<code>HTPP</code>缓存策略中最重要的头，它是<code>HTTP/1.1</code>中出现的，它由如下几个值</p></blockquote><ul><li><code>no-cache</code>：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在<code>ETag</code>，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载</li><li><code>no-store</code>：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源</li><li><code>public</code>：可以被所有的用户缓存，包括终端用户和<code>CDN</code>等中间代理服务器。</li><li><code>private</code>：只能被终端用户的浏览器缓存，不允许<code>CDN</code>等中继缓存服务器对其缓存。</li><li><code>max-age</code>：从当前请求开始，允许获取的响应被重用的最长时间（秒）。</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"></span><br><span class="line">Cache-Control: public, max-age=1000 </span><br><span class="line"><span class="comment"># 表示资源可以被所有用户以及代理服务器缓存，最长时间为1000秒。</span></span><br></pre></td></tr></tbody></table></figure><p><strong>3.2 Expires</strong></p><blockquote><p><code>Expires</code>是<code>HTTP/1.0</code>出现的头信息，同样是用于决定本地缓存策略的头，它是一个绝对时间，时间格式是如<code>Mon, 10 Jun 2015 21:31:12 GMT</code>，只要发送请求时间是在<code>Expires</code>之前，那么本地缓存始终有效，否则就会去服务器发送请求获取新的资源。如果同时出现<code>Cache-Control：max-age</code>和<code>Expires</code>，那么<code>max-age</code>优先级更高。他们可以这样组合使用</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public</span><br><span class="line">Expires: Wed, Jan 10 2018 00:27:04 GMT</span><br></pre></td></tr></tbody></table></figure><p><strong>3.3 所谓的缓存协商</strong></p><blockquote><p>当第一次请求时服务器返回的响应头中存在以下情况时</p></blockquote><ul><li>没有 <code>Cache-Control</code> 和 <code>Expires</code></li><li><code>Cache-Control</code> 和 <code>Expires</code> 过期了</li><li><code>Cache-Control</code> 的属性设置为 <code>no-cache</code> 时</li></ul><blockquote><p>那么浏览器第二次请求时就会与服务器进行协商，询问浏览器中的缓存资源是不是旧版本，需不需要更新，此时，服务器就会做出判断，如果缓存和服务端资源的最新版本是一致的，那么就无需再次下载该资源，服务端直接返回<code>304 Not Modified</code> 状态码，如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是<code>200 Ok</code>，那么服务端是根据什么来判断浏览器的缓存是不是最新的呢？其实是根据<code>HTTP</code>的另外两组头信息，分别是：<code>Last-Modified/If-Modified-Since</code> 与 <code>ETag/If-None-Match</code>。</p></blockquote><p><strong>Last-Modified 与 If-Modified-Since</strong></p><ul><li>浏览器第一次请求资源时，服务器会把资源的最新修改时间<code>Last-Modified:Thu, 29 Dec 2011 18:23:55 GMT</code>放在响应头中返回给浏览器</li><li>第二次请求时，浏览器就会把上一次服务器返回的修改时间放在请求头<code>If-Modified-Since:Thu, 29 Dec 2011 18:23:55</code>发送给服务器，服务器就会拿这个时间跟服务器上的资源的最新修改时间进行对比</li></ul><blockquote><p>如果两者相等或者大于服务器上的最新修改时间，那么表示浏览器的缓存是有效的，此时缓存会命中，服务器就不再返回内容给浏览器了，同时<code>Last-Modified</code>头也不会返回，因为资源没被修改，返回了也没什么意义。如果没命中缓存则最新修改的资源连同<code>Last-Modified</code>头一起返回</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次请求返回的响应头</span></span><br><span class="line">Cache-Control:max-age=3600</span><br><span class="line">Expires: Fri, Jan 12 2018 00:27:04 GMT</span><br><span class="line">Last-Modified: Wed, Jan 10 2018 00:27:04 GMT</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二次请求的请求头信息</span></span><br><span class="line">If-Modified-Since: Wed, Jan 10 2018 00:27:04 GMT</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这组头信息是基于资源的修改时间来判断资源有没有更新，另一种方式就是根据资源的内容来判断，就是接下来要讨论的 <code>ETag</code> 与 <code>If-None-Match</code></p></blockquote><p><strong>ETag与If-None-Match</strong></p><blockquote><p><code>ETag/If-None-Match</code>与<code>Last-Modified/If-Modified-Since</code>的流程其实是类似的，唯一的区别是它基于资源的内容的摘要信息（比如<code>MD5 hash</code>）来判断</p></blockquote><blockquote><p>浏览器发送第二次请求时，会把第一次的响应头信息<code>ETag</code>的值放在<code>If-None-Match</code>的请求头中发送到服务器，与最新的资源的摘要信息对比，如果相等，取浏览器缓存，否则内容有更新，最新的资源连同最新的摘要信息返回。用<code>ETag</code>的好处是如果因为某种原因到时资源的修改时间没改变，那么用<code>ETag</code>就能区分资源是不是有被更新。</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次请求返回的响应头：</span></span><br><span class="line"></span><br><span class="line">Cache-Control: public, max-age=31536000</span><br><span class="line">ETag: <span class="string">"15f0fff99ed5aae4edffdd6496d7131f"</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二次请求的请求头信息：</span></span><br><span class="line"></span><br><span class="line">If-None-Match: <span class="string">"15f0fff99ed5aae4edffdd6496d7131f"</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-4-cookie-和-session"><a href="#5-4-cookie-和-session" class="headerlink" title="5.4 cookie 和 session"></a>5.4 cookie 和 session</h3><ul><li><code>session</code>： 是一个抽象概念，开发者为了实现中断和继续等操作，将 <code>user agent </code>和 <code>server</code> 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 <code>session</code> 的概念</li><li><code>cookie</code>：它是一个世纪存在的东西，<code>http</code> 协议中定义在 <code>header</code> 中的字段，可以认为是 <code>session</code> 的一种后端无状态实现</li></ul><blockquote><p>现在我们常说的 <code>session</code>，是为了绕开 <code>cookie</code> 的各种限制，通常借助 <code>cookie</code>本身和后端存储实现的，一种更高级的会话状态实现</p></blockquote><p><code>session</code> 的常见实现要借助<code>cookie</code>来发送 <code>sessionID</code></p><h3 id="5-5-安全问题，如-XSS-和-CSRF"><a href="#5-5-安全问题，如-XSS-和-CSRF" class="headerlink" title="5.5 安全问题，如 XSS 和 CSRF"></a>5.5 安全问题，如 XSS 和 CSRF</h3><ul><li> <code>XSS</code>：跨站脚本攻击，是一种网站应用程序的安全漏洞攻击，是代码注入的一种。常见方式是将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动</li></ul><blockquote><p>防范：记住一点 “所有用户输入都是不可信的”，所以得做输入过滤和转义</p></blockquote><ul><li><code>CSRF</code>：跨站请求伪造，也称 <code>XSRF</code>，是一种挟制用户在当前已登录的<code>Web</code>应用程序上执行非本意的操作的攻击方法。与 <code>XSS</code> 相比，<code>XSS</code>利用的是用户对指定网站的信任，<code>CSRF</code>利用的是网站对用户网页浏览器的信任。</li></ul><blockquote><p>防范：用户操作验证（验证码），额外验证机制（<code>token</code>使用）等</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页面布局</title>
      <link href="2020/12/26/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
      <url>2020/12/26/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><blockquote><p>问题：假设高度默认<code>100px</code> ，请写出三栏布局，其中左栏、右栏各为<code>300px</code>，中间自适应。</p></blockquote><p><img src="http://img.smyhvae.com/20180305_1520.png"></p><p>分析：</p><p>初学者想到的答案有两种：</p><ul><li>方法1：浮动</li><li>方法2：绝对定位</li></ul><blockquote><p>但要求你能至少写出三四种方法，才算及格。剩下的方法如下：</p></blockquote><ul><li>方法3：<code>flexbox</code>。移动开发里经常用到。</li><li>方法4：表格布局<code> table</code>。虽然已经淘汰了，但也应该了解。</li><li>方法5：网格布局 <code>grid</code></li></ul><p><strong>方法1、浮动：</strong></p><blockquote><p>左侧设置左浮动，右侧设置右浮动即可，中间会自动地自适应。</p></blockquote><p><strong>方法2、绝对定位：</strong></p><blockquote><p>左侧设置为绝对定位， <code> left：0px</code>。右侧设置为绝对定位， <code>right：0px</code>。中间设置为绝对定位，<code>left </code>和<code>right</code> 都为<code>300px</code>，即可。中间的宽度会自适应。</p></blockquote><blockquote><p>使用<code>article</code>标签作为容器，包裹左、中、右三个部分。</p></blockquote><blockquote><p>方法1 和方法2 的代码如下：</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        html * {</span><br><span class="line">            padding: 0px;</span><br><span class="line">            margin: 0px;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span> {</span></span><br><span class="line">            margin-bottom: 150px;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span> <span class="selector-tag">article</span> <span class="selector-tag">div</span> { <span class="comment">/*注意，这里是设置每个小块儿的高度为100px，而不是设置大容器的高度。大容器的高度要符合响应式*/</span></span></span><br><span class="line">            height: 100px;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 方法一 start */</span></span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.float</span> <span class="selector-class">.left</span> {</span></span><br><span class="line">            float: left;</span><br><span class="line">            width: 300px;</span><br><span class="line">            background: red;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.float</span> <span class="selector-class">.right</span> {</span></span><br><span class="line">            float: right;</span><br><span class="line">            width: 300px;</span><br><span class="line">            background: blue;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.float</span> <span class="selector-class">.center</span> {</span></span><br><span class="line">            background: green;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 方法一 end */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 方法二 start */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.left-center-right</span> {</span></span><br><span class="line">            position: relative;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.left</span> {</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            left: 0;</span><br><span class="line">            width: 300px;</span><br><span class="line">            background: red;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 【重要】中间的区域，左侧定位300px，右侧定位为300px，即可完成。宽度会自使用 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.center</span> {</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            left: 300px;</span><br><span class="line">            right: 300px;</span><br><span class="line">            background: green;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.right</span> {</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            right: 0;</span><br><span class="line">            width: 300px;</span><br><span class="line">            background: blue;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 方法二 end */</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 方法一：浮动 start --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 输入 section.layout.float，即可生成  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout float"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 用  article 标签包裹左、中、右三个部分 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-right-center"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 输入 div.left+div.right+div.center，即可生成 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">                我是 left</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">                我是 right</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">                浮动解决方案</span><br><span class="line">                我是 center</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方法一：浮动 end --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout absolute"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-center-right"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">                我是 left</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">                我是 right</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>绝对定位解决方案<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                我是 center</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180305_1640.gif"></p><p><strong>方法3、flexbox布局</strong></p><blockquote><p>将左中右所在的容器设置为<code>display: flex</code>，设置两侧的宽度后，然后让中间的<code>flex = 1</code>，即可。</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        html * {</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span> <span class="selector-tag">article</span> <span class="selector-tag">div</span> {</span></span><br><span class="line">            height: 100px;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.left-center-right</span> {</span></span><br><span class="line">            display: flex;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.flex</span> <span class="selector-class">.left</span> {</span></span><br><span class="line">            width: 300px;</span><br><span class="line">            background: red;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.flex</span> <span class="selector-class">.center</span> {</span></span><br><span class="line">            flex: 1;</span><br><span class="line">            background: green;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.flex</span> <span class="selector-class">.right</span> {</span></span><br><span class="line">            width: 300px;</span><br><span class="line">            background: blue;</span><br><span class="line">        }</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout flex"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-center-right-"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">                我是 left</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>flex布局解决方案<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                我是 center</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">                我是 right</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180305_1700.gif"></p><p><strong>方法4、表格布局 table</strong></p><blockquote><p>设置整个容器的宽度为<code>100%</code>，设置三个部分均为表格，然后左边的单元格为 <code>300px</code>，右边的单元格为 <code>300px</code>，即可。中间的单元格会自适应。</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        html * {</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-tag">div</span> {</span></span><br><span class="line">            height: 100px;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 重要：设置容器为表格布局，宽度为100% */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.left-center-right</span> {</span></span><br><span class="line">            width: 100%;</span><br><span class="line">            display: table;</span><br><span class="line">            height: 100px;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.left-center-right</span> <span class="selector-tag">div</span> {</span></span><br><span class="line"><span class="css">            <span class="selector-tag">display</span>: <span class="selector-tag">table-cell</span>; <span class="comment">/* 重要：设置三个模块为表格里的单元*/</span></span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.left</span> {</span></span><br><span class="line">            width: 300px;</span><br><span class="line">            background: red;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.center</span> {</span></span><br><span class="line">            background: green;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.right</span> {</span></span><br><span class="line">            width: 300px;</span><br><span class="line">            background: blue;</span><br><span class="line">        }</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout table"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-center-right"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">                我是 left</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>表格布局解决方案<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                我是 center</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">                我是 right</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="http://img.smyhvae.com/20180305_1855.gif"></p><p><strong>方法5、网格布局 grid</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        html * {</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 重要：设置容器为网格布局，宽度为100% */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.left-center-right</span> {</span></span><br><span class="line">            display: grid;</span><br><span class="line">            width: 100%;</span><br><span class="line">            grid-template-rows: 100px;</span><br><span class="line"><span class="css">            <span class="selector-tag">grid-template-columns</span>: 300<span class="selector-tag">px</span> <span class="selector-tag">auto</span> 300<span class="selector-tag">px</span>;  <span class="comment">/* 重要：设置网格为三列，并设置每列的宽度。即可。*/</span></span></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.left</span> {</span></span><br><span class="line">            background: red;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.center</span> {</span></span><br><span class="line">            background: green;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.right</span> {</span></span><br><span class="line">            background: blue;</span><br><span class="line">        }</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout grid"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-center-right"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">                我是 left</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>网格布局解决方案<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                我是 center</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">                我是 right</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果：</p><p><img src="http://img.smyhvae.com/20180305_1920.gif"></p><p><strong>延伸：五种方法的对比</strong></p><blockquote><p>五种方法的优缺点</p></blockquote><ul><li>考虑中间模块的高度问题</li><li>兼容性问题：实际开发中，哪个最实用？</li></ul><p>方法1：浮动：</p><ul><li>优点：兼容性好。</li><li>缺点：浮动会脱离标准文档流，因此要清除浮动。我们解决好这个问题即可。</li></ul><p>方法:2：绝对定位</p><ul><li>优点：快捷。</li><li>缺点：导致子元素也脱离了标准文档流，可实用性差。</li></ul><p>方法3：flex 布局（CSS3中出现的）</p><ul><li>优点：解决上面两个方法的不足，flex布局比较完美。移动端基本用 flex布局。</li></ul><p>方法4：表格布局</p><ul><li>优点：表格布局在很多场景中很实用，兼容性非常好。因为IE8不支持 flex，此时可以尝试表格布局</li><li>缺点：因为三个部分都当成了<strong>单元格</strong>来对待，此时，如果中间的部分变高了，其会部分也会被迫调整高度。但是，在很多场景下，我们并不需要两侧的高度增高。</li></ul><blockquote><p>什么时候用 <code>flex </code>布局 or 表格布局，看具体的场景。二者没有绝对的优势，也没有绝对的不足。</p></blockquote><p>方法5：网格布局</p><ul><li>CSS3中引入的布局，很好用。代码量简化了很多。</li></ul><blockquote><p>PS：面试提到网格布局，说明我们对新技术是有追求的。</p></blockquote><p><strong>延伸：如果题目中去掉高度已知</strong></p><blockquote><p>问题：题目中，如果去掉高度已知，我们往中间的模块里塞很多内容，让中间的模块撑开。会发生什么变化？哪个布局就不能用了？</p></blockquote><p>分析：其实可以这样理解，我们回去看上面的动画效果，当中间的模块变得很挤时，会发生什么效果？就是我们想要的答案。</p><blockquote><p>答案是：<strong>flex 布局和表格布局可以通用</strong>，其他三个布局都不能用了。</p></blockquote><p><strong>总结</strong></p><blockquote><p>涉及到的知识点：</p></blockquote><ul><li>语义化掌握到位：每个区域用<code>section</code>、<code>article</code>代表容器、<code>div</code>代表块儿。如果通篇都用 div，那就是语义化没掌握好。</li><li>页面布局理解深刻。</li><li><code>CSS</code>基础知识扎实。</li><li>思维灵活且积极上进。题目中可以通过<code>网格布局</code>来体现。</li><li>代码书写规范。注意命名。上面的代码中，没有一行代码是多的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="2020/12/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>2020/12/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><blockquote><p>类与实例：</p></blockquote><ul><li>类的声明</li><li>生成实例</li></ul><p><strong>类与继承：</strong></p><ul><li>如何实现继承：继承的本质就是原型链</li><li>继承的几种方式</li></ul><h2 id="2-类的定义、实例化"><a href="#2-类的定义、实例化" class="headerlink" title="2 类的定义、实例化"></a>2 类的定义、实例化</h2><h3 id="2-1-类的定义-类的声明"><a href="#2-1-类的定义-类的声明" class="headerlink" title="2.1 类的定义/类的声明"></a>2.1 类的定义/类的声明</h3><p><strong>方式一</strong>：用构造函数模拟类（传统写法）</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal1</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">'smyhvae'</span>; <span class="comment">//通过this，表明这是一个构造函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>方式二</strong>：用 class 声明（<code>ES6</code>的写法）</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal2</span> </span>{</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> {  <span class="comment">//可以在构造函数里写属性</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>控制台的效果：</p><p><img src="http://img.smyhvae.com/20180307_0957.png"></p><h3 id="2-2-实例化"><a href="#2-2-实例化" class="headerlink" title="2.2 实例化"></a>2.2 实例化</h3><p>类的实例化很简单，直接 <code>new</code> 出来即可。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Animal1(),<span class="keyword">new</span> Animal2()); <span class="comment">//实例化。如果括号里没有参数，则括号可以省略</span></span><br></pre></td></tr></tbody></table></figure><p><img src="http://img.smyhvae.com/20180307_1000.png"></p><h2 id="3-继承的几种方式"><a href="#3-继承的几种方式" class="headerlink" title="3 继承的几种方式"></a>3 继承的几种方式</h2><blockquote><p>继承的本质就是原型链。</p></blockquote><p><strong>继承的方式有几种？每种形式的优缺点是</strong>？这些问题必问的。其实就是考察你对原型链的掌握程度。</p><h3 id="3-1-方式一：借助构造函数"><a href="#3-1-方式一：借助构造函数" class="headerlink" title="3.1 方式一：借助构造函数"></a>3.1 方式一：借助构造函数</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent1</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">'parent1 的属性'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span>(<span class="params"></span>) </span>{</span><br><span class="line">    Parent1.call(<span class="built_in">this</span>);         <span class="comment">//【重要】此处用 call 或 apply 都行：改变 this 的指向</span></span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">'child1 的属性'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child1);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>【重要】上方代码中，最重要的那行代码：在子类的构造函数里写了<code>Parent1.call(this);</code>，意思是：<strong>让Parent的构造函数在child的构造函数中执行</strong>。发生的变化是：<strong>改变this的指向</strong>，parent的实例 –&gt; 改为指向child的实例。导致 parent的实例的属性挂在到了child的实例上，这就实现了继承。</p></blockquote><p>打印结果：</p><p><img src="http://img.smyhvae.com/20180307_1015.png"></p><blockquote><p>上方结果表明：<code>child</code>先有了 <code>parent</code> 实例的属性（继承得以实现），再有了<code>child</code> 实例的属性。</p></blockquote><p><strong>分析</strong>：</p><blockquote><p>这种方式，虽然改变了 <code>this</code> 的指向，但是，<strong>Child1 无法继承 <code>Parent1</code> 的原型</strong>。也就是说，如果我给 <code>Parent1</code> 的原型增加一个方法：</p></blockquote><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent1.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>上面这个方法是无法被 <code>Child1</code> 继承的。如下：</p></blockquote><p><img src="http://img.smyhvae.com/20180307_1030.png"></p><h3 id="3-2-方法二：通过原型链实现继承"><a href="#3-2-方法二：通过原型链实现继承" class="headerlink" title="3.2 方法二：通过原型链实现继承"></a>3.2 方法二：通过原型链实现继承</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过原型链实现继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">'Parent 的属性'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">'Child 的属性'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent(); <span class="comment">//【重要】</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child());</span><br></pre></td></tr></tbody></table></figure><p>打印结果：</p><p><img src="http://img.smyhvae.com/20180307_1109.png"></p><blockquote><p>【重要】上方代码中，最重要的那行：每个函数都有<code>prototype</code>属性，于是，构造函数也有这个属性，这个属性是一个对象。现在，<strong>我们把<code>Parent</code>的实例赋值给了<code>Child</code>的<code>prototye</code>**，从而实现</strong>继承**。此时，<code>Child</code>构造函数、<code>Parent</code>的实例、<code>Child</code>的实例构成一个三角关系。于是：</p></blockquote><ul><li><code>new Child.__proto__ === new Parent()</code>的结果为<code>true</code></li></ul><p><strong>分析：</strong></p><ul><li>这种继承方式，<strong>Child 可以继承 Parent 的原型</strong>，但有个缺点：</li></ul><blockquote><p>缺点是：<strong>如果修改 child1实例的name属性，child2实例中的name属性也会跟着改变</strong>。</p></blockquote><p>如下：</p><p><img src="http://img.smyhvae.com/20180307_1123.png"></p><blockquote><p>上面的代码中， <code>child1</code>修改了<code>arr</code>属性，却发现，<code>child2</code>的<code>arr</code>属性也跟着改变了。这显然不太好，在业务中，两个子模块应该隔离才对。如果改了一个对象，另一个对象却发生了改变，就不太好。</p></blockquote><blockquote><p>造成这种缺点的原因是：<code>child1</code>和<code>child2</code>共用原型。即：<code>chi1d1.__proto__ === child2__proto__</code>是严格相同。而 arr方法是在 Parent 的实例上（即 Child实例的原型）的。</p></blockquote><h3 id="3-3-方式三：组合的方式：构造函数-原型链"><a href="#3-3-方式三：组合的方式：构造函数-原型链" class="headerlink" title="3.3 方式三：组合的方式：构造函数 + 原型链"></a>3.3 方式三：组合的方式：构造函数 + 原型链</h3><p>就是把上面的两种方式组合起来：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">组合方式实现继承：构造函数、原型链</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent3</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">'Parent 的属性'</span>;</span><br><span class="line">    <span class="built_in">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child3</span>(<span class="params"></span>) </span>{</span><br><span class="line">    Parent3.call(<span class="built_in">this</span>); <span class="comment">//【重要1】执行 parent方法</span></span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">'Child 的属性'</span>;</span><br><span class="line">}</span><br><span class="line">Child3.prototype = <span class="keyword">new</span> Parent3(); <span class="comment">//【重要2】第二次执行parent方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child3();</span><br></pre></td></tr></tbody></table></figure><ul><li>这种方式，能解决之前两种方式的问题：既可以继承父类原型的内容，也不会造成原型里属性的修改。</li><li>这种方式的缺点是：让父亲<code>Parent</code>的构造方法执行了两次。</li><li><code>ES6</code>中的继承方式，一带而过即可，重点是要掌握<code>ES5</code>中的继承。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域通信</title>
      <link href="2020/12/26/%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E7%B1%BB/"/>
      <url>2020/12/26/%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>从本章起，对代码的要求没之前那么高了，但是，要求你对知识面的掌握要足够宽。</p><p><strong>前端通信类的问题，主要包括以下内容</strong>：</p><ol><li>什么是<strong>同源策略</strong>及限制</li></ol><blockquote><p>同源策略是一个概念，就一句话。有什么限制，就三句话。能说出来即可。</p></blockquote><ol start="2"><li><strong>前后端如何通信</strong></li></ol><blockquote><p>如果你不准备，估计也就只能说出<code>ajax</code>。这个可以考察出知识面。</p></blockquote><ol start="3"><li>如何创建<strong>Ajax</strong></li></ol><blockquote><p><code>Ajax</code>在前后端通信中经常用到。做业务时，可以借助第三方的库，比如<code>vue</code>框架里的库、<code>jQuery</code>也有封装好的方法。但如果让你用原生的<code>js</code>去实现，该怎么做？</p></blockquote><p>这就是考察你的动手能力，以及框架原理的掌握。如果能写出来，可以体现出你的基本功。是加分项。</p><ol start="4"><li><strong>跨域通信</strong>的几种方式</li></ol><blockquote><p>这部分非常重要。无非就是问你：什么是跨域、跨域有什么限制、<strong>跨域有几种方式</strong>。</p></blockquote><p>下面分别讲解。</p><h2 id="2-同源策略的概念和具体限制"><a href="#2-同源策略的概念和具体限制" class="headerlink" title="2 同源策略的概念和具体限制"></a>2 同源策略的概念和具体限制</h2><blockquote><p><strong>同源策略</strong>：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。（来自MDN官方的解释）</p></blockquote><p><strong>具体解释：</strong></p><ol><li><code>源</code>包括三个部分：协议、域名、端口（<code>http</code>协议的默认端口是<code>80</code>）。如果有任何一个部分不同，则<code>源</code>不同，那就是跨域了。</li><li><code>限制</code>：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住）</li></ol><ul><li><code>Cookie</code>、<code>LocalStorage</code>和<code>IndexDB</code>无法获取。</li><li>无法获取和操作<code>DOM</code>。</li><li>不能发送<code>Ajax</code>请求。我们要注意，<code>Ajax</code>只适合<strong>同源</strong>的通信。</li></ul><h2 id="3-前后端如何通信"><a href="#3-前后端如何通信" class="headerlink" title="3 前后端如何通信"></a>3 前后端如何通信</h2><p><strong>主要有以下几种方式：</strong></p><ul><li><code>Ajax</code>：不支持跨域。</li><li><code>WebSocket</code>：不受同源策略的限制，支持跨域</li><li><code>CORS</code>：不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：<strong>同时支持同源和跨域的Ajax</strong>。</li></ul><h2 id="4-如何创建Ajax"><a href="#4-如何创建Ajax" class="headerlink" title="4 如何创建Ajax"></a>4 如何创建Ajax</h2><blockquote><p>在回答 <code>Ajax</code> 的问题时，要回答以下几个方面：</p></blockquote><ol><li><code>XMLHttpRequest</code> 的工作原理</li><li>兼容性处理</li></ol><blockquote><p><code>XMLHttpRequest</code>只有在高级浏览器中才支持。在回答问题时，这个兼容性问题不要忽略。</p></blockquote><ol start="3"><li>事件的触发条件</li><li>事件的触发顺序</li></ol><blockquote><p><code>XMLHttpRequest</code>有很多触发事件，每个事件是怎么触发的。</p></blockquote><h3 id="4-1-发送-Ajax-请求的五个步骤（XMLHttpRequest的工作原理）"><a href="#4-1-发送-Ajax-请求的五个步骤（XMLHttpRequest的工作原理）" class="headerlink" title="4.1 发送 Ajax 请求的五个步骤（XMLHttpRequest的工作原理）"></a>4.1 发送 Ajax 请求的五个步骤（XMLHttpRequest的工作原理）</h3><ol><li>创建<code>XMLHttpRequest</code> 对象。</li><li>使用<code>open</code>方法设置请求的参数。`open(method, url, 是否异步)``。</li><li>发送请求。</li><li>注册事件。 注册<code>onreadystatechange</code>事件，状态改变时就会调用。</li></ol><blockquote><p>如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。</p></blockquote><ol start="5"><li>获取返回的数据，更新UI。</li></ol><h3 id="4-2-发送-get-请求和-post-请求"><a href="#4-2-发送-get-请求和-post-请求" class="headerlink" title="4.2 发送 get 请求和 post 请求"></a>4.2 发送 get 请求和 post 请求</h3><blockquote><p><code>get</code>请求举例：</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Ajax 发送 get 请求<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"发送get_ajax请求"</span> <span class="attr">id</span>=<span class="string">'btnAjax'</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 绑定点击事件</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">'#btnAjax'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 发送ajax 请求 需要 五步</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// （1）创建异步对象</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ajaxObj = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// （2）设置请求的参数。包括：请求的方法、请求的url。</span></span></span><br><span class="line"><span class="javascript">        ajaxObj.open(<span class="string">'get'</span>, <span class="string">'02-ajax.php'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// （3）发送请求</span></span></span><br><span class="line">        ajaxObj.send();</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//（4）注册事件。 onreadystatechange事件，状态改变时就会调用。</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。</span></span></span><br><span class="line"><span class="javascript">        ajaxObj.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 为了保证 数据 完整返回，我们一般会判断 两个值</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (ajaxObj.readyState == <span class="number">4</span> &amp;&amp; ajaxObj.status == <span class="number">200</span>) {</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 5.在注册的事件中 获取 返回的 内容 并修改页面的显示</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'数据返回成功'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="comment">// 数据是保存在 异步对象的 属性中</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(ajaxObj.responseText);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="comment">// 修改页面的显示</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.querySelector(<span class="string">'h1'</span>).innerHTML = ajaxObj.responseText;</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>post</code> 请求举例：</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Ajax 发送 get 请求<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"发送put_ajax请求"</span> <span class="attr">id</span>=<span class="string">'btnAjax'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 异步对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置属性</span></span></span><br><span class="line"><span class="javascript">    xhr.open(<span class="string">'post'</span>, <span class="string">'02.post.php'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 如果想要使用post提交数据,必须添加此行</span></span></span><br><span class="line"><span class="javascript">    xhr.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 将数据通过send方法传递</span></span></span><br><span class="line"><span class="javascript">    xhr.send(<span class="string">'name=fox&amp;age=18'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 发送并接受返回值</span></span></span><br><span class="line"><span class="javascript">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 这步为判断服务器是否正确响应</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) {</span></span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="4-3-onreadystatechange-事件"><a href="#4-3-onreadystatechange-事件" class="headerlink" title="4.3 onreadystatechange 事件"></a>4.3 onreadystatechange 事件</h3><blockquote><p>注册 <code>onreadystatechange</code> 事件后，每当 <code>readyState</code> 属性改变时，就会调用 <code>onreadystatechange</code> 函数。</p></blockquote><blockquote><p><code>readyState</code>：（存有 <code>XMLHttpRequest</code> 的状态。从 <code>0</code> 到 <code>4</code> 发生变化）</p></blockquote><ul><li><code>0</code>: 请求未初始化</li><li><code>1</code>: 服务器连接已建立</li><li><code>2</code>: 请求已接收</li><li><code>3</code>: 请求处理中</li><li><code>4</code>: 请求已完成，且响应已就绪</li></ul><h3 id="4-4-事件的触发条件"><a href="#4-4-事件的触发条件" class="headerlink" title="4.4 事件的触发条件"></a>4.4 事件的触发条件</h3><p><img src="http://img.smyhvae.com/20180307_1443.png"></p><h3 id="4-5-事件的触发顺序"><a href="#4-5-事件的触发顺序" class="headerlink" title="4.5 事件的触发顺序"></a>4.5 事件的触发顺序</h3><p><img src="http://img.smyhvae.com/20180307_1445.png"></p><h3 id="4-6-实际开发中用的-原生Ajax请求"><a href="#4-6-实际开发中用的-原生Ajax请求" class="headerlink" title="4.6 实际开发中用的 原生Ajax请求"></a>4.6 实际开发中用的 原生Ajax请求</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> util = {};</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 ajax 请求之后的json</span></span><br><span class="line">util.json = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> opt = {</span><br><span class="line">        url: <span class="string">''</span>,</span><br><span class="line">        type: <span class="string">'get'</span>,</span><br><span class="line">        data: {},</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        },</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">    };</span><br><span class="line">    util.extend(opt, options);</span><br><span class="line">    <span class="keyword">if</span> (opt.url) {</span><br><span class="line">        <span class="comment">//IE兼容性处理：浏览器特征检查。检查该浏览器是否存在XMLHttpRequest这个api，没有的话，就用IE的api</span></span><br><span class="line">        <span class="keyword">var</span> xhr = XMLHttpRequest ? <span class="keyword">new</span> XMLHttpRequest() : <span class="keyword">new</span> <span class="built_in">window</span>.ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> data = opt.data,</span><br><span class="line">            url = opt.url,</span><br><span class="line">            type = opt.type.toUpperCase();</span><br><span class="line">        dataArr = [];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> data) {</span><br><span class="line">        dataArr.push(key + <span class="string">'='</span> + data[key]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'GET'</span>) {</span><br><span class="line">        url = url + <span class="string">'?'</span> + dataArr.join(<span class="string">'&amp;'</span>);</span><br><span class="line">        xhr.open(type, url.replace(<span class="regexp">/\?$/g</span>, <span class="string">''</span>), <span class="literal">true</span>);</span><br><span class="line">        xhr.send();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'POST'</span>) {</span><br><span class="line">        xhr.open(type, url, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 如果想要使用post提交数据,必须添加此行</span></span><br><span class="line">        xhr.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">        xhr.send(dataArr.join(<span class="string">'&amp;'</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span> || xhr.status === <span class="number">304</span>) { <span class="comment">//304表示：用缓存即可。206表示获取媒体资源的前面一部分</span></span><br><span class="line">            <span class="keyword">var</span> res;</span><br><span class="line">            <span class="keyword">if</span> (opt.success &amp;&amp; opt.success <span class="keyword">instanceof</span> <span class="built_in">Function</span>) {</span><br><span class="line">                res = xhr.responseText;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> res === <span class="string">'string'</span>) {</span><br><span class="line">                    res = <span class="built_in">JSON</span>.parse(res);  <span class="comment">//将字符串转成json</span></span><br><span class="line">                    opt.success.call(xhr, res);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (opt.error &amp;&amp; opt.error <span class="keyword">instanceof</span> <span class="built_in">Function</span>) {</span><br><span class="line">                opt.error.call(xhr, res);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="5-跨域通信的几种方式"><a href="#5-跨域通信的几种方式" class="headerlink" title="5 跨域通信的几种方式"></a>5 跨域通信的几种方式</h2><blockquote><p>方式如下：</p></blockquote><ol><li><code>JSONP</code></li><li><code>WebSocket</code></li><li><code>CORS</code></li><li><code>Hash</code></li><li><code>postMessage</code></li></ol><blockquote><p>上面这五种方式，在面试时，都要说出来。</p></blockquote><h3 id="5-1-JSONP"><a href="#5-1-JSONP" class="headerlink" title="5.1 JSONP"></a>5.1 JSONP</h3><blockquote><p>面试会问：<code>JSONP</code>的原理是什么？怎么实现的？</p></blockquote><ul><li>在<code>CORS</code>和<code>postMessage</code>以前，我们一直都是通过<code>JSONP</code>来做跨域通信的。</li></ul><blockquote><p><strong>JSONP的原理</strong>：通过<code>&lt;script&gt;</code>标签的异步加载来实现的。比如说，实际开发中，我们发现，<code>head</code>标签里，可以通过<code>&lt;script&gt;</code>标签的<code>src</code>，里面放<code>url</code>，加载很多在线的插件。这就是用到了<code>JSONP</code>。</p></blockquote><p><strong>JSONP的实现：</strong></p><blockquote><p>比如说，客户端这样写：</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://www.smyhvae.com/?data=name&amp;callback=myjsonp"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>上面的<code>src</code>中，<code>data=name</code>是get请求的参数，<code>myjsonp</code>是和后台约定好的函数名。<br>服务器端这样写：</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myjsonp({</span><br><span class="line">    data: {}</span><br><span class="line"></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><blockquote><p>于是，本地要求创建一个<code>myjsonp</code> 的<strong>全局函数</strong>，才能将返回的数据执行出来。</p></blockquote><p><strong>实际开发中，前端的JSONP是这样实现的：</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> util = {};</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//定义方法：动态创建 script 标签</span></span></span><br><span class="line">    /**</span><br><span class="line"><span class="javascript">     * [<span class="function"><span class="keyword">function</span> 在页面中注入<span class="title">js</span>脚本]</span></span></span><br><span class="line">     * @param  {[type]} url     [description]</span><br><span class="line">     * @param  {[type]} charset [description]</span><br><span class="line"><span class="javascript">     * @<span class="keyword">return</span> {[type]}         [description]</span></span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    util.createScript = <span class="function"><span class="keyword">function</span> (<span class="params">url, charset</span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="javascript">        script.setAttribute(<span class="string">'type'</span>, <span class="string">'text/javascript'</span>);</span></span><br><span class="line"><span class="javascript">        charset &amp;&amp; script.setAttribute(<span class="string">'charset'</span>, charset);</span></span><br><span class="line"><span class="javascript">        script.setAttribute(<span class="string">'src'</span>, url);</span></span><br><span class="line"><span class="javascript">        script.async = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> script;</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"><span class="javascript">     * [<span class="function"><span class="keyword">function</span> 处理<span class="title">jsonp</span>]</span></span></span><br><span class="line">     * @param  {[type]} url      [description]</span><br><span class="line">     * @param  {[type]} onsucess [description]</span><br><span class="line">     * @param  {[type]} onerror  [description]</span><br><span class="line">     * @param  {[type]} charset  [description]</span><br><span class="line"><span class="javascript">     * @<span class="keyword">return</span> {[type]}          [description]</span></span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    util.jsonp = <span class="function"><span class="keyword">function</span> (<span class="params">url, onsuccess, onerror, charset</span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> callbackName = util.getName(<span class="string">'tt_player'</span>); <span class="comment">//事先约定好的 函数名</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>[callbackName] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{      <span class="comment">//根据回调名称注册一个全局的函数</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (onsuccess &amp;&amp; util.isFunction(onsuccess)) {</span></span><br><span class="line"><span class="javascript">                onsuccess(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span></span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> script = util.createScript(url + <span class="string">'&amp;callback='</span> + callbackName, charset);   <span class="comment">//动态创建一个script标签</span></span></span><br><span class="line"><span class="javascript">        script.onload = script.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{   <span class="comment">//监听加载成功的事件，获取数据</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (!script.readyState || <span class="regexp">/loaded|complete/</span>.test(script.readyState)) {</span></span><br><span class="line"><span class="javascript">                script.onload = script.onreadystatechange = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 移除该script的 DOM 对象</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (script.parentNode) {</span></span><br><span class="line">                    script.parentNode.removeChild(script);</span><br><span class="line">                }</span><br><span class="line"><span class="javascript">                <span class="comment">// 删除函数或变量</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">window</span>[callbackName] = <span class="literal">null</span>;  <span class="comment">//最后不要忘了删除</span></span></span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"><span class="javascript">        script.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (onerror &amp;&amp; util.isFunction(onerror)) {</span></span><br><span class="line">                onerror();</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script); <span class="comment">//往html中增加这个标签，目的是把请求发送出去</span></span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-WebSocket"><a href="#5-2-WebSocket" class="headerlink" title="5.2 WebSocket"></a>5.2 WebSocket</h3><blockquote><p><code>WebSocket</code>的用法如下：</p></blockquote><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'wss://echo.websocket.org'</span>); <span class="comment">//创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把请求发出去</span></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Connection open ...'</span>);</span><br><span class="line">    ws.send(<span class="string">'Hello WebSockets!'</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对方发消息过来时，我接收</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Received Message: '</span>, evt.data);</span><br><span class="line">    ws.close();</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Connection closed.'</span>);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>面试一般不会让你写这个代码，一般是考察你是否了解 <code>WebSocket</code>概念，知道有这么回事即可。</p></blockquote><h3 id="5-3-CORS"><a href="#5-3-CORS" class="headerlink" title="5.3 CORS"></a>5.3 CORS</h3><blockquote><p><code>CORS</code> 可以理解成是<strong>既可以同步、也可以异步</strong>的Ajax。</p></blockquote><ul><li>fetch<code> 是一个比较新的</code>API<code>，用来实现</code>CORS`通信。用法如下：</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url（必选），options（可选）</span></span><br><span class="line">fetch(<span class="string">'/some/url/'</span>, {</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">}).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>{  <span class="comment">//类似于 ES6中的promise</span></span><br><span class="line"></span><br><span class="line">}).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{</span><br><span class="line">  <span class="comment">// 出错了，等价于 then 的第二个参数，但这样更好用更直观</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><blockquote><p>另外，如果面试官问：“CORS为什么支持跨域的通信？”</p></blockquote><blockquote><p>答案：跨域时，浏览器会拦截<code>Ajax</code>请求，并在<code>http</code>头中加<code>Origin</code>。</p></blockquote><h3 id="5-4-Hash"><a href="#5-4-Hash" class="headerlink" title="5.4 Hash"></a>5.4 Hash</h3><ul><li><code>url</code>的<code>#</code>后面的内容就叫<code>Hash</code>。<strong>Hash的改变，页面不会刷新</strong>。这就是用 <code>Hash</code> 做跨域通信的基本原理。</li></ul><blockquote><p>补充：<code>url</code>的<code>?</code>后面的内容叫<code>Search</code>。<code>Search</code>的改变，会导致页面刷新，因此不能做跨域通信。</p></blockquote><p><strong>使用举例：</strong></p><p><strong>场景</strong>：我的页面 <code>A</code> 通过<code>iframe</code>或<code>frame</code>嵌入了跨域的页面 <code>B</code>。</p><blockquote><p>现在，我这个<code>A</code>页面想给<code>B</code>页面发消息，怎么操作呢？</p></blockquote><ol><li>首先，在我的<code>A</code>页面中：</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">var</span> B = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'iframe'</span>);</span><br><span class="line">B.src = B.src + <span class="string">'#'</span> + <span class="string">'jsonString'</span>;  <span class="comment">//我们可以把JS 对象，通过 JSON.stringify()方法转成 json字符串，发给 B</span></span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>然后，在<code>B</code>页面中：</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B中的伪代码</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{  <span class="comment">//通过onhashchange方法监听，url中的 hash 是否发生变化</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">window</span>.location.hash;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="5-5-postMessage-方法"><a href="#5-5-postMessage-方法" class="headerlink" title="5.5 postMessage()方法"></a>5.5 postMessage()方法</h3><blockquote><p><code>H5</code>中新增的`postMessage()``方法，可以用来做跨域通信。既然是H5中新增的，那就一定要提到。</p></blockquote><p><strong>场景</strong>：窗口 A (<code>http:A.com</code>)向跨域的窗口 B (<code>http:B.com</code>)发送信息。步骤如下</p><ol><li>在<code>A</code>窗口中操作如下：向<code>B</code>窗口发送数据：</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息</span></span><br><span class="line">Bwindow.postMessage(<span class="string">'data'</span>, <span class="string">'http://B.com'</span>); <span class="comment">//这里强调的是B窗口里的window对象</span></span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>在<code>B</code>窗口中操作如下：</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在窗口B中监听 message 事件</span></span><br><span class="line">Awindow.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>{   <span class="comment">//这里强调的是A窗口里的window对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.origin);  <span class="comment">//获取 ：url。这里指：http://A.com</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.source);  <span class="comment">//获取：A window对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.data);    <span class="comment">//获取传过来的数据</span></span><br><span class="line">}, <span class="literal">false</span>);</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器</title>
      <link href="2020/12/26/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>2020/12/26/%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、事件机制"><a href="#一、事件机制" class="headerlink" title="一、事件机制"></a>一、事件机制</h2><h3 id="1-1-事件触发三阶段"><a href="#1-1-事件触发三阶段" class="headerlink" title="1.1 事件触发三阶段"></a>1.1 事件触发三阶段</h3><ul><li>document 往事件触发处传播，遇到注册的捕获事件会触发</li><li>传播到事件触发处时触发注册的事件</li><li>从事件触发处往 document 传播，遇到注册的冒泡事件会触发</li></ul><blockquote><p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 以下会先打印冒泡然后是捕获</span><br><span class="line">node.addEventListener('click',(event) =&gt;{</span><br><span class="line">console.log('冒泡')</span><br><span class="line">},false);</span><br><span class="line">node.addEventListener('click',(event) =&gt;{</span><br><span class="line">console.log('捕获 ')</span><br><span class="line">},true)</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2-注册事件"><a href="#1-2-注册事件" class="headerlink" title="1.2 注册事件"></a>1.2 注册事件</h3><ul><li>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> 。<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件</li><li>一般来说，我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node.addEventListener(<span class="string">'click'</span>,<span class="function">(<span class="params">event</span>) =&gt;</span>{</span><br><span class="line">event.stopImmediatePropagation()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">},<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 点击 node 只会执行上面的函数，该函数不会执行</span></span><br><span class="line">node.addEventListener(<span class="string">'click'</span>,<span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'捕获 '</span>)</span><br><span class="line">},<span class="literal">true</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3-事件代理"><a href="#1-3-事件代理" class="headerlink" title="1.3 事件代理"></a>1.3 事件代理</h3><blockquote><p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'##ul'</span>)</span></span><br><span class="line"><span class="javascript">ul.addEventListener(<span class="string">'click'</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(event.target);</span></span><br><span class="line">})</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>事件代理的方式相对于直接给目标注册事件来说，有以下优点</p></blockquote><ul><li>节省内存</li><li>不需要给子节点注销事件</li></ul><h2 id="二、跨域"><a href="#二、跨域" class="headerlink" title="二、跨域"></a>二、跨域</h2><blockquote><p>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败</p></blockquote><h3 id="2-1-JSONP"><a href="#2-1-JSONP" class="headerlink" title="2.1 JSONP"></a>2.1 JSONP</h3><blockquote><p>JSONP 的原理很简单，就是利用 <script> 标签没有跨域限制的漏洞。通过 <script> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>JSONP 使用简单且兼容性不错，但是只限于 get 请求</li></ul><h3 id="2-2-CORS"><a href="#2-2-CORS" class="headerlink" title="2.2 CORS"></a>2.2 CORS</h3><ul><li><code>CORS</code>需要浏览器和后端同时支持</li><li>浏览器会自动进行 <code>CORS</code> 通信，实现CORS通信的关键是后端。只要后端实现了 <code>CORS</code>，就实现了跨域。</li><li>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 <code>CORS</code>。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源</li></ul><h3 id="2-3-document-domain"><a href="#2-3-document-domain" class="headerlink" title="2.3 document.domain"></a>2.3 document.domain</h3><ul><li>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</li><li>只需要给页面添加 <code>document.domain = &#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域</li></ul><h3 id="2-4-postMessage"><a href="#2-4-postMessage" class="headerlink" title="2.4 postMessage"></a>2.4 postMessage</h3><blockquote><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息端</span></span><br><span class="line"><span class="built_in">window</span>.parent.postMessage(<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;http://test.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收消息端</span></span><br><span class="line"><span class="keyword">var</span> mc = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">mc.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin; </span><br><span class="line">    <span class="keyword">if</span> (origin === <span class="string">&#x27;http://test.com&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;验证通过&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="三、Event-loop"><a href="#三、Event-loop" class="headerlink" title="三、Event loop"></a>三、Event loop</h2><h3 id="3-1-JS中的event-loop"><a href="#3-1-JS中的event-loop" class="headerlink" title="3.1 JS中的event loop"></a>3.1 JS中的event loop</h3><blockquote><p>众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点）</p></blockquote><ul><li>JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不同的任务源会被分配到不同的 <code>Task</code> 队列中，任务源可以分为 微任务（<code>microtask</code>） 和 宏任务（<code>macrotask</code>）。在 <code>ES6</code> 规范中，<code>microtask</code> 称为 jobs，macrotask 称为 task</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"><span class="comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure><blockquote><p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务</p></blockquote><p><strong>微任务</strong></p><ul><li><code>process.nextTick</code></li><li><code>promise</code></li><li><code>Object.observe</code></li><li><code>MutationObserver</code></li></ul><p><strong>宏任务</strong></p><ul><li><code>script </code></li><li><code>setTimeout</code></li><li><code>setInterval </code></li><li><code>setImmediate </code></li><li><code>I/O </code></li><li><code>UI rendering</code></li></ul><blockquote><p>宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务</p></blockquote><p><strong>所以正确的一次 Event loop 顺序是这样的</strong></p><ul><li>执行同步代码，这属于宏任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 UI</li><li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li></ul><blockquote><p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的响应界面响应，我们可以把操作 <code>DOM</code> 放入微任务中</p></blockquote><h3 id="3-2-Node-中的-Event-loop"><a href="#3-2-Node-中的-Event-loop" class="headerlink" title="3.2 Node 中的 Event loop"></a>3.2 Node 中的 Event loop</h3><ul><li><code>Node</code> 中的 <code>Event loop</code> 和浏览器中的不相同。</li><li><code>Node</code> 的 <code>Event loop</code> 分为<code>6</code>个阶段，它们会按照顺序反复运行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>timer</strong></p><ul><li><code>timers</code> 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code></li><li>一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟</li></ul><p><strong>I/O</strong></p><ul><li><code>I/O</code> 阶段会执行除了 <code>close</code> 事件，定时器和 <code>setImmediate</code> 的回调</li></ul><p>idle, prepare<br>idle, prepare 阶段内部实现</p><p><strong>poll</strong></p><ul><li><p><code>poll</code> 阶段很重要，这一阶段中，系统会做两件事情</p><ul><li>执行到点的定时器</li><li>执行 <code>poll</code> 队列中的事件</li></ul></li><li><p>并且当 poll 中没有定时器的情况下，会发现以下两件事情</p><ul><li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li><li>如果 poll 队列为空，会有两件事发生</li><li>如果有 <code>setImmediate</code> 需要执行，<code>poll</code> 阶段会停止并且进入到 <code>check</code> 阶段执行 <code>setImmediate</code></li><li>如果没有 <code>setImmediate</code> 需要执行，会等待回调被加入到队列中并立即执行回调</li><li>如果有别的定时器需要被执行，会回到 <code>timer</code> 阶段执行回调。</li></ul></li></ul><p><strong>check</strong></p><ul><li><code>check</code> 阶段执行 <code>setImmediate</code></li></ul><p><strong>close callbacks</strong></p><ul><li><code>close callbacks</code> 阶段执行 <code>close</code> 事件</li><li>并且在 <code>Node</code> 中，有些情况下的定时器执行顺序是随机的</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setImmediate&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里可能会输出 setTimeout，setImmediate</span></span><br><span class="line"><span class="comment">// 可能也会相反的输出，这取决于性能</span></span><br><span class="line"><span class="comment">// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate</span></span><br><span class="line"><span class="comment">// 否则会执行 setTimeout</span></span><br></pre></td></tr></table></figure><blockquote><p>上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码在浏览器和 node 中打印情况是不同的</span></span><br><span class="line"><span class="comment">// 浏览器中一定打印 timer1, promise1, timer2, promise2</span></span><br><span class="line"><span class="comment">// node 中可能打印 timer1, timer2, promise1, promise2</span></span><br><span class="line"><span class="comment">// 也可能打印 timer1, promise1, timer2, promise2</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Node</code> 中的 <code>process.nextTick</code> 会先于其他 <code>microtask</code> 执行</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;timer1&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;nextTick&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// nextTick, timer1, promise1</span></span><br></pre></td></tr></table></figure><h2 id="四、Service-Worker"><a href="#四、Service-Worker" class="headerlink" title="四、Service Worker"></a>四、Service Worker</h2><blockquote><p>Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API</p></blockquote><p><strong>目前该技术通常用来做缓存文件，提高首屏速度</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(<span class="string">&quot;sw.js&quot;</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;service worker 注册成功&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;servcie worker 注册失败&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 监听 `install` 事件，回调中缓存所需文件</span></span><br><span class="line">self.addEventListener(<span class="string">&quot;install&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(<span class="string">&quot;my-cache&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([<span class="string">&quot;./index.html&quot;</span>, <span class="string">&quot;./index.js&quot;</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截所有请求事件</span></span><br><span class="line"><span class="comment">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span></span><br><span class="line">self.addEventListener(<span class="string">&quot;fetch&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;fetch source&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b1e8eba68e1c?w=1770&h=722&f=png&s=192277"></p><blockquote><p>在 Cache 中也可以发现我们所需的文件已被缓存</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b20dfc4fcd26?w=1118&h=728&f=png&s=85610"></p><p>当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的</p><h2 id="五、渲染机制"><a href="#五、渲染机制" class="headerlink" title="五、渲染机制"></a>五、渲染机制</h2><p><strong>浏览器的渲染机制一般分为以下几个步骤</strong></p><ul><li>处理 <code>HTML</code> 并构建 <code>DOM</code> 树。</li><li>处理 <code>CSS</code> 构建 <code>CSSOM</code> 树。</li><li>将 <code>DOM</code> 与 <code>CSSOM</code> 合并成一个渲染树。</li><li>根据渲染树来布局，计算每个节点的位置。</li><li>调用 <code>GPU</code> 绘制，合成图层，显示在屏幕上</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/4/11/162b2ab2ec70ac5b?w=900&h=352&f=png&s=49983"></p><ul><li>在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢</li><li>当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM</li></ul><h3 id="5-1-图层"><a href="#5-1-图层" class="headerlink" title="5.1 图层"></a>5.1 图层</h3><blockquote><p>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用</p></blockquote><p><strong>通过以下几个常用属性可以生成新图层</strong></p><ul><li>3D 变换：<code>translate3d</code>、<code>translateZ</code></li><li><code>will-change</code></li><li><code>video</code>、<code>iframe</code> 标签</li><li>通过动画实现的 <code>opacity</code> 动画转换</li><li><code>position: fixed</code></li></ul><h3 id="5-2-重绘（Repaint）和回流（Reflow）"><a href="#5-2-重绘（Repaint）和回流（Reflow）" class="headerlink" title="5.2 重绘（Repaint）和回流（Reflow）"></a>5.2 重绘（Repaint）和回流（Reflow）</h3><ul><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘</li><li>回流是布局或者几何属性需要改变就称为回流</li></ul><blockquote><p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流</p></blockquote><p><strong>所以以下几个动作可能会导致性能问题</strong>：</p><ul><li>改变 window 大小</li><li>改变字体</li><li>添加或删除样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型</li></ul><p><strong>很多人不知道的是，重绘和回流其实和 Event loop 有关</strong></p><ul><li>当 Event loop 执行完 <code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 <code>60Hz </code>的刷新率，每 <code>16ms </code>才会更新一次。</li><li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code> 才会触发一次，并且自带节流功能。</li><li>判断是否触发了<code> media query</code></li><li>更新动画并且发送事件</li><li>判断是否有全屏操作事件</li><li>执行 <code>requestAnimationFrame</code> 回调</li><li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li><li>更新界面</li><li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调</li></ul><p><strong>减少重绘和回流</strong></p><ul><li>使用 <code>translate</code> 替代 <code>top</code></li><li>使用 <code>visibility</code> 替换<code> display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 table 的重新布局</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li><li><code>CSS</code> 选择符从右往左匹配查找，避免 <code>DOM</code> 深度过深</li><li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 <code>video </code>标签，浏览器会自动将该节点变为图层</li></ul></script></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端错误监控</title>
      <link href="2020/12/26/%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/"/>
      <url>2020/12/26/%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><blockquote><p>错误监控包含的内容是：</p></blockquote><ul><li>前端错误的分类</li><li>每种错误的捕获方式</li><li>上报错误的基本原理</li></ul><blockquote><p>面试时，可能有两种问法：</p></blockquote><ul><li>如何监测 <code>js</code> 错误？（开门见山的方式）</li><li>如何保证<strong>产品质量</strong>？（其实问的也是错误监控）</li></ul><h2 id="2-前端错误的分类"><a href="#2-前端错误的分类" class="headerlink" title="2 前端错误的分类"></a>2 前端错误的分类</h2><p>包括两种：</p><ul><li>即时运行错误（代码错误）</li><li>资源加载错误</li></ul><h2 id="3-每种错误的捕获方式"><a href="#3-每种错误的捕获方式" class="headerlink" title="3 每种错误的捕获方式"></a>3 每种错误的捕获方式</h2><h3 id="3-1-即时运行错误的捕获方式"><a href="#3-1-即时运行错误的捕获方式" class="headerlink" title="3.1 即时运行错误的捕获方式"></a>3.1 即时运行错误的捕获方式</h3><p><strong>方式1</strong>：<code>try ... catch</code>。</p><blockquote><p>这种方式要部署在代码中。</p></blockquote><p><strong>方式2：</strong><code>window.onerror</code>函数。这个函数是全局的。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">msg, url, row, col, error</span>) </span>{ ... }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>参数解释：</p></blockquote><ul><li><code>msg</code>为异常基本信息</li><li><code>source</code>为发生异常<code>Javascript</code>文件的<code>url</code></li><li><code>row</code>为发生错误的行号</li></ul><blockquote><p>方式二中的<code>window.onerror</code>是属于DOM0的写法，我们也可以用DOM2的写法：<code>window.addEventListener("error", fn);</code>也可以。</p></blockquote><p><strong>问题延伸1：</strong></p><p><code>window.onerror</code>默认无法捕获<strong>跨域</strong>的<code>js</code>运行错误。捕获出来的信息如下：（基本属于无效信息）</p><blockquote><p>比如说，我们的代码想引入<code>B</code>网站的<code>b.js</code>文件，怎么捕获它的异常呢？</p></blockquote><p><strong>解决办法</strong>：在方法二的基础之上，做如下操作：</p><ol><li>在<code>b.js</code>文件里，加入如下 <code>response</code> <code>header</code>，表示允许跨域：（或者世界给静态资源<code>b.js</code>加这个 response header）</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>引入第三方的文件<code>b.js</code>时，在<code>&lt;script&gt;</code>标签中增加<code>crossorigin</code>属性；</li></ol><p><strong>问题延伸2：</strong></p><blockquote><p>只靠方式二中的<code>window.onerror</code>是不够的，因为我们无法获取文件名是什么，不知道哪里出了错误。解决办法：把<strong>堆栈</strong>信息作为msg打印出来，堆栈里很详细。</p></blockquote><h3 id="3-2-资源加载错误的捕获方式"><a href="#3-2-资源加载错误的捕获方式" class="headerlink" title="3.2 资源加载错误的捕获方式"></a>3.2 资源加载错误的捕获方式</h3><blockquote><p>上面的<code>window.onerror</code>只能捕获即时运行错误，无法捕获资源加载错误。原理是：资源加载错误，并不会向上冒泡，<code>object.onerror</code>捕获后就会终止（不会冒泡给<code>window</code>），所以<code>window.onerror</code>并不能捕获资源加载错误。</p></blockquote><ul><li><strong>方式1</strong>：<code>object.onerror</code>。<code>img</code>标签、<code>script</code>标签等节点都可以添加<code>onerror</code>事件，用来捕获资源加载的错误。</li><li><strong>方式2</strong>：performance.getEntries。可以获取所有已加载资源的加载时长，通过这种方式，可以间接的拿到没有加载的资源错误。</li></ul><p>举例：</p><blockquote><p>浏览器打开一个网站，在<code>Console</code>控制台下，输入：</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">performance.getEntries().forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>{<span class="built_in">console</span>.log(item.name)})</span><br></pre></td></tr></tbody></table></figure><p>或者输入：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">performance.getEntries().forEach(<span class="function"><span class="params">item</span>=&gt;</span>{<span class="built_in">console</span>.log(item.name)})</span><br></pre></td></tr></tbody></table></figure><blockquote><p>上面这个<code>api</code>，返回的是数组，既然是数组，就可以用<code>forEach</code>遍历。打印出来的资源就是<strong>已经成功加载</strong>的资源。；</p></blockquote><p><img src="http://img.smyhvae.com/20180311_2030.png"></p><blockquote><p>再入<code>document.getElementsByTagName('img')</code>，就会显示出所有<strong>需要加载</strong>的的img集合。</p></blockquote><blockquote><p>于是，<code>document.getElementsByTagName('img')</code>获取的资源数组减去通过<code>performance.getEntries()</code>获取的资源数组，剩下的就是没有成功加载的，这种方式可以间接捕获到资源加载错误。</p></blockquote><p>这种方式非常有用，一定要记住。</p><p><strong>方式3；</strong>Error事件捕获。</p><blockquote><p>源加载错误，虽然会阻止冒泡，但是不会阻止捕获。我们可以在捕获阶段绑定error事件。例如：</p></blockquote><p><img src="http://img.smyhvae.com/20180311_2040.png"></p><blockquote><p><strong>总结：</strong>如果我们能回答出后面的两种方式，面试官对我们的印象会大大增加。既可以体现出我们对错误监控的了解，还可以体现出我们对事件模型的掌握。</p></blockquote><h2 id="4-错误上报的两种方式"><a href="#4-错误上报的两种方式" class="headerlink" title="4 错误上报的两种方式"></a>4 错误上报的两种方式</h2><ul><li><strong>方式一</strong>：采用Ajax通信的方式上报（此方式虽然可以上报错误，但是我们并不采用这种方式）</li><li><strong>方式二：</strong>利用Image对象上报（推荐。网站的监控体系都是采用的这种方式）</li></ul><blockquote><p>方式二的实现方式如下：</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">//通过Image对象进行错误上报</span></span></span><br><span class="line"><span class="javascript">    (<span class="keyword">new</span> Image()).src = <span class="string">'http://smyhvae.com/myPath?badjs=msg'</span>;   <span class="comment">// myPath表示上报的路径（我要上报到哪里去）。后面的内容是自己加的参数。</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>打开浏览器，效果如下：</p></blockquote><p><img src="http://img.smyhvae.com/20180311_2055.png"></p><p>上图中，红色那一栏表明，我的请求已经发出去了。点进去看看：</p><p><img src="http://img.smyhvae.com/20180311_2057.png"></p><blockquote><p>这种方式，不需要借助第三方的库，一行代码即可搞定。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能</title>
      <link href="2020/12/26/%E6%80%A7%E8%83%BD/"/>
      <url>2020/12/26/%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="一、网络相关"><a href="#一、网络相关" class="headerlink" title="一、网络相关"></a>一、网络相关</h2><h3 id="1-1-DNS-预解析"><a href="#1-1-DNS-预解析" class="headerlink" title="1.1 DNS 预解析"></a>1.1 DNS 预解析</h3><ul><li>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP</li></ul><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//yuchengkai.cn"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="1-2-缓存"><a href="#1-2-缓存" class="headerlink" title="1.2 缓存"></a>1.2 缓存</h3><ul><li>缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度</li><li>通常浏览器缓存策略分为两种：强缓存和协商缓存</li></ul><p><strong>强缓存</strong></p><blockquote><p>实现强缓存可以通过两种响应头实现：<code>Expires </code>和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，<code>state code </code>为 <code>200</code></p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 22 Oct 2018 08:41:00 GMT</span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>Expires</code> 是 <code>HTTP / 1.0</code> 的产物，表示资源会在 <code>Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 <code>Expires</code> 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-control: max-age=30</span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>Cache-Control</code> 出现于 <code>HTTP / 1.1</code>，优先级高于 <code>Expires</code> 。该属性表示资源会在 <code>30</code> 秒后过期，需要再次请求</p></blockquote><p><strong>协商缓存</strong></p><ul><li>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304</li><li>协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式</li></ul><p>Last-Modified 和 If-Modified-Since</p><ul><li><code>Last-Modified</code> 表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified </code>的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来</li><li>但是如果在本地打开缓存文件，就会造成 <code>Last-Modified</code> 被修改，所以在 <code>HTTP / 1.1</code> 出现了 <code>ETag</code></li></ul><p>ETag 和 If-None-Match</p><ul><li><code>ETag</code> 类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 <code>ETag</code> 优先级比 <code>Last-Modified</code> 高</li></ul><p><strong>选择合适的缓存策略</strong></p><blockquote><p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p></blockquote><ul><li>对于某些不需要缓存的资源，可以使用 <code>Cache-control: no-store</code> ，表示该资源不需要缓存</li><li>对于频繁变动的资源，可以使用 <code>Cache-Control: no-cache</code> 并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li><li>对于代码文件来说，通常使用 <code>Cache-Control: max-age=31536000</code> 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件</li></ul><h3 id="1-3-使用-HTTP-2-0"><a href="#1-3-使用-HTTP-2-0" class="headerlink" title="1.3 使用 HTTP / 2.0"></a>1.3 使用 HTTP / 2.0</h3><ul><li>因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间</li><li>在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小</li></ul><h3 id="1-4-预加载"><a href="#1-4-预加载" class="headerlink" title="1.4 预加载"></a>1.4 预加载</h3><ul><li>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载</li><li>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</li></ul><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好</p></blockquote><h3 id="1-5-预渲染"><a href="#1-5-预渲染" class="headerlink" title="1.5 预渲染"></a>1.5 预渲染</h3><blockquote><p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prerender"</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span>&gt;</span> </span><br></pre></td></tr></tbody></table></figure><ul><li>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染</li></ul><h2 id="二、优化渲染过程"><a href="#二、优化渲染过程" class="headerlink" title="二、优化渲染过程"></a>二、优化渲染过程</h2><h3 id="2-1-懒执行"><a href="#2-1-懒执行" class="headerlink" title="2.1 懒执行"></a>2.1 懒执行</h3><ul><li>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒</li></ul><h3 id="2-2-懒加载"><a href="#2-2-懒加载" class="headerlink" title="2.2 懒加载"></a>2.2 懒加载</h3><ul><li>懒加载就是将不关键的资源延后加载</li></ul><blockquote><p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载</p></blockquote><ul><li>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等</li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何解决跨域问题</title>
      <link href="2020/12/26/cross-domain/"/>
      <url>2020/12/26/cross-domain/</url>
      
        <content type="html"><![CDATA[<h3 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h3><hr><p><strong>JSONP：</strong></p><ul><li>原理是：动态插入<code>script</code>标签，通过<code>script</code>标签引入一个<code>js</code>文件，这个<code>js</code>文件载入成功后会执行我们在<code>url</code>参数中指定的函数，并且会把我们需要的<code>json</code>数据作为参数传入</li><li>由于同源策略的限制，<code>XmlHttpRequest</code>只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过<code>script</code>标签实现跨域请求，然后在服务端输出<code>JSON</code>数据并执行回调函数，从而解决了跨域的数据请求</li><li>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求</li><li><code>JSONP</code>：<code>json+padding</code>（内填充），顾名思义，就是把<code>JSON</code>填充到一个盒子里</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createJs</span>(<span class="params">sUrl</span>)</span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> oScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    oScript.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    oScript.src = sUrl;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(oScript);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">createJs(<span class="string">'jsonp.js'</span>);</span><br><span class="line"></span><br><span class="line">box({</span><br><span class="line">   <span class="string">'name'</span>: <span class="string">'test'</span></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span>(<span class="params">json</span>)</span>{</span><br><span class="line">    alert(json.name);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>CORS</strong></p><ul><li>服务器端对于<code>CORS</code>的支持，主要就是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许<code>Ajax</code>进行跨域的访问</li></ul><p><strong>通过修改document.domain来跨子域</strong></p><ul><li>将子域和主域的<code>document.domain</code>设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用<code>document.domain</code>进行跨域。主域相同的使用<code>document.domain</code></li></ul><p><strong>使用window.name来进行跨域</strong></p><ul><li><code>window</code>对象有个name属性，该属性有个特征：即在一个窗口(<code>window</code>)的生命周期内,窗口载入的所有的页面都是共享一个<code>window.name</code>的，每个页面对window.name都有读写的权限，<code>window.name</code>是持久存在一个窗口载入过的所有页面中的</li></ul><p><strong>使用HTML5中新引进的window.postMessage方法来跨域传送数据</strong></p><ul><li>还有<code>flash</code>、在服务器上设置代理页面等跨域方式。个人认为<code>window.name</code>的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法</li></ul><p><strong>如何解决跨域问题?</strong></p><ul><li><p><code>jsonp</code>、 <code>iframe</code>、<code>window.name</code>、<code>window.postMessage</code>、服务器上设置代理页面</p></li><li><p>如何解决跨域问题?</p><ul><li><code>document.domain + iframe</code>：要求主域名相同 //只能跨子域</li><li><code>JSONP(JSON with Padding)``：</code>response: callback(data)`` //只支持 GET 请求</li><li>跨域资源共享<code>CORS(XHR2)``：</code>Access-Control-Allow` //兼容性 IE10+</li><li>跨文档消息传输(HTML5)：<code>postMessage + onmessage</code>  //兼容性 IE8+</li><li><code>WebSocket(HTML5)：new WebSocket(url) + onmessage</code> //兼容性 IE10+</li><li>服务器端设置代理请求：服务器端不受同源策略限制</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请你谈谈Cookie的弊端</title>
      <link href="2020/12/26/cookie/"/>
      <url>2020/12/26/cookie/</url>
      
        <content type="html"><![CDATA[<p><strong>请你谈谈Cookie的弊端</strong></p><ul><li><p>cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的</p></li><li><p>第一：每个特定的域名下最多生成20个cookie</p></li><li><p>1.IE6或更低版本最多20个cookie</p></li><li><p>2.IE7和之后的版本最后可以有50个cookie。</p></li><li><p>3.Firefox最多50个cookie</p></li><li><p>4.chrome和Safari没有做硬性限制</p></li></ul><p><strong>请你谈谈Cookie的弊端？</strong></p><ul><li>每个特定的域名下最多生成的 cookie 个数有限制</li><li>IE 和 Opera 会清理近期最少使用的 cookie，Firefox 会随机清理 cookie</li><li>cookie 的最大大约为 4096 字节，为了兼容性，一般设置不超过 4095 字节</li><li>如果 cookie 被人拦截了，就可以取得所有的 session 信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="2020/12/26/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%8F%8ABFC/"/>
      <url>2020/12/26/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%8F%8ABFC/</url>
      
        <content type="html"><![CDATA[<h2 id="题目：谈一谈你对CSS盒模型的认识"><a href="#题目：谈一谈你对CSS盒模型的认识" class="headerlink" title="题目：谈一谈你对CSS盒模型的认识"></a>题目：谈一谈你对CSS盒模型的认识</h2><blockquote><p>专业的面试，一定会问 <code>CSS</code> 盒模型。对于这个题目，我们要回答一下几个方面：</p></blockquote><ol><li>基本概念：<code>content</code>、<code>padding</code>、<code>margin</code></li><li>标准盒模型、<code>IE</code>盒模型的区别。不要漏说了<code>IE</code>盒模型，通过这个问题，可以筛选一部分人</li><li><code>CSS</code>如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。</li><li><code>JS</code>如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。</li><li>实例题：根据盒模型解释<strong>边距重叠</strong>。</li></ol><blockquote><p>前四个方面是逐渐递增，第五个方面，却鲜有人知。</p></blockquote><ol start="6"><li><code>BFC</code>（边距重叠解决方案）或<code>IFC</code>。</li></ol><blockquote><p>如果能回答第五条，就会引出第六条。<code>BFC</code>是面试频率较高的。</p></blockquote><p><strong>总结</strong>：以上几点，从上到下，知识点逐渐递增，知识面从理论、<code>CSS</code>、<code>JS</code>，又回到<code>CSS</code>理论</p><p>接下来，我们把上面的六条，依次讲解。</p><p><strong>标准盒模型和IE盒子模型</strong></p><p>标准盒子模型：</p><p><img src="http://img.smyhvae.com/2015-10-03-css-27.jpg"></p><p><code>IE</code>盒子模型：</p><p><img src="http://img.smyhvae.com/2015-10-03-css-30.jpg"></p><p>上图显示：</p><blockquote><p>在 <code>CSS</code> 盒子模型 (<code>Box Model</code>) 规定了元素处理元素的几种方式：</p></blockquote><ul><li><code>width</code>和<code>height</code>：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）。</li><li><code>padding</code>：内边距。</li><li><code>border</code>：边框。</li><li><code>margin</code>：外边距。</li></ul><blockquote><p><code>CSS</code>盒模型和<code>IE</code>盒模型的区别：</p></blockquote><ul><li><p>在<strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p></li><li><p><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+border+padding</strong>的宽度和高度。</p></li></ul><p><strong>CSS如何设置这两种模型</strong></p><p>代码如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置当前盒子为 标准盒模型（默认） */</span></span><br><span class="line">box-sizing: content-box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置当前盒子为 IE盒模型 */</span></span><br><span class="line">box-sizing: border-box;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>备注：盒子默认为标准盒模型。</p></blockquote><p><strong>JS如何设置、获取盒模型对应的宽和高</strong></p><blockquote><p>方式一：通过<code>DOM</code>节点的 <code>style</code> 样式获取</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.style.width/height;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>缺点：通过这种方式，只能获取<strong>行内样式</strong>，不能获取<code>内嵌</code>的样式和<code>外链</code>的样式。</p></blockquote><p>这种方式有局限性，但应该了解。</p><blockquote><p>方式二（通用型）</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.getComputedStyle(element).width/height;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>方式二能兼容 <code>Chrome</code>、火狐。是通用型方式。</p></blockquote><blockquote><p>方式三（IE独有的）</p></blockquote><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.currentStyle.width/height;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。</p></blockquote><blockquote><p>方式四</p></blockquote><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.getBoundingClientRect().width/height;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>此 <code>api</code> 的作用是：获取一个元素的绝对位置。绝对位置是视窗 <code>viewport</code> 左上角的绝对位置。此 <code>api</code> 可以拿到四个属性：<code>left</code>、<code>top</code>、<code>width</code>、<code>height</code>。</p></blockquote><p><strong>总结：</strong></p><blockquote><p>上面的四种方式，要求能说出来区别，以及哪个的通用型更强。</p></blockquote><p><strong>margin塌陷/margin重叠</strong></p><p><strong>标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin</strong>(水平方向的<code>margin</code>是可以叠加的，即水平方向没有塌陷现象)。</p><blockquote><p>PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有<code>margin</code>重叠的现象的。</p></blockquote><blockquote><p>我们来看几个例子。</p></blockquote><p><strong>兄弟元素之间</strong></p><p>如下图所示：</p><p><img src="http://img.smyhvae.com/20170805_0904.png"></p><p><strong>子元素和父元素之间</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        * {</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father</span> {</span></span><br><span class="line">            background: green;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 给儿子设置margin-top为10像素 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.son</span> {</span></span><br><span class="line">            height: 100px;</span><br><span class="line">            margin-top: 10px;</span><br><span class="line">            background: red;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>上面的代码中，儿子的<code>height</code>是 <code>100p</code>x，<code>magin-top</code> 是<code>10px</code>。注意，此时父亲的 <code>height</code> 是<code>100</code>，而不是<code>110</code>。因为儿子和父亲在竖直方向上，共一个<code>margin</code>。</p></blockquote><p>儿子这个盒子：</p><p><img src="http://img.smyhvae.com/20180305_2216.png"></p><p>父亲这个盒子：</p><p><img src="http://img.smyhvae.com/20180305_2217.png"></p><blockquote><p>上方代码中，如果我们给父亲设置一个属性：<code>overflow: hidden</code>，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。</p></blockquote><p><strong>善于使用父亲的padding，而不是儿子的margin</strong></p><blockquote><p>其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。</p></blockquote><p>我们来看一个奇怪的现象。现在有下面这样一个结构：（<code>div</code>中放一个<code>p</code>）</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>上面的结构中，我们尝试通过给儿子<code>p</code>一个<code>margin-top:50px;</code>的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象：</p></blockquote><p><img src="http://img.smyhvae.com/20170806_1537.png"></p><blockquote><p>此时我们给父亲<code>div</code>加一个<code>border</code>属性，就正常了：</p></blockquote><p><img src="http://img.smyhvae.com/20170806_1544.png"></p><blockquote><p>如果父亲没有<code>border</code>，那么儿子的<code>margin</code>实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。</p></blockquote><p><strong>margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。</strong></p><blockquote><p>所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的`margin。</p></blockquote><p><strong>BFC（边距重叠解决方案）</strong></p><blockquote><p><code>BFC（Block Formatting Context）</code>：块级格式化上下文。你可以把它理解成一个独立的区域。</p></blockquote><p>另外还有个概念叫<code>IFC</code>。不过，<code>BFC</code>问得更多。</p><p><strong>BFC 的原理/BFC的布局规则【非常重要】</strong></p><blockquote><p><code>BFC</code> 的原理，其实也就是 <code>BFC</code> 的渲染规则（能说出以下四点就够了）。包括：</p></blockquote><ol><li>BFC <strong>内部的</strong>子元素，在垂直方向，<strong>边距会发生重叠</strong>。</li><li>BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看<code>举例1</code>）</li><li><strong>BFC区域不与旁边的<code>float box</code>区域重叠</strong>。（可以用来清除浮动带来的影响）。（稍后看<code>举例2</code>）</li><li>计算<code>BFC</code>的高度时，浮动的子元素也参与计算。（稍后看<code>举例3</code>）</li></ol><p><strong>如何生成BFC</strong></p><blockquote><p>有以下几种方法：</p></blockquote><ul><li>方法1：<code>overflow</code>: 不为<code>visible</code>，可以让属性是 <code>hidden</code>、<code>auto</code>。【最常用】</li><li>方法2：浮动中：<code>float</code>的属性值不为<code>none</code>。意思是，只要设置了浮动，当前元素就创建了<code>BFC</code>。</li><li>方法3：定位中：只要<code>posiiton</code>的值不是 s<code>tatic</code>或者是<code>relative</code>即可，可以是<code>absolute</code>或<code>fixed</code>，也就生成了一个<code>BFC</code>。</li><li>方法4：<code>display</code>为<code>inline-block</code>, <code>table-cell</code>, <code>table-caption</code>, <code>flex</code>, <code>inline-flex</code></li></ul><p><strong>BFC 的应用</strong></p><p><strong>举例1：</strong>解决 margin 重叠</p><blockquote><p>当父元素和子元素发生 <code>margin</code> 重叠时，解决办法：<strong>给子元素或父元素创建BFC</strong>。</p></blockquote><p>比如说，针对下面这样一个 <code>div</code> 结构：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>上面的<code>div</code>结构中，如果父元素和子元素发生<code>margin</code>重叠，我们可以给子元素创建一个 <code>BFC</code>，就解决了：</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"son"</span> <span class="attr">style</span>=<span class="string">"overflow: hidden"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>因为<strong>第二条：BFC区域是一个独立的区域，不会影响外面的元素</strong>。</p></blockquote><p><strong>举例2</strong>：BFC区域不与float区域重叠：</p><p>针对下面这样一个div结构；</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> {</span></span><br><span class="line">            background: pink;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.left</span> {</span></span><br><span class="line">            float: left;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: green;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.right</span> {</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span>: 150<span class="selector-tag">px</span>;  <span class="comment">/*右侧标准流里的元素，比左侧浮动的元素要高*/</span></span></span><br><span class="line">            background: red;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"father-layout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">        左侧，生命壹号</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">        右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180306_0825.png"></p><blockquote><p>上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。</p></blockquote><p><strong>如果要解决这个问题，可以将右侧的元素创建BFC</strong>，因为<strong>第三条：BFC区域不与<code>float box</code>区域重叠</strong>。解决办法如下：（将right区域添加overflow属性）</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span> <span class="attr">style</span>=<span class="string">"overflow: hidden"</span>&gt;</span></span><br><span class="line">    右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="http://img.smyhvae.com/20180306_0827.png"></p><p>上图表明，解决之后，<code>father-layout</code>的背景色显现出来了，说明问题解决了。</p><p><strong>举例3：</strong>清除浮动</p><p>现在有下面这样的结构：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father</span> {</span></span><br><span class="line">            background: pink;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.son</span> {</span></span><br><span class="line">            float: left;</span><br><span class="line">            background: green;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span></span><br><span class="line">        生命壹号</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180306_0840.png"></p><p>上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓<strong>有高度的盒子，才能关住浮动</strong>。</p><blockquote><p>如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 <code>overflow=hidden</code>属性即可， 增加之后，效果如下：</p></blockquote><p><img src="http://img.smyhvae.com/20180306_0845.png"></p><blockquote><p>为什么父元素成为BFC之后，就有了高度呢？这就回到了<strong>第四条：计算BFC的高度时，浮动元素也参与计算</strong>。意思是，<strong>在计算BFC的高度时，子元素的float box也会参与计算</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="2020/12/26/CSS/"/>
      <url>2020/12/26/CSS/</url>
      
        <content type="html"><![CDATA[<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><hr><p><strong>display: none; 与 visibility: hidden; 的区别</strong></p><ul><li>联系：它们都能让元素不可见</li><li>区别：<ul><li><code>display:none</code>;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility: hidden</code>;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见</li><li><code>display: none</code>;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；<code>visibility:hidden</code>;是继承属性，子孙节点消失由于继承了<code>hidden</code>，通过设置<code>visibility: visible</code>;可以让子孙节点显式</li><li>修改常规流中元素的<code>display</code>通常会造成文档重排。修改<code>visibility</code>属性只会造成本元素的重绘</li><li>读屏器不会读取<code>display: none;</code>元素内容；会读取<code>visibility: hidden</code>元素内容</li></ul></li></ul><p><strong>css hack原理及常用hack</strong></p><ul><li>原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。</li><li>常见的hack有<ul><li>属性hack</li><li>选择器hack</li><li>IE条件注释</li></ul></li></ul><p><strong>link 与 @import 的区别</strong></p><ul><li><code>link</code> 是<code>HTML</code>方式， <code>@import</code> 是<code>CSS</code>方式</li><li><code>link </code>最大限度支持并行下载，<code> @import</code> 过多嵌套导致串行下载，出现FOUC</li><li><code>link</code> 可以通过 <code>rel="alternate stylesheet"</code> 指定候选样式</li><li>浏览器对 <code>link</code> 支持早于<code> @import</code> ，可以使用 <code>@import</code> 对老浏览器隐藏样式</li><li><code>@import</code> 必须在样式规则之前，可以在<code>css</code>文件中引用其他文件</li><li>总体来说：<code>link</code>优于<code>@import</code></li></ul><p><strong>CSS有哪些继承属性</strong></p><ul><li>关于文字排版的属性如：<ul><li><code>font</code><ul><li><code>word-break</code></li><li><code>letter-spacing</code></li><li><code>text-align</code></li><li><code>text-rendering</code></li><li><code>word-spacing</code></li><li><code>white-space</code></li><li><code>text-indent</code></li><li><code>text-transform</code></li><li><code>text-shadow</code></li></ul></li><li><code>line-height</code></li><li><code>color</code></li><li><code>visibility</code></li><li><code>cursor</code></li></ul></li></ul><p><strong>display,float,position的关系</strong></p><ul><li><p>如果 <code>display</code> 为<code>none</code>，那么<code>position</code>和<code>float</code>都不起作用，这种情况下元素不产生框</p></li><li><p>否则，如果<code>position</code>值为<code>absolute</code>或者<code>fixed</code>，框就是绝对定位的，<code>float</code>的计算值为<code>none</code>，<code>display</code>根据下面的表格进行调整</p></li><li><p>否则，如果<code>float</code>不是<code>none</code>，框是浮动的，<code>display</code>根据下表进行调整</p></li><li><p>否则，如果元素是根元素，<code>display</code>根据下表进行调整</p></li><li><p>其他情况下<code>display</code>的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整 <code>display</code></p><p><img src="https://images2018.cnblogs.com/blog/715962/201805/715962-20180513012245079-391725349.png" alt="图片转自网络"></p></li></ul><p><strong>外边距折叠(collapsing margins)</strong></p><ul><li>毗邻的两个或多个 <code>margin</code> 会合并成一个<code>margin</code>，叫做外边距折叠。规则如下：<ul><li>两个或多个毗邻的普通流中的块元素垂直方向上的<code>margin</code>会折叠</li><li>浮动元素或<code>inline-block</code>元素或绝对定位元素的<code>margin</code>不会和垂直方向上的其他元素的margin折叠</li><li>创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠</li><li>元素自身的<code>margin-bottom</code>和<code>margin-top</code>相邻时也会折</li></ul></li></ul><p><strong>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</strong></p><ul><li>有两种， IE 盒子模型、W3C 盒子模型；</li><li>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；</li><li>区  别： IE的content部分把 border 和 padding计算了进去;</li></ul><p><strong>CSS选择符有哪些？哪些属性可以继承？</strong></p><ul><li><p>id选择器（ # myid）</p></li><li><p>类选择器（.myclassname）</p></li><li><p>标签选择器（div, h1, p）</p></li><li><p>相邻选择器（h1 + p）</p></li><li><p>子选择器（ul &gt; li）</p></li><li><p>后代选择器（li a）</p></li><li><p>通配符选择器（ * ）</p></li><li><p>属性选择器（a[rel = “external”]）</p></li><li><p>伪类选择器（a:hover, li:nth-child）</p></li><li><p>可继承的样式： <code>font-size font-family color, UL LI DL DD DT</code></p></li><li><p>不可继承的样式：<code>border padding margin width height </code></p></li></ul><p><strong>CSS优先级算法如何计算？</strong></p><ul><li>优先级就近原则，同权重情况下样式定义最近者为准</li><li>载入样式以最后载入的定位为准</li><li>优先级为: <code>!important &gt;  id &gt; class &gt; tag</code> important 比 内联优先级高</li></ul><p><strong>CSS3新增伪类有那些？</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br><span class="line"></span><br><span class="line">:after          在元素之前添加内容,也可以用来做清除浮动。</span><br><span class="line">:before         在元素之后添加内容</span><br><span class="line">:enabled        </span><br><span class="line">:disabled       控制表单控件的禁用状态。</span><br><span class="line">:checked        单选框或复选框被选中</span><br></pre></td></tr></tbody></table></figure><p><strong>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</strong></p><ul><li>给<code>div</code>设置一个宽度，然后添加<code>margin:0 auto</code>属性</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div{</span><br><span class="line">    width:200px;</span><br><span class="line">    margin:0 auto;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><ul><li>居中一个浮动元素</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//确定容器的宽高 宽500 高 300 的层</span><br><span class="line">//设置层的外边距</span><br><span class="line"></span><br><span class="line"> .div {</span><br><span class="line">      width:500px ; height:300px;//高度可以不设</span><br><span class="line">      margin: -150px 0 0 -250px;</span><br><span class="line">      position:relative;         //相对定位</span><br><span class="line">      background-color:pink;     //方便看效果</span><br><span class="line">      left:50%;</span><br><span class="line">      top:50%;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><ul><li>让绝对定位的div居中</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">width: 1200px;</span><br><span class="line">background: none;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">top: 0;</span><br><span class="line">left: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">right: 0;</span><br></pre></td></tr></tbody></table></figure><p><strong>display有哪些值？说明他们的作用</strong></p><ul><li>block         象块类型元素一样显示。</li><li>none          缺省值。象行内元素类型一样显示。</li><li>inline-block  象行内元素一样显示，但其内容象块类型元素一样显示。</li><li>list-item     象块类型元素一样显示，并添加样式列表标记。</li><li>table         此元素会作为块级表格来显示</li><li>inherit       规定应该从父元素继承 display 属性的值</li></ul><p><strong>position的值relative和absolute定位原点是？</strong></p><ul><li>absolute<ul><li>生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。</li></ul></li><li>fixed （老IE不支持）<ul><li>生成绝对定位的元素，相对于浏览器窗口进行定位。</li></ul></li><li>relative<ul><li>生成相对定位的元素，相对于其正常位置进行定位。</li></ul></li><li>static<ul><li>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right - z-index 声明）。</li></ul></li><li>inherit<ul><li>规定从父元素继承 position 属性的值</li></ul></li></ul><p><strong>CSS3有哪些新特性？</strong></p><ul><li>新增各种CSS选择器  （: not(.input)：所有 class 不是“input”的节点）</li><li>圆角           （border-radius:8px）</li><li>多列布局        （multi-column layout）</li><li>阴影和反射        （Shadow\Reflect）</li><li>文字特效      （text-shadow、）</li><li>文字渲染      （Text-decoration）</li><li>线性渐变      （gradient）</li><li>旋转          （transform）</li><li>增加了旋转,缩放,定位,倾斜,动画，多背景</li><li><code>transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:</code></li></ul><p><strong>用纯CSS创建一个三角形的原理是什么？</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 把上、左、右三条边隐藏掉（颜色设为 transparent）</span><br><span class="line">#demo {</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  border-width: 20px;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-color: transparent transparent red transparent;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>一个满屏 品 字布局 如何设计?</strong></p><ul><li>简单的方式：<ul><li>上面的div宽100%，</li><li>下面的两个div分别宽50%，</li><li>然后用float或者inline使其不换行即可</li></ul></li></ul><p><strong>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</strong></p><ul><li><p>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.</p></li><li><p>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一</p></li><li><p>IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;</p></li><li><p>Firefox下,只能使用getAttribute()获取自定义属性。</p><ul><li>解决方法:统一通过getAttribute()获取自定义属性</li></ul></li><li><p> IE下,even对象有x,y属性,但是没有pageX,pageY属性</p></li><li><p> Firefox下,event对象有pageX,pageY属性,但是没有x,y属性</p></li></ul><p><strong>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</strong></p><ul><li>行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了</li></ul><p><strong>为什么要初始化CSS样式</strong></p><ul><li>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异</li></ul><p><strong>对BFC规范(块级格式化上下文：block formatting context)的理解？</strong></p><ul><li>一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型</li><li>不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响</li></ul><p><strong>css定义的权重</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下/// 例子是演示各种定义的权重值：</span><br><span class="line"></span><br><span class="line">/*权重为1*/</span><br><span class="line">div{</span><br><span class="line">}</span><br><span class="line">/*权重为10*/</span><br><span class="line">.class1{</span><br><span class="line">}</span><br><span class="line">/*权重为100*/</span><br><span class="line">#id1{</span><br><span class="line">}</span><br><span class="line">/*权重为100+1=101*/</span><br><span class="line">#id1 div{</span><br><span class="line">}</span><br><span class="line">/*权重为10+1=11*/</span><br><span class="line">.class1 div{</span><br><span class="line">}</span><br><span class="line">/*权重为10+10+1=21*/</span><br><span class="line">.class1 .class2 div{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</span><br></pre></td></tr></tbody></table></figure><p><strong>display:inline-block 什么时候会显示间隙？(携程)</strong></p><ul><li>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</li></ul><p><strong>谈谈浮动和清除浮动</strong></p><ul><li>浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上</li></ul><p><strong>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</strong></p><ul><li>盒子模型构成：内容(content)、内填充(padding)、 边框(border)、外边距(margin)</li><li>IE8及其以下版本浏览器，未声明 DOCTYPE，内容宽高会包含内填充和边框，称为怪异盒模型(IE盒模型)</li><li>标准(W3C)盒模型：元素宽度 = width + padding + border + margin</li><li>怪异(IE)盒模型：元素宽度 = width + margin</li><li>标准浏览器通过设置 css3 的 box-sizing: border-box 属性，触发“怪异模式”解析计算宽高</li></ul><p><strong>box-sizing 常用的属性有哪些？分别有什么作用？</strong></p><ul><li>box-sizing: content-box;  // 默认的标准(W3C)盒模型元素效果</li><li>box-sizing: border-box;   // 触发怪异(IE)盒模型元素的效果</li><li>box-sizing: inherit;      //  继承父元素 box-sizing 属性的值</li></ul><p><strong>CSS选择器有哪些？</strong></p><ul><li>id选择器        #id</li><li>类选择器        .class</li><li>标签选择器      div, h1, p</li><li>相邻选择器      h1 + p</li><li>子选择器        ul &gt; li</li><li>后代选择器      li a</li><li>通配符选择器    *</li><li>属性选择器      a[rel=’external’]</li><li>伪类选择器      a:hover, li:nth-child</li></ul><p><strong>CSS哪些属性可以继承？哪些属性不可以继承？</strong></p><ul><li>可以继承的样式：font-size、font-family、color、list-style、cursor</li><li>不可继承的样式：width、height、border、padding、margin、background</li></ul><p><strong>CSS如何计算选择器优先？</strong></p><ul><li>相同权重，定义最近者为准：行内样式 &gt; 内部样式 &gt; 外部样式</li><li>含外部载入样式时，后载入样式覆盖其前面的载入的样式和内部样式</li><li>选择器优先级: 行内样式[1000] &gt; id[100] &gt; class[10] &gt; Tag[1]</li><li>在同一组属性设置中，!important 优先级最高，高于行内样式</li></ul><p><strong>CSS3新增伪类有哪些？</strong></p><ul><li><p>:root           选择文档的根元素，等同于 html 元素</p></li><li><p>:empty          选择没有子元素的元素</p></li><li><p>:target         选取当前活动的目标元素</p></li><li><p>:not(selector)  选择除 selector 元素意外的元素</p></li><li><p>:enabled        选择可用的表单元素</p></li><li><p>:disabled       选择禁用的表单元素</p></li><li><p>:checked        选择被选中的表单元素</p></li><li><p>:after          在元素内部最前添加内容</p></li><li><p>:before         在元素内部最后添加内容</p></li><li><p>:nth-child(n)      匹配父元素下指定子元素，在所有子元素中排序第n</p></li><li><p>:nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n，从后向前数</p></li><li><p>:nth-child(odd)</p></li><li><p>:nth-child(even)</p></li><li><p>:nth-child(3n+1)</p></li><li><p>:first-child</p></li><li><p>:last-child</p></li><li><p>:only-child</p></li><li><p>:nth-of-type(n)      匹配父元素下指定子元素，在同类子元素中排序第n</p></li><li><p>:nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n，从后向前数</p></li><li><p>:nth-of-type(odd)</p></li><li><p>:nth-of-type(even)</p></li><li><p>:nth-of-type(3n+1)</p></li><li><p>:first-of-type</p></li><li><p>:last-of-type</p></li><li><p>:only-of-type</p></li><li><p>::selection     选择被用户选取的元素部分</p></li><li><p>:first-line     选择元素中的第一行</p></li><li><p>:first-letter   选择元素中的第一个字符</p></li></ul><p><strong>请列举几种隐藏元素的方法</strong></p><ul><li>visibility: hidden;   这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在</li><li>opacity: 0;           CSS3属性，设置0可以使一个元素完全透明</li><li>position: absolute;   设置一个很大的 left 负值定位，使元素定位在可见区域之外</li><li>display: none;        元素会变得不可见，并且不会再占用文档的空间。</li><li>transform: scale(0);  将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留</li><li><code>&lt;div hidden="hidden"&gt;</code> HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态</li><li>height: 0;            将元素高度设为 0 ，并消除边框</li><li>filter: blur(0);      CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中</li></ul><p><strong>rgba() 和 opacity 的透明效果有什么不同？</strong></p><ul><li>opacity 作用于元素以及元素内的所有内容（包括文字）的透明度</li><li>rgba() 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果</li></ul><p><strong>css 属性 content 有什么作用？</strong></p><ul><li>content 属性专门应用在 before/after 伪元素上，用于插入额外内容或样式</li></ul><p><strong>CSS3有哪些新特性？</strong></p><ul><li>新增选择器     p:nth-child(n){color: rgba(255, 0, 0, 0.75)}</li><li>弹性盒模型     display: flex;</li><li>多列布局       column-count: 5;</li><li>媒体查询       @media (max-width: 480px) {.box: {column-count: 1;}}</li><li>个性化字体     @font-face{font-family: BorderWeb; src:url(BORDERW0.eot);}</li><li>颜色透明度     color: rgba(255, 0, 0, 0.75);</li><li>圆角           border-radius: 5px;</li><li>渐变           background:linear-gradient(red, green, blue);</li><li>阴影           box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3);</li><li>倒影           box-reflect: below 2px;</li><li>文字装饰       text-stroke-color: red;</li><li>文字溢出       text-overflow:ellipsis;</li><li>背景效果       background-size: 100px 100px;</li><li>边框效果       border-image:url(bt_blue.png) 0 10;</li><li>转换<ul><li>旋转          transform: rotate(20deg);</li><li>倾斜          transform: skew(150deg, -10deg);</li><li>位移          transform: translate(20px, 20px);</li><li>缩放          transform: scale(.5);</li></ul></li><li>平滑过渡       transition: all .3s ease-in .1s;</li><li>动画           @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;</li></ul><p><strong>请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？</strong></p><ul><li>Flexbox 用于不同尺寸屏幕中创建可自动扩展和收缩布局</li></ul><p><strong>经常遇到的浏览器的JS兼容性有哪些？解决方法是什么？</strong></p><ul><li>当前样式：getComputedStyle(el, null) VS el.currentStyle</li><li>事件对象：e VS window.event</li><li>鼠标坐标：e.pageX, e.pageY VS window.event.x, window.event.y</li><li>按键码：e.which VS event.keyCode</li><li>文本节点：el.textContent VS el.innerText</li></ul><p><strong>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</strong></p><ul><li>li排列受到中间空白(回车/空格)等的影响，因为空白也属于字符，会被应用样式占据空间，产生间隔</li><li>解决办法：在ul设置设置font-size=0,在li上设置需要的文字大小</li></ul><p><strong>什么是外边距重叠？ 重叠的结果是什么？</strong></p><ul><li><p>外边距重叠就是 margin-collapse</p></li><li><p>相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。<br>这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距</p></li><li><p>折叠结果遵循下列计算规则：</p><ul><li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值</li><li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值</li><li>两个外边距一正一负时，折叠结果是两者的相加的和</li></ul></li></ul><p><strong>请写出多种等高布局</strong></p><ul><li>在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假像</li><li>模仿表格布局等高列效果：兼容性不好，在ie6-7无法正常运行</li><li>css3 flexbox 布局： .container{display: flex; align-items: stretch;}</li></ul><p><strong>css垂直居中的方法有哪些？</strong></p><ul><li>如果是单行文本, line-height 设置成和 height 值</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.vertical {</span><br><span class="line">      height: 100px;</span><br><span class="line">      line-height: 100px;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>已知高度的块级子元素，采用绝对定位和负边距</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.container {</span><br><span class="line">  position: relative;</span><br><span class="line">}</span><br><span class="line">.vertical {</span><br><span class="line">  height: 300px;  /*子元素高度*/</span><br><span class="line">  position: absolute;</span><br><span class="line">  top:50%;  /*父元素高度50%*/</span><br><span class="line">  margin-top: -150px; /*自身高度一半*/</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>未知高度的块级父子元素居中，模拟表格布局</li><li>缺点：IE67不兼容，父级 overflow：hidden 失效</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.container {</span><br><span class="line">      display: table;</span><br><span class="line">    }</span><br><span class="line">    .content {</span><br><span class="line">      display: table-cell;</span><br><span class="line">      vertical-align: middle;</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>新增 inline-block 兄弟元素，设置 vertical-align<ul><li>缺点：需要增加额外标签，IE67不兼容</li></ul></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.container {</span><br><span class="line">  height: 100%;/*定义父级高度，作为参考*/</span><br><span class="line">}</span><br><span class="line">.extra .vertical{</span><br><span class="line">  display: inline-block;  /*行内块显示*/</span><br><span class="line">  vertical-align: middle; /*垂直居中*/</span><br><span class="line">}</span><br><span class="line">.extra {</span><br><span class="line">  height: 100%; /*设置新增元素高度为100%*/</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>绝对定位配合 CSS3 位移</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.vertical {</span><br><span class="line">  position: absolute;</span><br><span class="line">  top:50%;  /*父元素高度50%*/</span><br><span class="line">  transform:translateY(-50%, -50%);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>CSS3弹性盒模型</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container {</span><br><span class="line">  display:flex;</span><br><span class="line">  justify-content: center; /*子元素水平居中*/</span><br><span class="line">  align-items: center; /*子元素垂直居中*/</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>圣杯布局的实现原理？</strong></p><ul><li>要求：三列布局；中间主体内容前置，且宽度自适应；两边内容定宽<ul><li>好处：重要的内容放在文档流前面可以优先渲染</li><li>原理：利用相对定位、浮动、负边距布局，而不添加额外标签</li></ul></li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> {</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">190px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.main</span> {</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.left</span> {</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">150px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">190px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>什么是双飞翼布局？实现原理？</strong></p><ul><li>双飞翼布局：对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局</li><li>原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。</li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> {</span><br><span class="line">    <span class="comment">/*padding-left:150px;*/</span></span><br><span class="line">    <span class="comment">/*padding-right:190px;*/</span></span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.main-wrap</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.main</span> {</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">190px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.left</span> {</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="comment">/*position: relative;*/</span></span><br><span class="line">    <span class="comment">/*left:-150px;*/</span></span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">190px</span>;</span><br><span class="line">    <span class="comment">/*position:relative;*/</span></span><br><span class="line">    <span class="comment">/*right:-190px;*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>在CSS样式中常使用 px、em 在表现上有什么区别？</strong></p><ul><li>px 相对于显示器屏幕分辨率，无法用浏览器字体放大功能</li><li>em 值并不是固定的，会继承父级的字体大小： em = 像素值 / 父级font-size</li></ul><p><strong>为什么要初始化CSS样式？</strong></p><ul><li>不同浏览器对有些标签样式的默认值解析不同</li><li>不初始化CSS会造成各现浏览器之间的页面显示差异</li><li>可以使用 reset.css 或 Normalize.css 做 CSS 初始化</li></ul><p><strong>解释下什么是浮动和它的工作原理？</strong></p><ul><li>非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。<br>此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</li><li>工作原理：<ul><li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li><li>浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li></ul></li></ul><p><strong>浮动元素引起的问题？</strong></p><ul><li>父元素的高度无法被撑开，影响与父元素同级的元素</li><li>与浮动元素同级的非浮动元素会跟随其后</li></ul><p><strong>列举几种清除浮动的方式？</strong></p><ul><li>添加额外标签，例如 <code>&lt;div style="clear:both"&gt;&lt;/div&gt;</code></li><li>使用 br 标签和其自身的 clear 属性，例如 <code>&lt;br clear="all" /&gt;</code></li><li>父元素设置 overflow：hidden; 在IE6中还需要触发 hasLayout，例如zoom：1;</li><li>父元素也设置浮动</li><li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout</li></ul><p><strong>清除浮动最佳实践（after伪元素闭合浮动）：</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after{</span><br><span class="line">    content: "\200B";</span><br><span class="line">    display: table; </span><br><span class="line">    height: 0;</span><br><span class="line">    clear: both;</span><br><span class="line">  }</span><br><span class="line">  .clearfix{</span><br><span class="line">    *zoom: 1;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>  <strong>什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC？</strong></p><ul><li>当使用 @import 导入 CSS 时，会导致某些页面在 IE 出现奇怪的现象：<br>没有样式的页面内容显示瞬间闪烁，这种现象称为“文档样式短暂失效”，简称为FOUC</li><li>产生原因：当样式表晚于结构性html加载时，加载到此样式表时，页面将停止之前的渲染。</li><li>等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。</li><li>解决方法：使用 link 标签将样式表放在文档 head</li></ul><p><strong>介绍使用过的 CSS 预处理器？</strong></p><ul><li>CSS 预处理器基本思想：为 CSS 增加了一些编程的特性（变量、逻辑判断、函数等）</li><li>开发者使用这种语言进行进行 Web 页面样式设计，再编译成正常的 CSS 文件使用</li><li>使用 CSS 预处理器，可以使 CSS 更加简洁、适应性更强、可读性更佳，无需考虑兼容性</li><li>最常用的 CSS 预处理器语言包括：Sass（SCSS）和 LESS</li></ul><p><strong>CSS优化、提高性能的方法有哪些？</strong></p><ul><li>多个css合并，尽量减少HTTP请求</li><li>将css文件放在页面最上面</li><li>移除空的css规则</li><li>避免使用CSS表达式</li><li>选择器优化嵌套，尽量避免层级过深</li><li>充分利用css继承属性，减少代码量</li><li>抽象提取公共样式，减少代码量</li><li>属性值为0时，不加单位</li><li>属性值为小于1的小数时，省略小数点前面的0</li><li>css雪碧图</li></ul><p><strong>浏览器是怎样解析CSS选择器的？</strong></p><ul><li>浏览器解析 CSS 选择器的方式是从右到左</li></ul><p><strong>在网页中的应该使用奇数还是偶数的字体？</strong></p><ul><li>在网页中的应该使用“偶数”字体：<ul><li>偶数字号相对更容易和 web 设计的其他部分构成比例关系</li><li>使用奇数号字体时文本段落无法对齐</li><li>宋体的中文网页排布中使用最多的就是 12 和 14</li></ul></li></ul><p><strong>margin和padding分别适合什么场景使用？</strong></p><ul><li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin</li><li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding</li></ul><p><strong>抽离样式模块怎么写，说出思路？</strong></p><ul><li>CSS可以拆分成2部分：公共CSS 和 业务CSS：<ul><li>网站的配色，字体，交互提取出为公共CSS。这部分CSS命名不应涉及具体的业务</li><li>对于业务CSS，需要有统一的命名，使用公用的前缀。可以参考面向对象的CSS</li></ul></li></ul><p><strong>元素竖向的百分比设定是相对于容器的高度吗？</strong></p><ul><li>元素竖向的百分比设定是相对于容器的宽度，而不是高度</li></ul><p><strong>全屏滚动的原理是什么？ 用到了CSS的那些属性？</strong></p><ul><li>原理类似图片轮播原理，超出隐藏部分，滚动时显示</li><li>可能用到的CSS属性：overflow:hidden; transform:translate(100%, 100%); display:none;</li></ul><p><strong>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</strong></p><ul><li>响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本</li><li>基本原理是利用CSS3媒体查询，为不同尺寸的设备适配不同样式</li><li>对于低版本的IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容：</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  screenRespond();</span><br><span class="line">});</span><br><span class="line">screenRespond();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">screenRespond</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="keyword">var</span> screenWidth = $(<span class="built_in">window</span>).width();</span><br><span class="line"><span class="keyword">if</span>(screenWidth &lt;= <span class="number">1800</span>){</span><br><span class="line">  $(<span class="string">"body"</span>).attr(<span class="string">"class"</span>, <span class="string">"w1800"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(screenWidth &lt;= <span class="number">1400</span>){</span><br><span class="line">  $(<span class="string">"body"</span>).attr(<span class="string">"class"</span>, <span class="string">"w1400"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(screenWidth &gt; <span class="number">1800</span>){</span><br><span class="line">  $(<span class="string">"body"</span>).attr(<span class="string">"class"</span>, <span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>什么是视差滚动效果，如何给每页做不同的动画？</strong></p><ul><li><p>视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验</p></li><li><p>一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的</p></li><li><p>实现原理</p><ul><li>以 “页面滚动条” 作为 “视差动画进度条”</li><li>以 “滚轮刻度” 当作 “动画帧度” 去播放动画的</li><li>监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果</li></ul></li></ul><p><strong>a标签上四个伪类的执行顺序是怎么样的？</strong></p><p><code>link &gt; visited &gt; hover &gt; active</code></p><ul><li>L-V-H-A love hate 用喜欢和讨厌两个词来方便记忆</li></ul><p><strong>伪元素和伪类的区别和作用？</strong></p><ul><li>伪元素 – 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。</li><li>它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p::before {content:"第一章：";}</span><br><span class="line">p::after {content:"Hot!";}</span><br><span class="line">p::first-line {background:red;}</span><br><span class="line">p::first-letter {font-size:30px;}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>伪类 – 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:hover {color: #FF00FF}</span><br><span class="line">p:first-child {color: red}</span><br></pre></td></tr></tbody></table></figure><p><strong>::before 和 :after 中双冒号和单冒号有什么区别？</strong></p><ul><li>在 CSS 中伪类一直用 : 表示，如 :hover, :active 等</li><li>伪元素在CSS1中已存在，当时语法是用 : 表示，如 :before 和 :after</li><li>后来在CSS3中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类</li><li>由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素</li><li>综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容IE的老语法</li></ul><p><strong>如何修改Chrome记住密码后自动填充表单的黄色背景？</strong></p><ul><li>产生原因：由于Chrome默认会给自动填充的input表单加上 input:-webkit-autofill 私有属性造成的</li><li>解决方案1：在form标签上直接关闭了表单的自动填充：autocomplete=”off”</li><li>解决方案2：input:-webkit-autofill { background-color: transparent; }</li></ul><p><strong>input [type=search] 搜索框右侧小图标如何美化？</strong></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">"search"</span>]</span><span class="selector-pseudo">::-webkit-search-cancel-button</span>{</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"images/searchicon.png"</span>) no-repeat <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">15px</span> <span class="number">15px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>网站图片文件，如何点击下载？而非点击预览？</strong></p><p><code>&lt;a href="logo.jpg" download&gt;下载&lt;/a&gt;</code><br><code>&lt;a href="logo.jpg" download="网站LOGO" &gt;下载&lt;/a&gt;</code></p><p><strong>iOS safari 如何阻止“橡皮筋效果”？</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="keyword">var</span> stopScrolling = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>{</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, stopScrolling, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'touchmove'</span>, stopScrolling, <span class="literal">false</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p><strong>你对 line-height 是如何理解的？</strong></p><ul><li>line-height 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离</li><li>如果一个标签没有定义 height 属性，那么其最终表现的高度是由 line-height 决定的</li><li>一个容器没有设置高度，那么撑开容器高度的是 line-height 而不是容器内的文字内容</li><li>把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中</li><li>line-height 和 height 都能撑开一个高度，height 会触发 haslayout，而 line-height 不会</li></ul><p><strong>line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）</strong></p><ul><li>带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li><li>纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</li><li>百分比：将计算后的值传递给后代</li></ul><p><strong>设置元素浮动后，该元素的 display 值会如何变化？</strong></p><ul><li>设置元素浮动后，该元素的 display 值自动变成 block</li></ul><p><strong>怎么让Chrome支持小于12px 的文字？</strong></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.shrink</span>{</span><br><span class="line">  <span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(<span class="number">0.8</span>);</span><br><span class="line">  <span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="attribute">display</span>:inline-block;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）</strong></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-font-smoothing</span>: <span class="selector-tag">antialiased</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>font-style 属性 oblique 是什么意思？</strong></p><ul><li>font-style: oblique; 使没有 italic 属性的文字实现倾斜</li></ul><p><strong>如果需要手动写动画，你认为最小时间间隔是多久？</strong></p><ul><li>16.7ms 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔: 1s / 60 * 1000 ＝ 16.7ms</li></ul><p><strong>display:inline-block 什么时候会显示间隙？</strong></p><ul><li>相邻的 inline-block 元素之间有换行或空格分隔的情况下会产生间距</li><li>非 inline-block 水平元素设置为 inline-block 也会有水平间距</li><li>可以借助 vertical-align:top; 消除垂直间隙</li><li>可以在父级加 font-size：0; 在子元素里设置需要的字体大小，消除垂直间隙</li><li>把 li 标签写到同一行可以消除垂直间隙，但代码可读性差</li></ul><p><strong>overflow: scroll 时不能平滑滚动的问题怎么处理？</strong></p><ul><li>监听滚轮事件，然后滚动到一定距离时用 jquery 的 animate 实现平滑效果。</li></ul><p><strong>一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</strong></p><ul><li>方案1：<br> <code>.sub { height: calc(100%-100px); }</code></li><li>方案2：<br> <code>.container { position:relative; }</code><br> <code>.sub { position: absolute; top: 100px; bottom: 0; }</code></li><li>方案3：<br> <code>.container { display:flex; flex-direction:column; }</code><br> <code>.sub { flex:1; }</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matery主题介绍</title>
      <link href="2020/08/06/hello-world/"/>
      <url>2020/08/06/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-With-Matery"><a href="#Hexo-With-Matery" class="headerlink" title="Hexo-With-Matery"></a>Hexo-With-Matery</h1><p>默认主题为Matery的Hexo博客模板</p><h1 id="My-Blog"><a href="#My-Blog" class="headerlink" title="My Blog"></a>My Blog</h1><p><a href="https://www/">My Blog</a></p><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p><a href="https://ga/">DEMO_HERE</a></p><h1 id="特别之处"><a href="#特别之处" class="headerlink" title="特别之处"></a>特别之处</h1><ul><li><input checked="" disabled="" type="checkbox"> 更改默认Hexo主题为<code>Matery</code>，并去除Hexo默认<code>landscape</code>主题。</li><li><input checked="" disabled="" type="checkbox"> 删除<code>Matery</code>主题文件夹下的<code>.git</code>仓库，便于文件同步。</li><li><input checked="" disabled="" type="checkbox"> 自带<code>categories</code>,<code>tags</code>,<code>about</code>,<code>contant</code>,<code>friend</code>页面。</li><li><input checked="" disabled="" type="checkbox"> 自带<code>hexo-prism-plugin</code>代码高亮插件，并默认禁用Hexo官方代码高亮。</li><li><input checked="" disabled="" type="checkbox"> 自带<code>hexo-generator-search</code>搜索插件。</li><li><input checked="" disabled="" type="checkbox"> 自带<code>hexo-wordcount</code>文章字数统计插件。</li><li><input checked="" disabled="" type="checkbox"> 自带<code>hexo-generator-feed</code>RSS订阅插件。</li><li><input checked="" disabled="" type="checkbox"> 自带<code>hexo-abbrlink</code>链接优化插件。</li><li><input checked="" disabled="" type="checkbox"> 页面标题由<code>subtitle</code>改为<code>page-title</code>，更加简洁明了。</li><li><input checked="" disabled="" type="checkbox"> 默认去除<code>Banner图</code>动态背景颜色<code>Rainbow</code>。</li><li><input checked="" disabled="" type="checkbox"> 去除<code>Banner</code>图片每日更新，提高博客辨识度。</li><li><input checked="" disabled="" type="checkbox"> 修改<code>Banner</code>图片默认格式为<code>.jpeg</code>，减小图片体积，加快博客加载。</li><li><input disabled="" type="checkbox"> 修改<code>Banner</code>图片默认格式为更快的<code>.webp</code>。<code>.webp</code>文件在IOS端兼容性不太好。暂时不添加该功能。</li><li><input disabled="" type="checkbox"> 汉化<code>Hexo</code>根目录下的<code>_config.yml</code>配置文件。 （感谢：Neutron做出贡献）</li><li><input disabled="" type="checkbox"> 汉化<code>Matery</code>根目录下的<code>_config.yml</code>配置文件。 （感谢：Neutron做出贡献）</li></ul><h1 id="需要自定义"><a href="#需要自定义" class="headerlink" title="需要自定义"></a>需要自定义</h1><ul><li>添加DaoVoice在线聊天</li><li>添加Tidio在线聊天</li><li>修改社交链接</li><li>修改打赏二维码图片</li><li>文章的配置在<code>hello-world.md</code>中有完整配置。其中尾部有注释的非必填且可删除。<!--## Quick Start</li></ul><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>–&gt;</p>--></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Matery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
