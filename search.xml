<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试题</title>
      <link href="2020/12/26/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E7%AE%80%E7%89%88%E6%9C%AC/"/>
      <url>2020/12/26/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E7%AE%80%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="一、CSS相关"><a href="#一、CSS相关" class="headerlink" title="一、CSS相关"></a>一、CSS相关</h2><h3 id="1-1-左边定宽，右边自适应方案：float-margin，float-calc"><a href="#1-1-左边定宽，右边自适应方案：float-margin，float-calc" class="headerlink" title="1.1 左边定宽，右边自适应方案：float + margin，float + calc"></a>1.1 左边定宽，右边自适应方案：float + margin，float + calc</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方案1 */</span> </span><br><span class="line"><span class="selector-class">.left</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">120px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 方案2 */</span> </span><br><span class="line"><span class="selector-class">.left</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">120px</span>);</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2-左右两边定宽，中间自适应：float，float-calc-圣杯布局（设置BFC，margin负值法），flex"><a href="#1-2-左右两边定宽，中间自适应：float，float-calc-圣杯布局（设置BFC，margin负值法），flex" class="headerlink" title="1.2 左右两边定宽，中间自适应：float，float + calc, 圣杯布局（设置BFC，margin负值法），flex"></a>1.2 左右两边定宽，中间自适应：float，float + calc, 圣杯布局（设置BFC，margin负值法），flex</h3><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.wrap</span> &gt; <span class="selector-tag">div</span> {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 方案1 */</span></span><br><span class="line"><span class="selector-class">.left</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">120px</span>; </span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 方案2 */</span></span><br><span class="line"><span class="selector-class">.left</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">240px</span>);</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">120px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 方案3 */</span></span><br><span class="line"><span class="selector-class">.wrap</span> {</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.left</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3-左右居中"><a href="#1-3-左右居中" class="headerlink" title="1.3 左右居中"></a>1.3 左右居中</h3><ul><li>行内元素: <code>text-align: center</code></li><li>定宽块状元素: 左右 <code>margin</code> 值为 <code>auto</code></li><li>不定宽块状元素: <code>table</code>布局，<code>position + transform</code></li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方案1 */</span></span><br><span class="line"><span class="selector-class">.wrap</span> {</span><br><span class="line">  <span class="attribute">text-align</span>: center</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">  <span class="comment">/* or */</span></span><br><span class="line">  <span class="comment">/* display: inline-block; */</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 方案2 */</span></span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 方案2 */</span></span><br><span class="line"><span class="selector-class">.wrap</span> {</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">position</span>: absulote;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-4-上下垂直居中"><a href="#1-4-上下垂直居中" class="headerlink" title="1.4 上下垂直居中"></a>1.4 上下垂直居中</h3><ul><li>定高：<code>margin</code>，<code>position + margin</code>(负值)</li><li>不定高：<code>position</code> + <code>transform</code>，<code>flex</code>，<code>IFC + vertical-align:middle</code></li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定高方案1 */</span></span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span> <span class="number">0</span>;   </span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 定高方案2 */</span></span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">25px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 不定高方案1 */</span></span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 不定高方案2 */</span></span><br><span class="line"><span class="selector-class">.wrap</span> {</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 不定高方案3 */</span></span><br><span class="line"><span class="comment">/* 设置 inline-block 则会在外层产生 IFC，高度设为 100% 撑开 wrap 的高度 */</span></span><br><span class="line"><span class="selector-class">.wrap</span><span class="selector-pseudo">::before</span> {</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.wrap</span> {</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.center</span> {</span><br><span class="line">  <span class="attribute">display</span>: inline-block;  </span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-5-盒模型：content（元素内容）-padding（内边距）-border（边框）-margin（外边距）"><a href="#1-5-盒模型：content（元素内容）-padding（内边距）-border（边框）-margin（外边距）" class="headerlink" title="1.5 盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距）"></a>1.5 盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距）</h3><blockquote><p>延伸： <code>box-sizing</code></p></blockquote><ul><li><code>content-box</code>：默认值，总宽度 = <code>margin</code> + <code>border</code> + <code>padding</code> + <code>width</code></li><li><code>border-box</code>：盒子宽度包含 <code>padding</code> 和 <code>border</code>，<code>总宽度 = margin + width</code></li><li><code>inherit</code>：从父元素继承 <code>box-sizing</code> 属性</li></ul><h3 id="1-6-BFC、IFC、GFC、FFC：FC（Formatting-Contexts），格式化上下文"><a href="#1-6-BFC、IFC、GFC、FFC：FC（Formatting-Contexts），格式化上下文" class="headerlink" title="1.6 BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文"></a>1.6 BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文</h3><blockquote><p><code>BFC</code>：块级格式化上下文，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此(按照这个理念来想，只要脱离文档流，肯定就能产生 <code>BFC</code>)。产生 <code>BFC</code> 方式如下</p></blockquote><ul><li><code>float</code> 的值不为 <code>none</code>。</li><li><code>overflow</code> 的值不为 <code>visible</code>。</li><li><code>position</code> 的值不为 <code>relative</code> 和 <code>static</code>。</li><li><code>display</code> 的值为 <code>table-cell</code>, <code>table-caption</code>, <code>inline-block</code>中的任何一个</li></ul><blockquote><p>用处？常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行</p></blockquote><blockquote><p><code>IFC</code>：内联格式化上下文，<code>IFC</code> 的 <code>line</code> <code>box</code>（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 <code>padding/margin</code> 影响)。</p></blockquote><blockquote><p><code>IFC</code>中的<code>line box</code>一般左右都贴紧整个 <code>IFC</code>，但是会因为 <code>float</code> 元素而扰乱。<code>float</code> 元素会位于 IFC 与 <code>line box</code> 之间，使得 <code>line box</code> 宽度缩短。 同个 <code>ifc</code> 下的多个 <code>line box</code> 高度会不同。 <code>IFC</code>中时不可能有块级元素的，当插入块级元素时（如 <code>p</code> 中插入 <code>div </code>）会产生两个匿名块与 <code>div</code> 分隔开，即产生两个 <code>IFC</code> ，每个 <code>IFC</code> 对外表现为块级元素，与 <code>div</code> 垂直排列。</p></blockquote><p>用处？</p><ul><li>水平居中：当一个块要在环境中水平居中时，设置其为 <code>inline-block</code> 则会在外层产生<code>IFC</code>，通过 <code>text-align</code> 则可以使其水平居中。</li><li>垂直居中：创建一个 <code>IFC</code>，用其中一个元素撑开父元素的高度，然后设置其 <code>vertical-align</code>: <code>middle</code>，其他行内元素则可以在此父元素下垂直居中</li></ul><blockquote><ul><li><strong>GFC</strong>：网格布局格式化上下文（<code>display: grid</code>）</li><li><strong>FFC</strong>：自适应格式化上下文（<code>display: flex</code>）</li></ul></blockquote><h2 id="二、JS-基础（ES5）"><a href="#二、JS-基础（ES5）" class="headerlink" title="二、JS 基础（ES5）"></a>二、JS 基础（ES5）</h2><h3 id="2-1-原型"><a href="#2-1-原型" class="headerlink" title="2.1 原型"></a>2.1 原型</h3><blockquote><p>这里可以谈很多，只要围绕 <code>[[ prototype ]]</code> 谈，都没啥问题</p></blockquote><h3 id="2-2-闭包"><a href="#2-2-闭包" class="headerlink" title="2.2 闭包"></a>2.2 闭包</h3><blockquote><p>牵扯作用域，可以两者联系起来一起谈</p></blockquote><h3 id="2-3-作用域"><a href="#2-3-作用域" class="headerlink" title="2.3 作用域"></a>2.3 作用域</h3><blockquote><p>词法作用域，动态作用域</p></blockquote><h3 id="2-4-this"><a href="#2-4-this" class="headerlink" title="2.4 this"></a>2.4 this</h3><blockquote><p>不同情况的调用，<code>this</code>指向分别如何。顺带可以提一下 <code>es6</code> 中箭头函数没有 <code>this</code>, <code>arguments</code>, <code>super</code> 等，这些只依赖包含箭头函数最接近的函数</p></blockquote><h3 id="2-5-call，apply，bind-三者用法和区别"><a href="#2-5-call，apply，bind-三者用法和区别" class="headerlink" title="2.5 call，apply，bind 三者用法和区别"></a>2.5 call，apply，bind 三者用法和区别</h3><blockquote><p>参数、绑定规则（显示绑定和强绑定），运行效率（最终都会转换成一个一个的参数去运行）、运行情况（<code>call</code>，<code>apply</code> 立即执行，<code>bind</code> 是<code>return</code> 出一个 <code>this</code> “固定”的函数，这也是为什么 <code>bind</code> 是强绑定的一个原因）</p></blockquote><blockquote><p>注：“固定”这个词的含义，它指的固定是指只要传进去了 <code>context</code>，则 <code>bind</code> 中 <code>return</code> 出来的函数 <code>this</code> 便一直指向 <code>context</code>，除非 <code>context</code> 是个变量</p></blockquote><h3 id="2-6-变量声明提升"><a href="#2-6-变量声明提升" class="headerlink" title="2.6 变量声明提升"></a>2.6 变量声明提升</h3><blockquote><p><code>js</code> 代码在运行前都会进行 <code>AST</code> 解析，函数申明默认会提到当前作用域最前面，变量申明也会进行提升。但赋值不会得到提升。关于 <code>AST</code> 解析，这里也可以说是形成词法作用域的主要原因</p></blockquote><h2 id="三、JS-基础（ES6）"><a href="#三、JS-基础（ES6）" class="headerlink" title="三、JS 基础（ES6）"></a>三、JS 基础（ES6）</h2><h3 id="3-1-let，const"><a href="#3-1-let，const" class="headerlink" title="3.1 let，const"></a>3.1 let，const</h3><blockquote><p><code>let</code> 产生块级作用域（通常配合 <code>for</code> 循环或者 <code>{}</code> 进行使用产生块级作用域），<code>const</code> 申明的变量是常量（内存地址不变）</p></blockquote><h3 id="3-2-Promise"><a href="#3-2-Promise" class="headerlink" title="3.2 Promise"></a>3.2 Promise</h3><blockquote><p>这里你谈 <code>promise</code>的时候，除了将他解决的痛点以及常用的 <code>API</code> 之外，最好进行拓展把 <code>eventloop</code> 带进来好好讲一下，<code>microtask</code>(微任务)、<code>macrotask</code>(任务) 的执行顺序，如果看过 <code>promise</code> 源码，最好可以谈一谈 原生 <code>Promise</code> 是如何实现的。<code>Promise</code> 的关键点在于<code>callback</code> 的两个参数，一个是 <code>resovle</code>，一个是 <code>reject</code>。还有就是 <code>Promise</code> 的链式调用（<code>Promise.then()</code>，每一个 <code>then</code> 都是一个责任人）</p></blockquote><h3 id="3-3-Generator"><a href="#3-3-Generator" class="headerlink" title="3.3 Generator"></a>3.3 Generator</h3><blockquote><p>遍历器对象生成函数，最大的特点是可以交出函数的执行权</p></blockquote><ul><li><code>function</code> 关键字与函数名之间有一个星号；</li><li>函数体内部使用 <code>yield</code>表达式，定义不同的内部状态；</li><li><code>next </code>指针移向下一个状态</li></ul><blockquote><p>这里你可以说说 <code>Generator</code>的异步编程，以及它的语法糖 <code>async</code> 和 <code>awiat</code>，传统的异步编程。<code>ES6</code> 之前，异步编程大致如下</p></blockquote><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li></ul><blockquote><p>传统异步编程方案之一：协程，多个线程互相协作，完成异步任务。</p></blockquote><h3 id="3-4-async、await"><a href="#3-4-async、await" class="headerlink" title="3.4 async、await"></a>3.4 async、await</h3><blockquote><p><code>Generator</code> 函数的语法糖。有更好的语义、更好的适用性、返回值是 <code>Promise</code>。</p></blockquote><ul><li><code>async =&gt; *</code></li><li><code>await =&gt; yield</code></li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span> (<span class="params">ms</span>) </span>{</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms)    </span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncConsole</span> (<span class="params">value, ms</span>) </span>{</span><br><span class="line">  <span class="keyword">await</span> timeout(ms)</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">}</span><br><span class="line">asyncConsole(<span class="string">'hello async and await'</span>, <span class="number">1000</span>)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注：最好把2，3，4 连到一起讲</p></blockquote><h3 id="3-5-AMD，CMD，CommonJs，ES6-Module：解决原始无模块化的痛点"><a href="#3-5-AMD，CMD，CommonJs，ES6-Module：解决原始无模块化的痛点" class="headerlink" title="3.5 AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点"></a>3.5 AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点</h3><ul><li><strong>AMD</strong>：<code>requirejs</code> 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置</li><li><strong>CMD</strong>：<code>seajs</code> 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近</li><li><strong>CommonJs</strong>：模块输出的是一个值的 <code>copy</code>，运行时加载，加载的是一个对象（<code>module.exports</code> 属性），该对象只有在脚本运行完才会生成</li><li><strong>ES6 Module</strong>：模块输出的是一个值的引用，编译时输出接口，<code>ES6</code>模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li></ul><h2 id="四、框架相关"><a href="#四、框架相关" class="headerlink" title="四、框架相关"></a>四、框架相关</h2><h3 id="4-1-数据双向绑定原理：常见数据绑定的方案"><a href="#4-1-数据双向绑定原理：常见数据绑定的方案" class="headerlink" title="4.1 数据双向绑定原理：常见数据绑定的方案"></a>4.1 数据双向绑定原理：常见数据绑定的方案</h3><ul><li><code>Object.defineProperty（vue）</code>：劫持数据的 <code>getter</code> 和 <code>setter</code></li><li>脏值检测（<code>angularjs</code>）：通过特定事件进行轮循<br>发布/订阅模式：通过消息发布并将消息进行订阅</li></ul><h3 id="4-2-VDOM：三个-part"><a href="#4-2-VDOM：三个-part" class="headerlink" title="4.2 VDOM：三个 part"></a>4.2 VDOM：三个 part</h3><ul><li>虚拟节点类，将真实 <code>DOM </code>节点用 <code>js</code> 对象的形式进行展示，并提供 <code>render</code> 方法，将虚拟节点渲染成真实 <code>DOM</code></li><li>节点 <code>diff</code> 比较：对虚拟节点进行 <code>js</code> 层面的计算，并将不同的操作都记录到 <code>patch</code> 对象</li><li><code>re-render</code>：解析 <code>patch</code> 对象，进行 <code>re-render</code></li></ul><p><strong>补充1：VDOM 的必要性？</strong></p><ul><li><strong>创建真实DOM的代价高</strong>：真实的 <code>DOM</code> 节点 <code>node</code> 实现的属性很多，而 <code>vnode</code> 仅仅实现一些必要的属性，相比起来，创建一个 <code>vnode</code> 的成本比较低。</li><li><strong>触发多次浏览器重绘及回流</strong>：使用 <code>vnode</code> ，相当于加了一个缓冲，让一次数据变动所带来的所有 <code>node</code> 变化，先在 <code>vnode</code> 中进行修改，然后 <code>diff</code> 之后对所有产生差异的节点集中一次对 <code>DOM tree</code> 进行修改，以减少浏览器的重绘及回流。</li></ul><p><strong>补充2：vue 为什么采用 vdom？</strong></p><blockquote><p>引入 <code>Virtual DOM</code> 在性能方面的考量仅仅是一方面。</p></blockquote><ul><li>性能受场景的影响是非常大的，不同的场景可能造成不同实现方案之间成倍的性能差距，所以依赖细粒度绑定及 <code>Virtual DOM</code> 哪个的性能更好还真不是一个容易下定论的问题。</li><li><code>Vue</code> 之所以引入了 <code>Virtual DOM</code>，更重要的原因是为了解耦 <code>HTML</code>依赖，这带来两个非常重要的好处是：</li></ul><blockquote><ul><li>不再依赖 <code>HTML</code> 解析器进行模版解析，可以进行更多的 <code>AOT</code> 工作提高运行时效率：通过模版 <code>AOT</code> 编译，<code>Vue</code> 的运行时体积可以进一步压缩，运行时效率可以进一步提升；</li><li>可以渲染到 <code>DOM</code> 以外的平台，实现 <code>SSR</code>、同构渲染这些高级特性，<code>Weex</code>等框架应用的就是这一特性。</li></ul></blockquote><blockquote><p>综上，<code>Virtual DOM</code> 在性能上的收益并不是最主要的，更重要的是它使得 <code>Vue</code> 具备了现代框架应有的高级特性。</p></blockquote><h3 id="4-3-vue-和-react-区别"><a href="#4-3-vue-和-react-区别" class="headerlink" title="4.3 vue 和 react 区别"></a>4.3 vue 和 react 区别</h3><ul><li>相同点：都支持 <code>ssr</code>，都有 <code>vdom</code>，组件化开发，实现 <code>webComponents</code> 规范，数据驱动等</li><li>不同点：<code>vue</code> 是双向数据流（当然为了实现单数据流方便管理组件状态，<code>vuex</code> 便出现了），<code>react</code> 是单向数据流。<code>vue </code>的 <code>vdom</code> 是追踪每个组件的依赖关系，不会渲染整个组件树，<code>react</code> 每当应该状态被改变时，全部子组件都会 <code>re-render</code></li></ul><h3 id="4-4-为什么用-vue"><a href="#4-4-为什么用-vue" class="headerlink" title="4.4 为什么用 vue"></a>4.4 为什么用 vue</h3><blockquote><p>简洁、轻快、舒服</p></blockquote><h2 id="五、网络基础类"><a href="#五、网络基础类" class="headerlink" title="五、网络基础类"></a>五、网络基础类</h2><h3 id="5-1-跨域"><a href="#5-1-跨域" class="headerlink" title="5.1 跨域"></a>5.1 跨域</h3><blockquote><p>很多种方法，但万变不离其宗，都是为了搞定同源策略。重用的有 <code>jsonp</code>、<code>iframe</code>、<code>cors</code>、<code>img</code>、H<code>TML5 postMessage</code>等等。其中用到 <code>html</code> 标签进行跨域的原理就是 <code>html</code> 不受同源策略影响。但只是接受 <code>Get</code> 的请求方式，这个得清楚。</p></blockquote><blockquote><p><strong>延伸1：img iframe script 来发送跨域请求有什么优缺点？</strong></p></blockquote><p><strong>1. <code>iframe</code></strong></p><ul><li>优点：跨域完毕之后<code>DOM</code>操作和互相之间的<code>JavaScript</code>调用都是没有问题的</li><li>缺点：1.若结果要以<code>URL</code>参数传递，这就意味着在结果数据量很大的时候需要分割传递，巨烦。2.还有一个是<code>iframe</code>本身带来的，母页面和<code>iframe</code>本身的交互本身就有安全性限制。</li></ul><p><strong>2. script</strong></p><ul><li>优点：可以直接返回<code>json</code>格式的数据，方便处理</li><li>缺点：只接受<code>GET</code>请求方式</li></ul><p><strong>3. 图片ping</strong></p><ul><li>优点：可以访问任何<code>url</code>，一般用来进行点击追踪，做页面分析常用的方法</li><li>缺点：不能访问响应文本，只能监听是否响应</li></ul><blockquote><p><strong>延伸2：配合 webpack 进行反向代理？</strong></p></blockquote><p><code>webpack</code> 在 <code>devServer</code> 选项里面提供了一个 <code>proxy</code> 的参数供开发人员进行反向代理</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'/api'</span>: {</span><br><span class="line">  target: <span class="string">'http://www.example.com'</span>, <span class="comment">// your target host</span></span><br><span class="line">  changeOrigin: <span class="literal">true</span>, <span class="comment">// needed for virtual hosted sites</span></span><br><span class="line">  pathRewrite: {</span><br><span class="line">    <span class="string">'^/api'</span>: <span class="string">''</span>  <span class="comment">// rewrite path</span></span><br><span class="line">  }</span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure><blockquote><p>然后再配合 <code>http-proxy-middleware</code> 插件对 <code>api</code> 请求地址进行代理</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line"><span class="comment">// proxy api requests</span></span><br><span class="line"><span class="keyword">const</span> exampleProxy = proxy(options); <span class="comment">// 这里的 options 就是 webpack 里面的 proxy 选项对应的每个选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mount `exampleProxy` in web server</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(<span class="string">'/api'</span>, exampleProxy);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>然后再用 <code>nginx</code> 把允许跨域的源地址添加到报头里面即可</p></blockquote><blockquote><p>说到 <code>nginx</code> ，可以再谈谈 <code>CORS</code> 配置，大致如下</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location / {</span><br><span class="line">  <span class="keyword">if</span> ($request_method = <span class="string">'OPTIONS'</span>) {</span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">'*'</span>;  </span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'GET, POST, OPTIONS'</span>; </span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Credentials'</span> <span class="string">'true'</span>;</span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Headers'</span> <span class="string">'DNT, X-Mx-ReqToken, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type'</span>;  </span><br><span class="line">    add_header <span class="string">'Access-Control-Max-Age'</span> <span class="number">86400</span>;  </span><br><span class="line">    add_header <span class="string">'Content-Type'</span> <span class="string">'text/plain charset=UTF-8'</span>;  </span><br><span class="line">    add_header <span class="string">'Content-Length'</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span>;  </span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-http-无状态无连接"><a href="#5-2-http-无状态无连接" class="headerlink" title="5.2 http 无状态无连接"></a>5.2 http 无状态无连接</h3><ul><li><code>http</code> 协议对于事务处理没有记忆能力</li><li>对同一个<code>url</code>请求没有上下文关系</li><li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况</li><li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器</li><li>人生若只如初见，请求过的资源下一次会继续进行请求</li></ul><p><strong>http协议无状态中的 状态 到底指的是什么？！</strong></p><ul><li>【状态】的含义就是：客户端和服务器在某次会话中产生的数据</li><li>那么对应的【无状态】就意味着：这些数据不会被保留</li><li>通过增加<code>cookie</code>和<code>session</code>机制，现在的网络请求其实是有状态的</li><li>在没有状态的<code>http</code>协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话</li></ul><h3 id="5-3-http-cache：就是-http-缓存"><a href="#5-3-http-cache：就是-http-缓存" class="headerlink" title="5.3 http-cache：就是 http 缓存"></a>5.3 http-cache：就是 http 缓存</h3><p><strong>1. 首先得明确 http 缓存的好处</strong></p><ul><li>减少了冗余的数据传输，减少网费</li><li>减少服务器端的压力</li><li><code>Web</code> 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间</li><li>加快客户端加载网页的速度</li></ul><p><strong>2. 常见 http 缓存的类型</strong></p><ul><li>私有缓存（一般为本地浏览器缓存）</li><li>代理缓存</li></ul><p><strong>3. 然后谈谈本地缓存</strong></p><blockquote><p>本地缓存是指浏览器请求资源时命中了浏览器本地的缓存资源，浏览器并不会发送真正的请求给服务器了。它的执行过程是</p></blockquote><ul><li>第一次浏览器发送请求给服务器时，此时浏览器还没有本地缓存副本，服务器返回资源给浏览器，响应码是<code>200 OK</code>，浏览器收到资源后，把资源和对应的响应头一起缓存下来</li><li>第二次浏览器准备发送请求给服务器时候，浏览器会先检查上一次服务端返回的响应头信息中的<code>Cache-Control</code>，它的值是一个相对值，单位为秒，表示资源在客户端缓存的最大有效期，过期时间为第一次请求的时间减去<code>Cache-Control</code>的值，过期时间跟当前的请求时间比较，如果本地缓存资源没过期，那么命中缓存，不再请求服务器</li><li>如果没有命中，浏览器就会把请求发送给服务器，进入缓存协商阶段。</li></ul><blockquote><p>与本地缓存相关的头有：<code>Cache-Control</code>、<code>Expires</code>，<code>Cache-Control</code>有多个可选值代表不同的意义，而<code>Expires</code>就是一个日期格式的绝对值。</p></blockquote><p><strong>3.1 Cache-Control</strong></p><blockquote><p><code>Cache-Control</code>是<code>HTPP</code>缓存策略中最重要的头，它是<code>HTTP/1.1</code>中出现的，它由如下几个值</p></blockquote><ul><li><code>no-cache</code>：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在<code>ETag</code>，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载</li><li><code>no-store</code>：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源</li><li><code>public</code>：可以被所有的用户缓存，包括终端用户和<code>CDN</code>等中间代理服务器。</li><li><code>private</code>：只能被终端用户的浏览器缓存，不允许<code>CDN</code>等中继缓存服务器对其缓存。</li><li><code>max-age</code>：从当前请求开始，允许获取的响应被重用的最长时间（秒）。</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"></span><br><span class="line">Cache-Control: public, max-age=1000 </span><br><span class="line"><span class="comment"># 表示资源可以被所有用户以及代理服务器缓存，最长时间为1000秒。</span></span><br></pre></td></tr></tbody></table></figure><p><strong>3.2 Expires</strong></p><blockquote><p><code>Expires</code>是<code>HTTP/1.0</code>出现的头信息，同样是用于决定本地缓存策略的头，它是一个绝对时间，时间格式是如<code>Mon, 10 Jun 2015 21:31:12 GMT</code>，只要发送请求时间是在<code>Expires</code>之前，那么本地缓存始终有效，否则就会去服务器发送请求获取新的资源。如果同时出现<code>Cache-Control：max-age</code>和<code>Expires</code>，那么<code>max-age</code>优先级更高。他们可以这样组合使用</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public</span><br><span class="line">Expires: Wed, Jan 10 2018 00:27:04 GMT</span><br></pre></td></tr></tbody></table></figure><p><strong>3.3 所谓的缓存协商</strong></p><blockquote><p>当第一次请求时服务器返回的响应头中存在以下情况时</p></blockquote><ul><li>没有 <code>Cache-Control</code> 和 <code>Expires</code></li><li><code>Cache-Control</code> 和 <code>Expires</code> 过期了</li><li><code>Cache-Control</code> 的属性设置为 <code>no-cache</code> 时</li></ul><blockquote><p>那么浏览器第二次请求时就会与服务器进行协商，询问浏览器中的缓存资源是不是旧版本，需不需要更新，此时，服务器就会做出判断，如果缓存和服务端资源的最新版本是一致的，那么就无需再次下载该资源，服务端直接返回<code>304 Not Modified</code> 状态码，如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是<code>200 Ok</code>，那么服务端是根据什么来判断浏览器的缓存是不是最新的呢？其实是根据<code>HTTP</code>的另外两组头信息，分别是：<code>Last-Modified/If-Modified-Since</code> 与 <code>ETag/If-None-Match</code>。</p></blockquote><p><strong>Last-Modified 与 If-Modified-Since</strong></p><ul><li>浏览器第一次请求资源时，服务器会把资源的最新修改时间<code>Last-Modified:Thu, 29 Dec 2011 18:23:55 GMT</code>放在响应头中返回给浏览器</li><li>第二次请求时，浏览器就会把上一次服务器返回的修改时间放在请求头<code>If-Modified-Since:Thu, 29 Dec 2011 18:23:55</code>发送给服务器，服务器就会拿这个时间跟服务器上的资源的最新修改时间进行对比</li></ul><blockquote><p>如果两者相等或者大于服务器上的最新修改时间，那么表示浏览器的缓存是有效的，此时缓存会命中，服务器就不再返回内容给浏览器了，同时<code>Last-Modified</code>头也不会返回，因为资源没被修改，返回了也没什么意义。如果没命中缓存则最新修改的资源连同<code>Last-Modified</code>头一起返回</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次请求返回的响应头</span></span><br><span class="line">Cache-Control:max-age=3600</span><br><span class="line">Expires: Fri, Jan 12 2018 00:27:04 GMT</span><br><span class="line">Last-Modified: Wed, Jan 10 2018 00:27:04 GMT</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二次请求的请求头信息</span></span><br><span class="line">If-Modified-Since: Wed, Jan 10 2018 00:27:04 GMT</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这组头信息是基于资源的修改时间来判断资源有没有更新，另一种方式就是根据资源的内容来判断，就是接下来要讨论的 <code>ETag</code> 与 <code>If-None-Match</code></p></blockquote><p><strong>ETag与If-None-Match</strong></p><blockquote><p><code>ETag/If-None-Match</code>与<code>Last-Modified/If-Modified-Since</code>的流程其实是类似的，唯一的区别是它基于资源的内容的摘要信息（比如<code>MD5 hash</code>）来判断</p></blockquote><blockquote><p>浏览器发送第二次请求时，会把第一次的响应头信息<code>ETag</code>的值放在<code>If-None-Match</code>的请求头中发送到服务器，与最新的资源的摘要信息对比，如果相等，取浏览器缓存，否则内容有更新，最新的资源连同最新的摘要信息返回。用<code>ETag</code>的好处是如果因为某种原因到时资源的修改时间没改变，那么用<code>ETag</code>就能区分资源是不是有被更新。</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次请求返回的响应头：</span></span><br><span class="line"></span><br><span class="line">Cache-Control: public, max-age=31536000</span><br><span class="line">ETag: <span class="string">"15f0fff99ed5aae4edffdd6496d7131f"</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二次请求的请求头信息：</span></span><br><span class="line"></span><br><span class="line">If-None-Match: <span class="string">"15f0fff99ed5aae4edffdd6496d7131f"</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-4-cookie-和-session"><a href="#5-4-cookie-和-session" class="headerlink" title="5.4 cookie 和 session"></a>5.4 cookie 和 session</h3><ul><li><code>session</code>： 是一个抽象概念，开发者为了实现中断和继续等操作，将 <code>user agent </code>和 <code>server</code> 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 <code>session</code> 的概念</li><li><code>cookie</code>：它是一个世纪存在的东西，<code>http</code> 协议中定义在 <code>header</code> 中的字段，可以认为是 <code>session</code> 的一种后端无状态实现</li></ul><blockquote><p>现在我们常说的 <code>session</code>，是为了绕开 <code>cookie</code> 的各种限制，通常借助 <code>cookie</code>本身和后端存储实现的，一种更高级的会话状态实现</p></blockquote><p><code>session</code> 的常见实现要借助<code>cookie</code>来发送 <code>sessionID</code></p><h3 id="5-5-安全问题，如-XSS-和-CSRF"><a href="#5-5-安全问题，如-XSS-和-CSRF" class="headerlink" title="5.5 安全问题，如 XSS 和 CSRF"></a>5.5 安全问题，如 XSS 和 CSRF</h3><ul><li> <code>XSS</code>：跨站脚本攻击，是一种网站应用程序的安全漏洞攻击，是代码注入的一种。常见方式是将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动</li></ul><blockquote><p>防范：记住一点 “所有用户输入都是不可信的”，所以得做输入过滤和转义</p></blockquote><ul><li><code>CSRF</code>：跨站请求伪造，也称 <code>XSRF</code>，是一种挟制用户在当前已登录的<code>Web</code>应用程序上执行非本意的操作的攻击方法。与 <code>XSS</code> 相比，<code>XSS</code>利用的是用户对指定网站的信任，<code>CSRF</code>利用的是网站对用户网页浏览器的信任。</li></ul><blockquote><p>防范：用户操作验证（验证码），额外验证机制（<code>token</code>使用）等</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页面布局</title>
      <link href="2020/12/26/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
      <url>2020/12/26/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><blockquote><p>问题：假设高度默认<code>100px</code> ，请写出三栏布局，其中左栏、右栏各为<code>300px</code>，中间自适应。</p></blockquote><p><img src="http://img.smyhvae.com/20180305_1520.png"></p><p>分析：</p><p>初学者想到的答案有两种：</p><ul><li>方法1：浮动</li><li>方法2：绝对定位</li></ul><blockquote><p>但要求你能至少写出三四种方法，才算及格。剩下的方法如下：</p></blockquote><ul><li>方法3：<code>flexbox</code>。移动开发里经常用到。</li><li>方法4：表格布局<code> table</code>。虽然已经淘汰了，但也应该了解。</li><li>方法5：网格布局 <code>grid</code></li></ul><p><strong>方法1、浮动：</strong></p><blockquote><p>左侧设置左浮动，右侧设置右浮动即可，中间会自动地自适应。</p></blockquote><p><strong>方法2、绝对定位：</strong></p><blockquote><p>左侧设置为绝对定位， <code> left：0px</code>。右侧设置为绝对定位， <code>right：0px</code>。中间设置为绝对定位，<code>left </code>和<code>right</code> 都为<code>300px</code>，即可。中间的宽度会自适应。</p></blockquote><blockquote><p>使用<code>article</code>标签作为容器，包裹左、中、右三个部分。</p></blockquote><blockquote><p>方法1 和方法2 的代码如下：</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        html * {</span><br><span class="line">            padding: 0px;</span><br><span class="line">            margin: 0px;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span> {</span></span><br><span class="line">            margin-bottom: 150px;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span> <span class="selector-tag">article</span> <span class="selector-tag">div</span> { <span class="comment">/*注意，这里是设置每个小块儿的高度为100px，而不是设置大容器的高度。大容器的高度要符合响应式*/</span></span></span><br><span class="line">            height: 100px;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 方法一 start */</span></span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.float</span> <span class="selector-class">.left</span> {</span></span><br><span class="line">            float: left;</span><br><span class="line">            width: 300px;</span><br><span class="line">            background: red;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.float</span> <span class="selector-class">.right</span> {</span></span><br><span class="line">            float: right;</span><br><span class="line">            width: 300px;</span><br><span class="line">            background: blue;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.float</span> <span class="selector-class">.center</span> {</span></span><br><span class="line">            background: green;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 方法一 end */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 方法二 start */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.left-center-right</span> {</span></span><br><span class="line">            position: relative;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.left</span> {</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            left: 0;</span><br><span class="line">            width: 300px;</span><br><span class="line">            background: red;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 【重要】中间的区域，左侧定位300px，右侧定位为300px，即可完成。宽度会自使用 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.center</span> {</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            left: 300px;</span><br><span class="line">            right: 300px;</span><br><span class="line">            background: green;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.right</span> {</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            right: 0;</span><br><span class="line">            width: 300px;</span><br><span class="line">            background: blue;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 方法二 end */</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 方法一：浮动 start --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 输入 section.layout.float，即可生成  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout float"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 用  article 标签包裹左、中、右三个部分 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-right-center"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 输入 div.left+div.right+div.center，即可生成 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">                我是 left</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">                我是 right</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">                浮动解决方案</span><br><span class="line">                我是 center</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方法一：浮动 end --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout absolute"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-center-right"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">                我是 left</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">                我是 right</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>绝对定位解决方案<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                我是 center</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180305_1640.gif"></p><p><strong>方法3、flexbox布局</strong></p><blockquote><p>将左中右所在的容器设置为<code>display: flex</code>，设置两侧的宽度后，然后让中间的<code>flex = 1</code>，即可。</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        html * {</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span> <span class="selector-tag">article</span> <span class="selector-tag">div</span> {</span></span><br><span class="line">            height: 100px;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.left-center-right</span> {</span></span><br><span class="line">            display: flex;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.flex</span> <span class="selector-class">.left</span> {</span></span><br><span class="line">            width: 300px;</span><br><span class="line">            background: red;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.flex</span> <span class="selector-class">.center</span> {</span></span><br><span class="line">            flex: 1;</span><br><span class="line">            background: green;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.flex</span> <span class="selector-class">.right</span> {</span></span><br><span class="line">            width: 300px;</span><br><span class="line">            background: blue;</span><br><span class="line">        }</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout flex"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-center-right-"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">                我是 left</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>flex布局解决方案<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                我是 center</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">                我是 right</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180305_1700.gif"></p><p><strong>方法4、表格布局 table</strong></p><blockquote><p>设置整个容器的宽度为<code>100%</code>，设置三个部分均为表格，然后左边的单元格为 <code>300px</code>，右边的单元格为 <code>300px</code>，即可。中间的单元格会自适应。</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        html * {</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-tag">div</span> {</span></span><br><span class="line">            height: 100px;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 重要：设置容器为表格布局，宽度为100% */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.left-center-right</span> {</span></span><br><span class="line">            width: 100%;</span><br><span class="line">            display: table;</span><br><span class="line">            height: 100px;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.left-center-right</span> <span class="selector-tag">div</span> {</span></span><br><span class="line"><span class="css">            <span class="selector-tag">display</span>: <span class="selector-tag">table-cell</span>; <span class="comment">/* 重要：设置三个模块为表格里的单元*/</span></span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.left</span> {</span></span><br><span class="line">            width: 300px;</span><br><span class="line">            background: red;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.center</span> {</span></span><br><span class="line">            background: green;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.right</span> {</span></span><br><span class="line">            width: 300px;</span><br><span class="line">            background: blue;</span><br><span class="line">        }</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout table"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-center-right"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">                我是 left</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>表格布局解决方案<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                我是 center</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">                我是 right</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="http://img.smyhvae.com/20180305_1855.gif"></p><p><strong>方法5、网格布局 grid</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        html * {</span><br><span class="line">            padding: 0;</span><br><span class="line">            margin: 0;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 重要：设置容器为网格布局，宽度为100% */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.left-center-right</span> {</span></span><br><span class="line">            display: grid;</span><br><span class="line">            width: 100%;</span><br><span class="line">            grid-template-rows: 100px;</span><br><span class="line"><span class="css">            <span class="selector-tag">grid-template-columns</span>: 300<span class="selector-tag">px</span> <span class="selector-tag">auto</span> 300<span class="selector-tag">px</span>;  <span class="comment">/* 重要：设置网格为三列，并设置每列的宽度。即可。*/</span></span></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.left</span> {</span></span><br><span class="line">            background: red;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.center</span> {</span></span><br><span class="line">            background: green;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.right</span> {</span></span><br><span class="line">            background: blue;</span><br><span class="line">        }</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout grid"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-center-right"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">                我是 left</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>网格布局解决方案<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                我是 center</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">                我是 right</span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果：</p><p><img src="http://img.smyhvae.com/20180305_1920.gif"></p><p><strong>延伸：五种方法的对比</strong></p><blockquote><p>五种方法的优缺点</p></blockquote><ul><li>考虑中间模块的高度问题</li><li>兼容性问题：实际开发中，哪个最实用？</li></ul><p>方法1：浮动：</p><ul><li>优点：兼容性好。</li><li>缺点：浮动会脱离标准文档流，因此要清除浮动。我们解决好这个问题即可。</li></ul><p>方法:2：绝对定位</p><ul><li>优点：快捷。</li><li>缺点：导致子元素也脱离了标准文档流，可实用性差。</li></ul><p>方法3：flex 布局（CSS3中出现的）</p><ul><li>优点：解决上面两个方法的不足，flex布局比较完美。移动端基本用 flex布局。</li></ul><p>方法4：表格布局</p><ul><li>优点：表格布局在很多场景中很实用，兼容性非常好。因为IE8不支持 flex，此时可以尝试表格布局</li><li>缺点：因为三个部分都当成了<strong>单元格</strong>来对待，此时，如果中间的部分变高了，其会部分也会被迫调整高度。但是，在很多场景下，我们并不需要两侧的高度增高。</li></ul><blockquote><p>什么时候用 <code>flex </code>布局 or 表格布局，看具体的场景。二者没有绝对的优势，也没有绝对的不足。</p></blockquote><p>方法5：网格布局</p><ul><li>CSS3中引入的布局，很好用。代码量简化了很多。</li></ul><blockquote><p>PS：面试提到网格布局，说明我们对新技术是有追求的。</p></blockquote><p><strong>延伸：如果题目中去掉高度已知</strong></p><blockquote><p>问题：题目中，如果去掉高度已知，我们往中间的模块里塞很多内容，让中间的模块撑开。会发生什么变化？哪个布局就不能用了？</p></blockquote><p>分析：其实可以这样理解，我们回去看上面的动画效果，当中间的模块变得很挤时，会发生什么效果？就是我们想要的答案。</p><blockquote><p>答案是：<strong>flex 布局和表格布局可以通用</strong>，其他三个布局都不能用了。</p></blockquote><p><strong>总结</strong></p><blockquote><p>涉及到的知识点：</p></blockquote><ul><li>语义化掌握到位：每个区域用<code>section</code>、<code>article</code>代表容器、<code>div</code>代表块儿。如果通篇都用 div，那就是语义化没掌握好。</li><li>页面布局理解深刻。</li><li><code>CSS</code>基础知识扎实。</li><li>思维灵活且积极上进。题目中可以通过<code>网格布局</code>来体现。</li><li>代码书写规范。注意命名。上面的代码中，没有一行代码是多的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="2020/12/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>2020/12/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><blockquote><p>类与实例：</p></blockquote><ul><li>类的声明</li><li>生成实例</li></ul><p><strong>类与继承：</strong></p><ul><li>如何实现继承：继承的本质就是原型链</li><li>继承的几种方式</li></ul><h2 id="2-类的定义、实例化"><a href="#2-类的定义、实例化" class="headerlink" title="2 类的定义、实例化"></a>2 类的定义、实例化</h2><h3 id="2-1-类的定义-类的声明"><a href="#2-1-类的定义-类的声明" class="headerlink" title="2.1 类的定义/类的声明"></a>2.1 类的定义/类的声明</h3><p><strong>方式一</strong>：用构造函数模拟类（传统写法）</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal1</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">'smyhvae'</span>; <span class="comment">//通过this，表明这是一个构造函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>方式二</strong>：用 class 声明（<code>ES6</code>的写法）</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal2</span> </span>{</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> {  <span class="comment">//可以在构造函数里写属性</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>控制台的效果：</p><p><img src="http://img.smyhvae.com/20180307_0957.png"></p><h3 id="2-2-实例化"><a href="#2-2-实例化" class="headerlink" title="2.2 实例化"></a>2.2 实例化</h3><p>类的实例化很简单，直接 <code>new</code> 出来即可。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Animal1(),<span class="keyword">new</span> Animal2()); <span class="comment">//实例化。如果括号里没有参数，则括号可以省略</span></span><br></pre></td></tr></tbody></table></figure><p><img src="http://img.smyhvae.com/20180307_1000.png"></p><h2 id="3-继承的几种方式"><a href="#3-继承的几种方式" class="headerlink" title="3 继承的几种方式"></a>3 继承的几种方式</h2><blockquote><p>继承的本质就是原型链。</p></blockquote><p><strong>继承的方式有几种？每种形式的优缺点是</strong>？这些问题必问的。其实就是考察你对原型链的掌握程度。</p><h3 id="3-1-方式一：借助构造函数"><a href="#3-1-方式一：借助构造函数" class="headerlink" title="3.1 方式一：借助构造函数"></a>3.1 方式一：借助构造函数</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent1</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">'parent1 的属性'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span>(<span class="params"></span>) </span>{</span><br><span class="line">    Parent1.call(<span class="built_in">this</span>);         <span class="comment">//【重要】此处用 call 或 apply 都行：改变 this 的指向</span></span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">'child1 的属性'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child1);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>【重要】上方代码中，最重要的那行代码：在子类的构造函数里写了<code>Parent1.call(this);</code>，意思是：<strong>让Parent的构造函数在child的构造函数中执行</strong>。发生的变化是：<strong>改变this的指向</strong>，parent的实例 –&gt; 改为指向child的实例。导致 parent的实例的属性挂在到了child的实例上，这就实现了继承。</p></blockquote><p>打印结果：</p><p><img src="http://img.smyhvae.com/20180307_1015.png"></p><blockquote><p>上方结果表明：<code>child</code>先有了 <code>parent</code> 实例的属性（继承得以实现），再有了<code>child</code> 实例的属性。</p></blockquote><p><strong>分析</strong>：</p><blockquote><p>这种方式，虽然改变了 <code>this</code> 的指向，但是，<strong>Child1 无法继承 <code>Parent1</code> 的原型</strong>。也就是说，如果我给 <code>Parent1</code> 的原型增加一个方法：</p></blockquote><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent1.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>上面这个方法是无法被 <code>Child1</code> 继承的。如下：</p></blockquote><p><img src="http://img.smyhvae.com/20180307_1030.png"></p><h3 id="3-2-方法二：通过原型链实现继承"><a href="#3-2-方法二：通过原型链实现继承" class="headerlink" title="3.2 方法二：通过原型链实现继承"></a>3.2 方法二：通过原型链实现继承</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过原型链实现继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">'Parent 的属性'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">'Child 的属性'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent(); <span class="comment">//【重要】</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child());</span><br></pre></td></tr></tbody></table></figure><p>打印结果：</p><p><img src="http://img.smyhvae.com/20180307_1109.png"></p><blockquote><p>【重要】上方代码中，最重要的那行：每个函数都有<code>prototype</code>属性，于是，构造函数也有这个属性，这个属性是一个对象。现在，<strong>我们把<code>Parent</code>的实例赋值给了<code>Child</code>的<code>prototye</code>**，从而实现</strong>继承**。此时，<code>Child</code>构造函数、<code>Parent</code>的实例、<code>Child</code>的实例构成一个三角关系。于是：</p></blockquote><ul><li><code>new Child.__proto__ === new Parent()</code>的结果为<code>true</code></li></ul><p><strong>分析：</strong></p><ul><li>这种继承方式，<strong>Child 可以继承 Parent 的原型</strong>，但有个缺点：</li></ul><blockquote><p>缺点是：<strong>如果修改 child1实例的name属性，child2实例中的name属性也会跟着改变</strong>。</p></blockquote><p>如下：</p><p><img src="http://img.smyhvae.com/20180307_1123.png"></p><blockquote><p>上面的代码中， <code>child1</code>修改了<code>arr</code>属性，却发现，<code>child2</code>的<code>arr</code>属性也跟着改变了。这显然不太好，在业务中，两个子模块应该隔离才对。如果改了一个对象，另一个对象却发生了改变，就不太好。</p></blockquote><blockquote><p>造成这种缺点的原因是：<code>child1</code>和<code>child2</code>共用原型。即：<code>chi1d1.__proto__ === child2__proto__</code>是严格相同。而 arr方法是在 Parent 的实例上（即 Child实例的原型）的。</p></blockquote><h3 id="3-3-方式三：组合的方式：构造函数-原型链"><a href="#3-3-方式三：组合的方式：构造函数-原型链" class="headerlink" title="3.3 方式三：组合的方式：构造函数 + 原型链"></a>3.3 方式三：组合的方式：构造函数 + 原型链</h3><p>就是把上面的两种方式组合起来：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">组合方式实现继承：构造函数、原型链</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent3</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">'Parent 的属性'</span>;</span><br><span class="line">    <span class="built_in">this</span>.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child3</span>(<span class="params"></span>) </span>{</span><br><span class="line">    Parent3.call(<span class="built_in">this</span>); <span class="comment">//【重要1】执行 parent方法</span></span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">'Child 的属性'</span>;</span><br><span class="line">}</span><br><span class="line">Child3.prototype = <span class="keyword">new</span> Parent3(); <span class="comment">//【重要2】第二次执行parent方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child3();</span><br></pre></td></tr></tbody></table></figure><ul><li>这种方式，能解决之前两种方式的问题：既可以继承父类原型的内容，也不会造成原型里属性的修改。</li><li>这种方式的缺点是：让父亲<code>Parent</code>的构造方法执行了两次。</li><li><code>ES6</code>中的继承方式，一带而过即可，重点是要掌握<code>ES5</code>中的继承。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器</title>
      <link href="2020/12/26/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>2020/12/26/%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、事件机制"><a href="#一、事件机制" class="headerlink" title="一、事件机制"></a>一、事件机制</h2><h3 id="1-1-事件触发三阶段"><a href="#1-1-事件触发三阶段" class="headerlink" title="1.1 事件触发三阶段"></a>1.1 事件触发三阶段</h3><ul><li>document 往事件触发处传播，遇到注册的捕获事件会触发</li><li>传播到事件触发处时触发注册的事件</li><li>从事件触发处往 document 传播，遇到注册的冒泡事件会触发</li></ul><blockquote><p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 以下会先打印冒泡然后是捕获</span><br><span class="line">node.addEventListener('click',(event) =&gt;{</span><br><span class="line">console.log('冒泡')</span><br><span class="line">},false);</span><br><span class="line">node.addEventListener('click',(event) =&gt;{</span><br><span class="line">console.log('捕获 ')</span><br><span class="line">},true)</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2-注册事件"><a href="#1-2-注册事件" class="headerlink" title="1.2 注册事件"></a>1.2 注册事件</h3><ul><li>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> 。<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件</li><li>一般来说，我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node.addEventListener(<span class="string">'click'</span>,<span class="function">(<span class="params">event</span>) =&gt;</span>{</span><br><span class="line">event.stopImmediatePropagation()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">},<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 点击 node 只会执行上面的函数，该函数不会执行</span></span><br><span class="line">node.addEventListener(<span class="string">'click'</span>,<span class="function">(<span class="params">event</span>) =&gt;</span> {</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'捕获 '</span>)</span><br><span class="line">},<span class="literal">true</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3-事件代理"><a href="#1-3-事件代理" class="headerlink" title="1.3 事件代理"></a>1.3 事件代理</h3><blockquote><p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'##ul'</span>)</span></span><br><span class="line"><span class="javascript">ul.addEventListener(<span class="string">'click'</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> {</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(event.target);</span></span><br><span class="line">})</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>事件代理的方式相对于直接给目标注册事件来说，有以下优点</p></blockquote><ul><li>节省内存</li><li>不需要给子节点注销事件</li></ul><h2 id="二、跨域"><a href="#二、跨域" class="headerlink" title="二、跨域"></a>二、跨域</h2><blockquote><p>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败</p></blockquote><h3 id="2-1-JSONP"><a href="#2-1-JSONP" class="headerlink" title="2.1 JSONP"></a>2.1 JSONP</h3><blockquote><p>JSONP 的原理很简单，就是利用 <script> 标签没有跨域限制的漏洞。通过 <script> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>JSONP 使用简单且兼容性不错，但是只限于 get 请求</li></ul><h3 id="2-2-CORS"><a href="#2-2-CORS" class="headerlink" title="2.2 CORS"></a>2.2 CORS</h3><ul><li><code>CORS</code>需要浏览器和后端同时支持</li><li>浏览器会自动进行 <code>CORS</code> 通信，实现CORS通信的关键是后端。只要后端实现了 <code>CORS</code>，就实现了跨域。</li><li>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 <code>CORS</code>。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源</li></ul><h3 id="2-3-document-domain"><a href="#2-3-document-domain" class="headerlink" title="2.3 document.domain"></a>2.3 document.domain</h3><ul><li>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</li><li>只需要给页面添加 <code>document.domain = &#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域</li></ul><h3 id="2-4-postMessage"><a href="#2-4-postMessage" class="headerlink" title="2.4 postMessage"></a>2.4 postMessage</h3><blockquote><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息端</span></span><br><span class="line"><span class="built_in">window</span>.parent.postMessage(<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;http://test.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收消息端</span></span><br><span class="line"><span class="keyword">var</span> mc = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">mc.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin; </span><br><span class="line">    <span class="keyword">if</span> (origin === <span class="string">&#x27;http://test.com&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;验证通过&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="三、Event-loop"><a href="#三、Event-loop" class="headerlink" title="三、Event loop"></a>三、Event loop</h2><h3 id="3-1-JS中的event-loop"><a href="#3-1-JS中的event-loop" class="headerlink" title="3.1 JS中的event loop"></a>3.1 JS中的event loop</h3><blockquote><p>众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点）</p></blockquote><ul><li>JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不同的任务源会被分配到不同的 <code>Task</code> 队列中，任务源可以分为 微任务（<code>microtask</code>） 和 宏任务（<code>macrotask</code>）。在 <code>ES6</code> 规范中，<code>microtask</code> 称为 jobs，macrotask 称为 task</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"><span class="comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure><blockquote><p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务</p></blockquote><p><strong>微任务</strong></p><ul><li><code>process.nextTick</code></li><li><code>promise</code></li><li><code>Object.observe</code></li><li><code>MutationObserver</code></li></ul><p><strong>宏任务</strong></p><ul><li><code>script </code></li><li><code>setTimeout</code></li><li><code>setInterval </code></li><li><code>setImmediate </code></li><li><code>I/O </code></li><li><code>UI rendering</code></li></ul><blockquote><p>宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务</p></blockquote><p><strong>所以正确的一次 Event loop 顺序是这样的</strong></p><ul><li>执行同步代码，这属于宏任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 UI</li><li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li></ul><blockquote><p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的响应界面响应，我们可以把操作 <code>DOM</code> 放入微任务中</p></blockquote><h3 id="3-2-Node-中的-Event-loop"><a href="#3-2-Node-中的-Event-loop" class="headerlink" title="3.2 Node 中的 Event loop"></a>3.2 Node 中的 Event loop</h3><ul><li><code>Node</code> 中的 <code>Event loop</code> 和浏览器中的不相同。</li><li><code>Node</code> 的 <code>Event loop</code> 分为<code>6</code>个阶段，它们会按照顺序反复运行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>timer</strong></p><ul><li><code>timers</code> 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code></li><li>一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟</li></ul><p><strong>I/O</strong></p><ul><li><code>I/O</code> 阶段会执行除了 <code>close</code> 事件，定时器和 <code>setImmediate</code> 的回调</li></ul><p>idle, prepare<br>idle, prepare 阶段内部实现</p><p><strong>poll</strong></p><ul><li><p><code>poll</code> 阶段很重要，这一阶段中，系统会做两件事情</p><ul><li>执行到点的定时器</li><li>执行 <code>poll</code> 队列中的事件</li></ul></li><li><p>并且当 poll 中没有定时器的情况下，会发现以下两件事情</p><ul><li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li><li>如果 poll 队列为空，会有两件事发生</li><li>如果有 <code>setImmediate</code> 需要执行，<code>poll</code> 阶段会停止并且进入到 <code>check</code> 阶段执行 <code>setImmediate</code></li><li>如果没有 <code>setImmediate</code> 需要执行，会等待回调被加入到队列中并立即执行回调</li><li>如果有别的定时器需要被执行，会回到 <code>timer</code> 阶段执行回调。</li></ul></li></ul><p><strong>check</strong></p><ul><li><code>check</code> 阶段执行 <code>setImmediate</code></li></ul><p><strong>close callbacks</strong></p><ul><li><code>close callbacks</code> 阶段执行 <code>close</code> 事件</li><li>并且在 <code>Node</code> 中，有些情况下的定时器执行顺序是随机的</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setImmediate&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里可能会输出 setTimeout，setImmediate</span></span><br><span class="line"><span class="comment">// 可能也会相反的输出，这取决于性能</span></span><br><span class="line"><span class="comment">// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate</span></span><br><span class="line"><span class="comment">// 否则会执行 setTimeout</span></span><br></pre></td></tr></table></figure><blockquote><p>上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码在浏览器和 node 中打印情况是不同的</span></span><br><span class="line"><span class="comment">// 浏览器中一定打印 timer1, promise1, timer2, promise2</span></span><br><span class="line"><span class="comment">// node 中可能打印 timer1, timer2, promise1, promise2</span></span><br><span class="line"><span class="comment">// 也可能打印 timer1, promise1, timer2, promise2</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Node</code> 中的 <code>process.nextTick</code> 会先于其他 <code>microtask</code> 执行</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;timer1&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;nextTick&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// nextTick, timer1, promise1</span></span><br></pre></td></tr></table></figure><h2 id="四、Service-Worker"><a href="#四、Service-Worker" class="headerlink" title="四、Service Worker"></a>四、Service Worker</h2><blockquote><p>Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API</p></blockquote><p><strong>目前该技术通常用来做缓存文件，提高首屏速度</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(<span class="string">&quot;sw.js&quot;</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;service worker 注册成功&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;servcie worker 注册失败&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 监听 `install` 事件，回调中缓存所需文件</span></span><br><span class="line">self.addEventListener(<span class="string">&quot;install&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(<span class="string">&quot;my-cache&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([<span class="string">&quot;./index.html&quot;</span>, <span class="string">&quot;./index.js&quot;</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截所有请求事件</span></span><br><span class="line"><span class="comment">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span></span><br><span class="line">self.addEventListener(<span class="string">&quot;fetch&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;fetch source&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b1e8eba68e1c?w=1770&h=722&f=png&s=192277"></p><blockquote><p>在 Cache 中也可以发现我们所需的文件已被缓存</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b20dfc4fcd26?w=1118&h=728&f=png&s=85610"></p><p>当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的</p><h2 id="五、渲染机制"><a href="#五、渲染机制" class="headerlink" title="五、渲染机制"></a>五、渲染机制</h2><p><strong>浏览器的渲染机制一般分为以下几个步骤</strong></p><ul><li>处理 <code>HTML</code> 并构建 <code>DOM</code> 树。</li><li>处理 <code>CSS</code> 构建 <code>CSSOM</code> 树。</li><li>将 <code>DOM</code> 与 <code>CSSOM</code> 合并成一个渲染树。</li><li>根据渲染树来布局，计算每个节点的位置。</li><li>调用 <code>GPU</code> 绘制，合成图层，显示在屏幕上</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/4/11/162b2ab2ec70ac5b?w=900&h=352&f=png&s=49983"></p><ul><li>在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢</li><li>当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM</li></ul><h3 id="5-1-图层"><a href="#5-1-图层" class="headerlink" title="5.1 图层"></a>5.1 图层</h3><blockquote><p>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用</p></blockquote><p><strong>通过以下几个常用属性可以生成新图层</strong></p><ul><li>3D 变换：<code>translate3d</code>、<code>translateZ</code></li><li><code>will-change</code></li><li><code>video</code>、<code>iframe</code> 标签</li><li>通过动画实现的 <code>opacity</code> 动画转换</li><li><code>position: fixed</code></li></ul><h3 id="5-2-重绘（Repaint）和回流（Reflow）"><a href="#5-2-重绘（Repaint）和回流（Reflow）" class="headerlink" title="5.2 重绘（Repaint）和回流（Reflow）"></a>5.2 重绘（Repaint）和回流（Reflow）</h3><ul><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘</li><li>回流是布局或者几何属性需要改变就称为回流</li></ul><blockquote><p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流</p></blockquote><p><strong>所以以下几个动作可能会导致性能问题</strong>：</p><ul><li>改变 window 大小</li><li>改变字体</li><li>添加或删除样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型</li></ul><p><strong>很多人不知道的是，重绘和回流其实和 Event loop 有关</strong></p><ul><li>当 Event loop 执行完 <code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 <code>60Hz </code>的刷新率，每 <code>16ms </code>才会更新一次。</li><li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code> 才会触发一次，并且自带节流功能。</li><li>判断是否触发了<code> media query</code></li><li>更新动画并且发送事件</li><li>判断是否有全屏操作事件</li><li>执行 <code>requestAnimationFrame</code> 回调</li><li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li><li>更新界面</li><li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调</li></ul><p><strong>减少重绘和回流</strong></p><ul><li>使用 <code>translate</code> 替代 <code>top</code></li><li>使用 <code>visibility</code> 替换<code> display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 table 的重新布局</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li><li><code>CSS</code> 选择符从右往左匹配查找，避免 <code>DOM</code> 深度过深</li><li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 <code>video </code>标签，浏览器会自动将该节点变为图层</li></ul></script></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域通信</title>
      <link href="2020/12/26/%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E7%B1%BB/"/>
      <url>2020/12/26/%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>从本章起，对代码的要求没之前那么高了，但是，要求你对知识面的掌握要足够宽。</p><p><strong>前端通信类的问题，主要包括以下内容</strong>：</p><ol><li>什么是<strong>同源策略</strong>及限制</li></ol><blockquote><p>同源策略是一个概念，就一句话。有什么限制，就三句话。能说出来即可。</p></blockquote><ol start="2"><li><strong>前后端如何通信</strong></li></ol><blockquote><p>如果你不准备，估计也就只能说出<code>ajax</code>。这个可以考察出知识面。</p></blockquote><ol start="3"><li>如何创建<strong>Ajax</strong></li></ol><blockquote><p><code>Ajax</code>在前后端通信中经常用到。做业务时，可以借助第三方的库，比如<code>vue</code>框架里的库、<code>jQuery</code>也有封装好的方法。但如果让你用原生的<code>js</code>去实现，该怎么做？</p></blockquote><p>这就是考察你的动手能力，以及框架原理的掌握。如果能写出来，可以体现出你的基本功。是加分项。</p><ol start="4"><li><strong>跨域通信</strong>的几种方式</li></ol><blockquote><p>这部分非常重要。无非就是问你：什么是跨域、跨域有什么限制、<strong>跨域有几种方式</strong>。</p></blockquote><p>下面分别讲解。</p><h2 id="2-同源策略的概念和具体限制"><a href="#2-同源策略的概念和具体限制" class="headerlink" title="2 同源策略的概念和具体限制"></a>2 同源策略的概念和具体限制</h2><blockquote><p><strong>同源策略</strong>：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。（来自MDN官方的解释）</p></blockquote><p><strong>具体解释：</strong></p><ol><li><code>源</code>包括三个部分：协议、域名、端口（<code>http</code>协议的默认端口是<code>80</code>）。如果有任何一个部分不同，则<code>源</code>不同，那就是跨域了。</li><li><code>限制</code>：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住）</li></ol><ul><li><code>Cookie</code>、<code>LocalStorage</code>和<code>IndexDB</code>无法获取。</li><li>无法获取和操作<code>DOM</code>。</li><li>不能发送<code>Ajax</code>请求。我们要注意，<code>Ajax</code>只适合<strong>同源</strong>的通信。</li></ul><h2 id="3-前后端如何通信"><a href="#3-前后端如何通信" class="headerlink" title="3 前后端如何通信"></a>3 前后端如何通信</h2><p><strong>主要有以下几种方式：</strong></p><ul><li><code>Ajax</code>：不支持跨域。</li><li><code>WebSocket</code>：不受同源策略的限制，支持跨域</li><li><code>CORS</code>：不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：<strong>同时支持同源和跨域的Ajax</strong>。</li></ul><h2 id="4-如何创建Ajax"><a href="#4-如何创建Ajax" class="headerlink" title="4 如何创建Ajax"></a>4 如何创建Ajax</h2><blockquote><p>在回答 <code>Ajax</code> 的问题时，要回答以下几个方面：</p></blockquote><ol><li><code>XMLHttpRequest</code> 的工作原理</li><li>兼容性处理</li></ol><blockquote><p><code>XMLHttpRequest</code>只有在高级浏览器中才支持。在回答问题时，这个兼容性问题不要忽略。</p></blockquote><ol start="3"><li>事件的触发条件</li><li>事件的触发顺序</li></ol><blockquote><p><code>XMLHttpRequest</code>有很多触发事件，每个事件是怎么触发的。</p></blockquote><h3 id="4-1-发送-Ajax-请求的五个步骤（XMLHttpRequest的工作原理）"><a href="#4-1-发送-Ajax-请求的五个步骤（XMLHttpRequest的工作原理）" class="headerlink" title="4.1 发送 Ajax 请求的五个步骤（XMLHttpRequest的工作原理）"></a>4.1 发送 Ajax 请求的五个步骤（XMLHttpRequest的工作原理）</h3><ol><li>创建<code>XMLHttpRequest</code> 对象。</li><li>使用<code>open</code>方法设置请求的参数。`open(method, url, 是否异步)``。</li><li>发送请求。</li><li>注册事件。 注册<code>onreadystatechange</code>事件，状态改变时就会调用。</li></ol><blockquote><p>如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。</p></blockquote><ol start="5"><li>获取返回的数据，更新UI。</li></ol><h3 id="4-2-发送-get-请求和-post-请求"><a href="#4-2-发送-get-请求和-post-请求" class="headerlink" title="4.2 发送 get 请求和 post 请求"></a>4.2 发送 get 请求和 post 请求</h3><blockquote><p><code>get</code>请求举例：</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Ajax 发送 get 请求<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"发送get_ajax请求"</span> <span class="attr">id</span>=<span class="string">'btnAjax'</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 绑定点击事件</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">'#btnAjax'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 发送ajax 请求 需要 五步</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// （1）创建异步对象</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ajaxObj = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// （2）设置请求的参数。包括：请求的方法、请求的url。</span></span></span><br><span class="line"><span class="javascript">        ajaxObj.open(<span class="string">'get'</span>, <span class="string">'02-ajax.php'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// （3）发送请求</span></span></span><br><span class="line">        ajaxObj.send();</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//（4）注册事件。 onreadystatechange事件，状态改变时就会调用。</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。</span></span></span><br><span class="line"><span class="javascript">        ajaxObj.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 为了保证 数据 完整返回，我们一般会判断 两个值</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (ajaxObj.readyState == <span class="number">4</span> &amp;&amp; ajaxObj.status == <span class="number">200</span>) {</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 5.在注册的事件中 获取 返回的 内容 并修改页面的显示</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'数据返回成功'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="comment">// 数据是保存在 异步对象的 属性中</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(ajaxObj.responseText);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="comment">// 修改页面的显示</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.querySelector(<span class="string">'h1'</span>).innerHTML = ajaxObj.responseText;</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>post</code> 请求举例：</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Ajax 发送 get 请求<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"发送put_ajax请求"</span> <span class="attr">id</span>=<span class="string">'btnAjax'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 异步对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置属性</span></span></span><br><span class="line"><span class="javascript">    xhr.open(<span class="string">'post'</span>, <span class="string">'02.post.php'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 如果想要使用post提交数据,必须添加此行</span></span></span><br><span class="line"><span class="javascript">    xhr.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 将数据通过send方法传递</span></span></span><br><span class="line"><span class="javascript">    xhr.send(<span class="string">'name=fox&amp;age=18'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 发送并接受返回值</span></span></span><br><span class="line"><span class="javascript">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 这步为判断服务器是否正确响应</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) {</span></span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="4-3-onreadystatechange-事件"><a href="#4-3-onreadystatechange-事件" class="headerlink" title="4.3 onreadystatechange 事件"></a>4.3 onreadystatechange 事件</h3><blockquote><p>注册 <code>onreadystatechange</code> 事件后，每当 <code>readyState</code> 属性改变时，就会调用 <code>onreadystatechange</code> 函数。</p></blockquote><blockquote><p><code>readyState</code>：（存有 <code>XMLHttpRequest</code> 的状态。从 <code>0</code> 到 <code>4</code> 发生变化）</p></blockquote><ul><li><code>0</code>: 请求未初始化</li><li><code>1</code>: 服务器连接已建立</li><li><code>2</code>: 请求已接收</li><li><code>3</code>: 请求处理中</li><li><code>4</code>: 请求已完成，且响应已就绪</li></ul><h3 id="4-4-事件的触发条件"><a href="#4-4-事件的触发条件" class="headerlink" title="4.4 事件的触发条件"></a>4.4 事件的触发条件</h3><p><img src="http://img.smyhvae.com/20180307_1443.png"></p><h3 id="4-5-事件的触发顺序"><a href="#4-5-事件的触发顺序" class="headerlink" title="4.5 事件的触发顺序"></a>4.5 事件的触发顺序</h3><p><img src="http://img.smyhvae.com/20180307_1445.png"></p><h3 id="4-6-实际开发中用的-原生Ajax请求"><a href="#4-6-实际开发中用的-原生Ajax请求" class="headerlink" title="4.6 实际开发中用的 原生Ajax请求"></a>4.6 实际开发中用的 原生Ajax请求</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> util = {};</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 ajax 请求之后的json</span></span><br><span class="line">util.json = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> opt = {</span><br><span class="line">        url: <span class="string">''</span>,</span><br><span class="line">        type: <span class="string">'get'</span>,</span><br><span class="line">        data: {},</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        },</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        },</span><br><span class="line"></span><br><span class="line">    };</span><br><span class="line">    util.extend(opt, options);</span><br><span class="line">    <span class="keyword">if</span> (opt.url) {</span><br><span class="line">        <span class="comment">//IE兼容性处理：浏览器特征检查。检查该浏览器是否存在XMLHttpRequest这个api，没有的话，就用IE的api</span></span><br><span class="line">        <span class="keyword">var</span> xhr = XMLHttpRequest ? <span class="keyword">new</span> XMLHttpRequest() : <span class="keyword">new</span> <span class="built_in">window</span>.ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> data = opt.data,</span><br><span class="line">            url = opt.url,</span><br><span class="line">            type = opt.type.toUpperCase();</span><br><span class="line">        dataArr = [];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> data) {</span><br><span class="line">        dataArr.push(key + <span class="string">'='</span> + data[key]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'GET'</span>) {</span><br><span class="line">        url = url + <span class="string">'?'</span> + dataArr.join(<span class="string">'&amp;'</span>);</span><br><span class="line">        xhr.open(type, url.replace(<span class="regexp">/\?$/g</span>, <span class="string">''</span>), <span class="literal">true</span>);</span><br><span class="line">        xhr.send();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'POST'</span>) {</span><br><span class="line">        xhr.open(type, url, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 如果想要使用post提交数据,必须添加此行</span></span><br><span class="line">        xhr.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">        xhr.send(dataArr.join(<span class="string">'&amp;'</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span> || xhr.status === <span class="number">304</span>) { <span class="comment">//304表示：用缓存即可。206表示获取媒体资源的前面一部分</span></span><br><span class="line">            <span class="keyword">var</span> res;</span><br><span class="line">            <span class="keyword">if</span> (opt.success &amp;&amp; opt.success <span class="keyword">instanceof</span> <span class="built_in">Function</span>) {</span><br><span class="line">                res = xhr.responseText;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> res === <span class="string">'string'</span>) {</span><br><span class="line">                    res = <span class="built_in">JSON</span>.parse(res);  <span class="comment">//将字符串转成json</span></span><br><span class="line">                    opt.success.call(xhr, res);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (opt.error &amp;&amp; opt.error <span class="keyword">instanceof</span> <span class="built_in">Function</span>) {</span><br><span class="line">                opt.error.call(xhr, res);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="5-跨域通信的几种方式"><a href="#5-跨域通信的几种方式" class="headerlink" title="5 跨域通信的几种方式"></a>5 跨域通信的几种方式</h2><blockquote><p>方式如下：</p></blockquote><ol><li><code>JSONP</code></li><li><code>WebSocket</code></li><li><code>CORS</code></li><li><code>Hash</code></li><li><code>postMessage</code></li></ol><blockquote><p>上面这五种方式，在面试时，都要说出来。</p></blockquote><h3 id="5-1-JSONP"><a href="#5-1-JSONP" class="headerlink" title="5.1 JSONP"></a>5.1 JSONP</h3><blockquote><p>面试会问：<code>JSONP</code>的原理是什么？怎么实现的？</p></blockquote><ul><li>在<code>CORS</code>和<code>postMessage</code>以前，我们一直都是通过<code>JSONP</code>来做跨域通信的。</li></ul><blockquote><p><strong>JSONP的原理</strong>：通过<code>&lt;script&gt;</code>标签的异步加载来实现的。比如说，实际开发中，我们发现，<code>head</code>标签里，可以通过<code>&lt;script&gt;</code>标签的<code>src</code>，里面放<code>url</code>，加载很多在线的插件。这就是用到了<code>JSONP</code>。</p></blockquote><p><strong>JSONP的实现：</strong></p><blockquote><p>比如说，客户端这样写：</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://www.smyhvae.com/?data=name&amp;callback=myjsonp"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>上面的<code>src</code>中，<code>data=name</code>是get请求的参数，<code>myjsonp</code>是和后台约定好的函数名。<br>服务器端这样写：</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myjsonp({</span><br><span class="line">    data: {}</span><br><span class="line"></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><blockquote><p>于是，本地要求创建一个<code>myjsonp</code> 的<strong>全局函数</strong>，才能将返回的数据执行出来。</p></blockquote><p><strong>实际开发中，前端的JSONP是这样实现的：</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> util = {};</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//定义方法：动态创建 script 标签</span></span></span><br><span class="line">    /**</span><br><span class="line"><span class="javascript">     * [<span class="function"><span class="keyword">function</span> 在页面中注入<span class="title">js</span>脚本]</span></span></span><br><span class="line">     * @param  {[type]} url     [description]</span><br><span class="line">     * @param  {[type]} charset [description]</span><br><span class="line"><span class="javascript">     * @<span class="keyword">return</span> {[type]}         [description]</span></span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    util.createScript = <span class="function"><span class="keyword">function</span> (<span class="params">url, charset</span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="javascript">        script.setAttribute(<span class="string">'type'</span>, <span class="string">'text/javascript'</span>);</span></span><br><span class="line"><span class="javascript">        charset &amp;&amp; script.setAttribute(<span class="string">'charset'</span>, charset);</span></span><br><span class="line"><span class="javascript">        script.setAttribute(<span class="string">'src'</span>, url);</span></span><br><span class="line"><span class="javascript">        script.async = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> script;</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"><span class="javascript">     * [<span class="function"><span class="keyword">function</span> 处理<span class="title">jsonp</span>]</span></span></span><br><span class="line">     * @param  {[type]} url      [description]</span><br><span class="line">     * @param  {[type]} onsucess [description]</span><br><span class="line">     * @param  {[type]} onerror  [description]</span><br><span class="line">     * @param  {[type]} charset  [description]</span><br><span class="line"><span class="javascript">     * @<span class="keyword">return</span> {[type]}          [description]</span></span><br><span class="line">     */</span><br><span class="line"><span class="javascript">    util.jsonp = <span class="function"><span class="keyword">function</span> (<span class="params">url, onsuccess, onerror, charset</span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> callbackName = util.getName(<span class="string">'tt_player'</span>); <span class="comment">//事先约定好的 函数名</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>[callbackName] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{      <span class="comment">//根据回调名称注册一个全局的函数</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (onsuccess &amp;&amp; util.isFunction(onsuccess)) {</span></span><br><span class="line"><span class="javascript">                onsuccess(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span></span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> script = util.createScript(url + <span class="string">'&amp;callback='</span> + callbackName, charset);   <span class="comment">//动态创建一个script标签</span></span></span><br><span class="line"><span class="javascript">        script.onload = script.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{   <span class="comment">//监听加载成功的事件，获取数据</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (!script.readyState || <span class="regexp">/loaded|complete/</span>.test(script.readyState)) {</span></span><br><span class="line"><span class="javascript">                script.onload = script.onreadystatechange = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 移除该script的 DOM 对象</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (script.parentNode) {</span></span><br><span class="line">                    script.parentNode.removeChild(script);</span><br><span class="line">                }</span><br><span class="line"><span class="javascript">                <span class="comment">// 删除函数或变量</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">window</span>[callbackName] = <span class="literal">null</span>;  <span class="comment">//最后不要忘了删除</span></span></span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"><span class="javascript">        script.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (onerror &amp;&amp; util.isFunction(onerror)) {</span></span><br><span class="line">                onerror();</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script); <span class="comment">//往html中增加这个标签，目的是把请求发送出去</span></span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-WebSocket"><a href="#5-2-WebSocket" class="headerlink" title="5.2 WebSocket"></a>5.2 WebSocket</h3><blockquote><p><code>WebSocket</code>的用法如下：</p></blockquote><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'wss://echo.websocket.org'</span>); <span class="comment">//创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把请求发出去</span></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Connection open ...'</span>);</span><br><span class="line">    ws.send(<span class="string">'Hello WebSockets!'</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对方发消息过来时，我接收</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Received Message: '</span>, evt.data);</span><br><span class="line">    ws.close();</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Connection closed.'</span>);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><blockquote><p>面试一般不会让你写这个代码，一般是考察你是否了解 <code>WebSocket</code>概念，知道有这么回事即可。</p></blockquote><h3 id="5-3-CORS"><a href="#5-3-CORS" class="headerlink" title="5.3 CORS"></a>5.3 CORS</h3><blockquote><p><code>CORS</code> 可以理解成是<strong>既可以同步、也可以异步</strong>的Ajax。</p></blockquote><ul><li>fetch<code> 是一个比较新的</code>API<code>，用来实现</code>CORS`通信。用法如下：</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url（必选），options（可选）</span></span><br><span class="line">fetch(<span class="string">'/some/url/'</span>, {</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">}).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>{  <span class="comment">//类似于 ES6中的promise</span></span><br><span class="line"></span><br><span class="line">}).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{</span><br><span class="line">  <span class="comment">// 出错了，等价于 then 的第二个参数，但这样更好用更直观</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><blockquote><p>另外，如果面试官问：“CORS为什么支持跨域的通信？”</p></blockquote><blockquote><p>答案：跨域时，浏览器会拦截<code>Ajax</code>请求，并在<code>http</code>头中加<code>Origin</code>。</p></blockquote><h3 id="5-4-Hash"><a href="#5-4-Hash" class="headerlink" title="5.4 Hash"></a>5.4 Hash</h3><ul><li><code>url</code>的<code>#</code>后面的内容就叫<code>Hash</code>。<strong>Hash的改变，页面不会刷新</strong>。这就是用 <code>Hash</code> 做跨域通信的基本原理。</li></ul><blockquote><p>补充：<code>url</code>的<code>?</code>后面的内容叫<code>Search</code>。<code>Search</code>的改变，会导致页面刷新，因此不能做跨域通信。</p></blockquote><p><strong>使用举例：</strong></p><p><strong>场景</strong>：我的页面 <code>A</code> 通过<code>iframe</code>或<code>frame</code>嵌入了跨域的页面 <code>B</code>。</p><blockquote><p>现在，我这个<code>A</code>页面想给<code>B</code>页面发消息，怎么操作呢？</p></blockquote><ol><li>首先，在我的<code>A</code>页面中：</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">var</span> B = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'iframe'</span>);</span><br><span class="line">B.src = B.src + <span class="string">'#'</span> + <span class="string">'jsonString'</span>;  <span class="comment">//我们可以把JS 对象，通过 JSON.stringify()方法转成 json字符串，发给 B</span></span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>然后，在<code>B</code>页面中：</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B中的伪代码</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{  <span class="comment">//通过onhashchange方法监听，url中的 hash 是否发生变化</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">window</span>.location.hash;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="5-5-postMessage-方法"><a href="#5-5-postMessage-方法" class="headerlink" title="5.5 postMessage()方法"></a>5.5 postMessage()方法</h3><blockquote><p><code>H5</code>中新增的`postMessage()``方法，可以用来做跨域通信。既然是H5中新增的，那就一定要提到。</p></blockquote><p><strong>场景</strong>：窗口 A (<code>http:A.com</code>)向跨域的窗口 B (<code>http:B.com</code>)发送信息。步骤如下</p><ol><li>在<code>A</code>窗口中操作如下：向<code>B</code>窗口发送数据：</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息</span></span><br><span class="line">Bwindow.postMessage(<span class="string">'data'</span>, <span class="string">'http://B.com'</span>); <span class="comment">//这里强调的是B窗口里的window对象</span></span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>在<code>B</code>窗口中操作如下：</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在窗口B中监听 message 事件</span></span><br><span class="line">Awindow.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>{   <span class="comment">//这里强调的是A窗口里的window对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.origin);  <span class="comment">//获取 ：url。这里指：http://A.com</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.source);  <span class="comment">//获取：A window对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.data);    <span class="comment">//获取传过来的数据</span></span><br><span class="line">}, <span class="literal">false</span>);</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全问题</title>
      <link href="2020/12/26/%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9ACSRF%E5%92%8CXSS/"/>
      <url>2020/12/26/%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9ACSRF%E5%92%8CXSS/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><blockquote><p>面试中的安全问题，明确来说，就两个方面：</p></blockquote><ul><li><code>CSRF</code>：基本概念、攻击方式、防御措施</li><li><code>XSS</code>：基本概念、攻击方式、防御措施</li></ul><blockquote><p>这两个问题，一般不会问太难。</p></blockquote><blockquote><p>有人问：<code>SQL</code>注入算吗？答案：这个其实跟前端的关系不是很大。</p></blockquote><h2 id="2-CSRF"><a href="#2-CSRF" class="headerlink" title="2 CSRF"></a>2 CSRF</h2><blockquote><p>问的不难，一般问：</p></blockquote><ul><li><code>CSRF</code>的基本概念、缩写、全称</li><li>攻击原理</li><li>防御措施</li></ul><blockquote><p>如果把<strong>攻击原理</strong>和<strong>防御措施</strong>掌握好，基本没什么问题。</p></blockquote><h3 id="2-1-CSRF的基本概念、缩写、全称"><a href="#2-1-CSRF的基本概念、缩写、全称" class="headerlink" title="2.1 CSRF的基本概念、缩写、全称"></a>2.1 CSRF的基本概念、缩写、全称</h3><blockquote><p><code>CSRF</code>（<code>Cross-site request forgery</code>）：<strong>跨站请求伪造</strong>。</p></blockquote><p>PS：中文名一定要记住。英文全称，如果记不住也拉倒。</p><h3 id="2-2-CSRF的攻击原理"><a href="#2-2-CSRF的攻击原理" class="headerlink" title="2.2 CSRF的攻击原理"></a>2.2 CSRF的攻击原理</h3><p><img src="http://img.smyhvae.com/20180307_1735.png"></p><blockquote><p>用户是网站A的注册用户，且登录进去，于是网站A就给用户下发<code>cookie</code>。</p></blockquote><blockquote><p>从上图可以看出，要完成一次<code>CSRF</code>攻击，受害者必须满足两个必要的条件：</p></blockquote><ol><li>登录受信任网站<code>A</code>，并在本地生成<code>Cookie</code>。（如果用户没有登录网站<code>A</code>，那么网站<code>B</code>在诱导的时候，请求网站<code>A</code>的<code>api</code>接口时，会提示你登录）</li><li>在不登出<code>A</code>的情况下，访问危险网站<code>B</code>（其实是利用了网站<code>A</code>的漏洞）。</li></ol><blockquote><p>我们在讲<code>CSRF</code>时，一定要把上面的两点说清楚。</p></blockquote><blockquote><p>温馨提示一下，<code>cookie</code>保证了用户可以处于登录状态，但网站<code>B</code>其实拿不到 <code>cookie</code>。</p></blockquote><blockquote><p>举个例子，前段时间里，微博网站有个<code>api</code>接口有漏洞，导致很多用户的粉丝暴增。</p></blockquote><h3 id="2-3-CSRF如何防御"><a href="#2-3-CSRF如何防御" class="headerlink" title="2.3 CSRF如何防御"></a>2.3 CSRF如何防御</h3><p><strong>方法一、Token 验证：</strong>（用的最多）</p><ol><li>服务器发送给客户端一个<code>token</code>；</li><li>客户端提交的表单中带着这个<code>token</code>。</li><li>如果这个 <code>token</code> 不合法，那么服务器拒绝这个请求。</li></ol><p><strong>方法二：隐藏令牌：</strong></p><ul><li>把 <code>token</code> 隐藏在 <code>http</code> 的 <code>head</code>头中。</li></ul><blockquote><p>方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。</p></blockquote><p><strong>方法三、Referer 验证：</strong></p><blockquote><p><code>Referer</code> 指的是页面请求来源。意思是，<strong>只接受本站的请求，服务器才做响应</strong>；如果不是，就拦截。</p></blockquote><h2 id="3-XSS"><a href="#3-XSS" class="headerlink" title="3 XSS"></a>3 XSS</h2><h3 id="3-1-XSS的基本概念"><a href="#3-1-XSS的基本概念" class="headerlink" title="3.1 XSS的基本概念"></a>3.1 XSS的基本概念</h3><blockquote><p>`XSS（Cross Site Scripting）``：<strong>跨域脚本攻击</strong>。</p></blockquote><ul><li>接下来，我们详细讲一下 <code>XSS</code> 的内容。</li></ul><blockquote><p>预备知识：<code>HTTP</code>、<code>Cookie</code>、<code>Ajax</code>。</p></blockquote><h3 id="3-2-XSS的攻击原理"><a href="#3-2-XSS的攻击原理" class="headerlink" title="3.2 XSS的攻击原理"></a>3.2 XSS的攻击原理</h3><blockquote><p><code>XSS</code>攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在<code>url</code>中输入、在评论框中输入），向你的页面注入脚本（可能是<code>js</code>、<code>hmtl</code>代码块等）。</p></blockquote><blockquote><p>最后导致的结果可能是：</p></blockquote><ul><li>盗用<code>Cookie</code></li><li>破坏页面的正常结构，插入广告等恶意内容</li><li><code>D-doss</code>攻击</li></ul><h3 id="3-3-XSS的攻击方式"><a href="#3-3-XSS的攻击方式" class="headerlink" title="3.3 XSS的攻击方式"></a>3.3 XSS的攻击方式</h3><ol><li>反射型</li></ol><blockquote><p>发出请求时，<code>XSS</code>代码出现在<code>url</code>中，作为输入提交到服务器端，服务器端解析后响应，<code>XSS</code>代码随响应内容一起传回给浏览器，最后浏览器解析执行<code>XSS</code>代码。这个过程像一次反射，所以叫反射型<code>XSS</code>。</p></blockquote><ol start="2"><li>存储型</li></ol><blockquote><p>存储型<code>XSS</code>和反射型<code>XSS</code>的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。</p></blockquote><h3 id="3-4-XSS的防范措施（encode-过滤）"><a href="#3-4-XSS的防范措施（encode-过滤）" class="headerlink" title="3.4 XSS的防范措施（encode + 过滤）"></a>3.4 XSS的防范措施（encode + 过滤）</h3><p><strong>XSS的防范措施主要有三个：</strong></p><p><strong>1. 编码</strong>：</p><blockquote><p>对用户输入的数据进行<code>HTML Entity</code>编码。</p></blockquote><p>如上图所示，把字符转换成 转义字符。</p><blockquote><p><code>Encode</code>的作用是将<code>$var</code>等一些字符进行转化，使得浏览器在最终输出结果上是一样的。</p></blockquote><p>比如说这段代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>若不进行任何处理，则浏览器会执行alert的js操作，实现XSS注入。</p></blockquote><blockquote><p>进行编码处理之后，L在浏览器中的显示结果就是<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，实现了将``$var<code>作为纯文本进行输出，且不引起J</code>avaScript`的执行。</p></blockquote><p><strong>2、过滤：</strong></p><ul><li>移除用户输入的和事件相关的属性。如<code>onerror</code>可以自动触发攻击，还有<code>onclick</code>等。（总而言是，过滤掉一些不安全的内容）</li><li>移除用户输入的<code>Style</code>节点、<code>Script</code>节点、<code>Iframe</code>节点。（尤其是<code>Script</code>节点，它可是支持跨域的呀，一定要移除）。</li></ul><p><strong>3、校正</strong></p><ul><li>避免直接对<code>HTML Entity</code>进行解码。</li><li>使用<code>DOM Parse</code>转换，校正不配对的<code>DOM</code>标签。</li></ul><blockquote><p>备注：我们应该去了解一下<code>DOM Parse</code>这个概念，它的作用是把文本解析成<code>DOM</code>结构。</p></blockquote><p>比较常用的做法是，通过第一步的编码转成文本，然后第三步转成<code>DOM</code>对象，然后经过第二步的过滤。</p><p><strong>还有一种简洁的答案：</strong></p><p>首先是encode，如果是富文本，就白名单。</p><h2 id="4-CSRF-和-XSS-的区别"><a href="#4-CSRF-和-XSS-的区别" class="headerlink" title="4 CSRF 和 XSS 的区别"></a>4 CSRF 和 XSS 的区别</h2><blockquote><p>面试官还可能喜欢问二者的区别。</p></blockquote><p><strong>区别一：</strong></p><ul><li><code>CSRF</code>：需要用户先登录网站<code>A</code>，获取 <code>cookie</code></li><li><code>XSS</code>：不需要登录。</li></ul><p><strong>区别二：（原理的区别）</strong></p><ul><li><code>CSRF</code>：是利用网站<code>A</code>本身的漏洞，去请求网站<code>A</code>的<code>api</code>。</li><li><code>XSS</code>：是向网站 <code>A</code> 注入 <code>JS</code>代码，然后执行 <code>JS</code> 里的代码，篡改网站<code>A</code>的内容。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能</title>
      <link href="2020/12/26/%E6%80%A7%E8%83%BD/"/>
      <url>2020/12/26/%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="一、网络相关"><a href="#一、网络相关" class="headerlink" title="一、网络相关"></a>一、网络相关</h2><h3 id="1-1-DNS-预解析"><a href="#1-1-DNS-预解析" class="headerlink" title="1.1 DNS 预解析"></a>1.1 DNS 预解析</h3><ul><li>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP</li></ul><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//yuchengkai.cn"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="1-2-缓存"><a href="#1-2-缓存" class="headerlink" title="1.2 缓存"></a>1.2 缓存</h3><ul><li>缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度</li><li>通常浏览器缓存策略分为两种：强缓存和协商缓存</li></ul><p><strong>强缓存</strong></p><blockquote><p>实现强缓存可以通过两种响应头实现：<code>Expires </code>和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，<code>state code </code>为 <code>200</code></p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 22 Oct 2018 08:41:00 GMT</span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>Expires</code> 是 <code>HTTP / 1.0</code> 的产物，表示资源会在 <code>Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 <code>Expires</code> 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-control: max-age=30</span><br></pre></td></tr></tbody></table></figure><blockquote><p><code>Cache-Control</code> 出现于 <code>HTTP / 1.1</code>，优先级高于 <code>Expires</code> 。该属性表示资源会在 <code>30</code> 秒后过期，需要再次请求</p></blockquote><p><strong>协商缓存</strong></p><ul><li>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304</li><li>协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式</li></ul><p>Last-Modified 和 If-Modified-Since</p><ul><li><code>Last-Modified</code> 表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified </code>的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来</li><li>但是如果在本地打开缓存文件，就会造成 <code>Last-Modified</code> 被修改，所以在 <code>HTTP / 1.1</code> 出现了 <code>ETag</code></li></ul><p>ETag 和 If-None-Match</p><ul><li><code>ETag</code> 类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 <code>ETag</code> 优先级比 <code>Last-Modified</code> 高</li></ul><p><strong>选择合适的缓存策略</strong></p><blockquote><p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p></blockquote><ul><li>对于某些不需要缓存的资源，可以使用 <code>Cache-control: no-store</code> ，表示该资源不需要缓存</li><li>对于频繁变动的资源，可以使用 <code>Cache-Control: no-cache</code> 并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li><li>对于代码文件来说，通常使用 <code>Cache-Control: max-age=31536000</code> 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件</li></ul><h3 id="1-3-使用-HTTP-2-0"><a href="#1-3-使用-HTTP-2-0" class="headerlink" title="1.3 使用 HTTP / 2.0"></a>1.3 使用 HTTP / 2.0</h3><ul><li>因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间</li><li>在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小</li></ul><h3 id="1-4-预加载"><a href="#1-4-预加载" class="headerlink" title="1.4 预加载"></a>1.4 预加载</h3><ul><li>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载</li><li>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</li></ul><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好</p></blockquote><h3 id="1-5-预渲染"><a href="#1-5-预渲染" class="headerlink" title="1.5 预渲染"></a>1.5 预渲染</h3><blockquote><p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prerender"</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span>&gt;</span> </span><br></pre></td></tr></tbody></table></figure><ul><li>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染</li></ul><h2 id="二、优化渲染过程"><a href="#二、优化渲染过程" class="headerlink" title="二、优化渲染过程"></a>二、优化渲染过程</h2><h3 id="2-1-懒执行"><a href="#2-1-懒执行" class="headerlink" title="2.1 懒执行"></a>2.1 懒执行</h3><ul><li>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒</li></ul><h3 id="2-2-懒加载"><a href="#2-2-懒加载" class="headerlink" title="2.2 懒加载"></a>2.2 懒加载</h3><ul><li>懒加载就是将不关键的资源延后加载</li></ul><blockquote><p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载</p></blockquote><ul><li>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等</li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端错误监控</title>
      <link href="2020/12/26/%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/"/>
      <url>2020/12/26/%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><blockquote><p>错误监控包含的内容是：</p></blockquote><ul><li>前端错误的分类</li><li>每种错误的捕获方式</li><li>上报错误的基本原理</li></ul><blockquote><p>面试时，可能有两种问法：</p></blockquote><ul><li>如何监测 <code>js</code> 错误？（开门见山的方式）</li><li>如何保证<strong>产品质量</strong>？（其实问的也是错误监控）</li></ul><h2 id="2-前端错误的分类"><a href="#2-前端错误的分类" class="headerlink" title="2 前端错误的分类"></a>2 前端错误的分类</h2><p>包括两种：</p><ul><li>即时运行错误（代码错误）</li><li>资源加载错误</li></ul><h2 id="3-每种错误的捕获方式"><a href="#3-每种错误的捕获方式" class="headerlink" title="3 每种错误的捕获方式"></a>3 每种错误的捕获方式</h2><h3 id="3-1-即时运行错误的捕获方式"><a href="#3-1-即时运行错误的捕获方式" class="headerlink" title="3.1 即时运行错误的捕获方式"></a>3.1 即时运行错误的捕获方式</h3><p><strong>方式1</strong>：<code>try ... catch</code>。</p><blockquote><p>这种方式要部署在代码中。</p></blockquote><p><strong>方式2：</strong><code>window.onerror</code>函数。这个函数是全局的。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">msg, url, row, col, error</span>) </span>{ ... }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>参数解释：</p></blockquote><ul><li><code>msg</code>为异常基本信息</li><li><code>source</code>为发生异常<code>Javascript</code>文件的<code>url</code></li><li><code>row</code>为发生错误的行号</li></ul><blockquote><p>方式二中的<code>window.onerror</code>是属于DOM0的写法，我们也可以用DOM2的写法：<code>window.addEventListener("error", fn);</code>也可以。</p></blockquote><p><strong>问题延伸1：</strong></p><p><code>window.onerror</code>默认无法捕获<strong>跨域</strong>的<code>js</code>运行错误。捕获出来的信息如下：（基本属于无效信息）</p><blockquote><p>比如说，我们的代码想引入<code>B</code>网站的<code>b.js</code>文件，怎么捕获它的异常呢？</p></blockquote><p><strong>解决办法</strong>：在方法二的基础之上，做如下操作：</p><ol><li>在<code>b.js</code>文件里，加入如下 <code>response</code> <code>header</code>，表示允许跨域：（或者世界给静态资源<code>b.js</code>加这个 response header）</li></ol><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>引入第三方的文件<code>b.js</code>时，在<code>&lt;script&gt;</code>标签中增加<code>crossorigin</code>属性；</li></ol><p><strong>问题延伸2：</strong></p><blockquote><p>只靠方式二中的<code>window.onerror</code>是不够的，因为我们无法获取文件名是什么，不知道哪里出了错误。解决办法：把<strong>堆栈</strong>信息作为msg打印出来，堆栈里很详细。</p></blockquote><h3 id="3-2-资源加载错误的捕获方式"><a href="#3-2-资源加载错误的捕获方式" class="headerlink" title="3.2 资源加载错误的捕获方式"></a>3.2 资源加载错误的捕获方式</h3><blockquote><p>上面的<code>window.onerror</code>只能捕获即时运行错误，无法捕获资源加载错误。原理是：资源加载错误，并不会向上冒泡，<code>object.onerror</code>捕获后就会终止（不会冒泡给<code>window</code>），所以<code>window.onerror</code>并不能捕获资源加载错误。</p></blockquote><ul><li><strong>方式1</strong>：<code>object.onerror</code>。<code>img</code>标签、<code>script</code>标签等节点都可以添加<code>onerror</code>事件，用来捕获资源加载的错误。</li><li><strong>方式2</strong>：performance.getEntries。可以获取所有已加载资源的加载时长，通过这种方式，可以间接的拿到没有加载的资源错误。</li></ul><p>举例：</p><blockquote><p>浏览器打开一个网站，在<code>Console</code>控制台下，输入：</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">performance.getEntries().forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>{<span class="built_in">console</span>.log(item.name)})</span><br></pre></td></tr></tbody></table></figure><p>或者输入：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">performance.getEntries().forEach(<span class="function"><span class="params">item</span>=&gt;</span>{<span class="built_in">console</span>.log(item.name)})</span><br></pre></td></tr></tbody></table></figure><blockquote><p>上面这个<code>api</code>，返回的是数组，既然是数组，就可以用<code>forEach</code>遍历。打印出来的资源就是<strong>已经成功加载</strong>的资源。；</p></blockquote><p><img src="http://img.smyhvae.com/20180311_2030.png"></p><blockquote><p>再入<code>document.getElementsByTagName('img')</code>，就会显示出所有<strong>需要加载</strong>的的img集合。</p></blockquote><blockquote><p>于是，<code>document.getElementsByTagName('img')</code>获取的资源数组减去通过<code>performance.getEntries()</code>获取的资源数组，剩下的就是没有成功加载的，这种方式可以间接捕获到资源加载错误。</p></blockquote><p>这种方式非常有用，一定要记住。</p><p><strong>方式3；</strong>Error事件捕获。</p><blockquote><p>源加载错误，虽然会阻止冒泡，但是不会阻止捕获。我们可以在捕获阶段绑定error事件。例如：</p></blockquote><p><img src="http://img.smyhvae.com/20180311_2040.png"></p><blockquote><p><strong>总结：</strong>如果我们能回答出后面的两种方式，面试官对我们的印象会大大增加。既可以体现出我们对错误监控的了解，还可以体现出我们对事件模型的掌握。</p></blockquote><h2 id="4-错误上报的两种方式"><a href="#4-错误上报的两种方式" class="headerlink" title="4 错误上报的两种方式"></a>4 错误上报的两种方式</h2><ul><li><strong>方式一</strong>：采用Ajax通信的方式上报（此方式虽然可以上报错误，但是我们并不采用这种方式）</li><li><strong>方式二：</strong>利用Image对象上报（推荐。网站的监控体系都是采用的这种方式）</li></ul><blockquote><p>方式二的实现方式如下：</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">//通过Image对象进行错误上报</span></span></span><br><span class="line"><span class="javascript">    (<span class="keyword">new</span> Image()).src = <span class="string">'http://smyhvae.com/myPath?badjs=msg'</span>;   <span class="comment">// myPath表示上报的路径（我要上报到哪里去）。后面的内容是自己加的参数。</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>打开浏览器，效果如下：</p></blockquote><p><img src="http://img.smyhvae.com/20180311_2055.png"></p><p>上图中，红色那一栏表明，我的请求已经发出去了。点进去看看：</p><p><img src="http://img.smyhvae.com/20180311_2057.png"></p><blockquote><p>这种方式，不需要借助第三方的库，一行代码即可搞定。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/26/react/"/>
      <url>2020/12/26/react/</url>
      
        <content type="html"><![CDATA[<h2 id="React-中-keys-的作用是什么？"><a href="#React-中-keys-的作用是什么？" class="headerlink" title="React 中 keys 的作用是什么？"></a>React 中 keys 的作用是什么？</h2><blockquote><p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识</p></blockquote><ul><li>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性</li></ul><h2 id="传入-setState-函数的第二个参数的作用是什么？"><a href="#传入-setState-函数的第二个参数的作用是什么？" class="headerlink" title="传入 setState 函数的第二个参数的作用是什么？"></a>传入 setState 函数的第二个参数的作用是什么？</h2><blockquote><p>该函数会在setState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成：</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.setState(</span><br><span class="line">  { username: 'tylermcginnis33' },</span><br><span class="line">  () =&gt; console.log('setState has finished and the component has re-rendered.')</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.setState((prevState, props) =&gt; {</span><br><span class="line">  return {</span><br><span class="line">    streak: prevState.streak + props.count</span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="React-中-refs-的作用是什么"><a href="#React-中-refs-的作用是什么" class="headerlink" title="React 中 refs 的作用是什么"></a>React 中 refs 的作用是什么</h2><ul><li>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄</li><li>可以为元素添加ref属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回</li></ul><h2 id="在生命周期中的哪一步你应该发起-AJAX-请求"><a href="#在生命周期中的哪一步你应该发起-AJAX-请求" class="headerlink" title="在生命周期中的哪一步你应该发起 AJAX 请求"></a>在生命周期中的哪一步你应该发起 AJAX 请求</h2><blockquote><p>我们应当将AJAX 请求放到 <code>componentDidMount</code> 函数中执行，主要原因有下</p></blockquote><ul><li>React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。</li><li>如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题</li></ul><h2 id="shouldComponentUpdate-的作用"><a href="#shouldComponentUpdate-的作用" class="headerlink" title="shouldComponentUpdate 的作用"></a>shouldComponentUpdate 的作用</h2><blockquote><p>shouldComponentUpdate 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新</p></blockquote><h2 id="如何告诉-React-它应该编译生产环境版"><a href="#如何告诉-React-它应该编译生产环境版" class="headerlink" title="如何告诉 React 它应该编译生产环境版"></a>如何告诉 React 它应该编译生产环境版</h2><blockquote><p>通常情况下我们会使用 Webpack 的 DefinePlugin 方法来将 NODE_ENV 变量值设置为 production。编译版本中 React 会忽略 propType 验证以及其他的告警信息，同时还会降低代码库的大小，React 使用了 Uglify 插件来移除生产环境下不必要的注释等信息</p></blockquote><h2 id="概述下-React-中的事件处理逻辑"><a href="#概述下-React-中的事件处理逻辑" class="headerlink" title="概述下 React 中的事件处理逻辑"></a>概述下 React 中的事件处理逻辑</h2><blockquote><p>为了解决跨浏览器兼容性问题，React 会将浏览器原生事件（Browser Native Event）封装为合成事件（SyntheticEvent）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的</p></blockquote><h2 id="createElement-与-cloneElement-的区别是什么"><a href="#createElement-与-cloneElement-的区别是什么" class="headerlink" title="createElement 与 cloneElement 的区别是什么"></a>createElement 与 cloneElement 的区别是什么</h2><blockquote><p>createElement 函数是 JSX 编译之后使用的创建 React Element 的函数，而 cloneElement 则是用于复制某个元素并传入新的 Props</p></blockquote><h2 id="redux中间件"><a href="#redux中间件" class="headerlink" title="redux中间件"></a>redux中间件</h2><blockquote><p>中间件提供第三方插件的模式，自定义拦截 action -&gt; reducer 的过程。变为 action -&gt; middlewares -&gt; reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能</p></blockquote><ul><li><code>redux-logger</code>：提供日志输出</li><li><code>redux-thunk</code>：处理异步操作</li><li><code>redux-promise</code>：处理异步操作，<code>actionCreator</code>的返回值是<code>promise</code></li></ul><h2 id="redux有什么缺点"><a href="#redux有什么缺点" class="headerlink" title="redux有什么缺点"></a>redux有什么缺点</h2><ul><li>一个组件所需要的数据，必须由父组件传过来，而不能像flux中直接从store取。</li><li>当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会有效率影响，或者需要写复杂的<code>shouldComponentUpdate</code>进行判断。</li></ul><h2 id="react组件的划分业务组件技术组件？"><a href="#react组件的划分业务组件技术组件？" class="headerlink" title="react组件的划分业务组件技术组件？"></a>react组件的划分业务组件技术组件？</h2><ul><li>根据组件的职责通常把组件分为UI组件和容器组件。</li><li>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</li><li>两者通过<code>React-Redux</code> 提供<code>connect</code>方法联系起来</li></ul><h2 id="react生命周期函数"><a href="#react生命周期函数" class="headerlink" title="react生命周期函数"></a>react生命周期函数</h2><p><strong>初始化阶段</strong></p><ul><li><code>getDefaultProp</code>s:获取实例的默认属性</li><li><code>getInitialState</code>:获取每个实例的初始化状态</li><li><code>componentWillMount</code>：组件即将被装载、渲染到页面上</li><li><code>render</code>:组件在这里生成虚拟的DOM节点</li><li><code>omponentDidMount</code>:组件真正在被装载之后</li></ul><p><strong>运行中状态</strong></p><ul><li><code>componentWillReceiveProps</code>:组件将要接收到属性的时候调用</li><li><code>shouldComponentUpdate</code>:组件接受到新属性或者新状态的时候（可以返回false，接收数据后不更新，阻止<code>render</code>调用，后面的函数不会被继续执行了）</li><li><code>componentWillUpdate</code>:组件即将更新不能修改属性和状态</li><li><code>render</code>:组件重新描绘</li><li><code>componentDidUpdate</code>:组件已经更新</li></ul><p><strong>销毁阶段</strong></p><ul><li><code>componentWillUnmount</code>:组件即将销毁</li></ul><h2 id="react性能优化是哪个周期函数"><a href="#react性能优化是哪个周期函数" class="headerlink" title="react性能优化是哪个周期函数"></a>react性能优化是哪个周期函数</h2><blockquote><p>shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom。因为dom的描绘非常消耗性能，如果我们能在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能</p></blockquote><h2 id="为什么虚拟dom会提高性能"><a href="#为什么虚拟dom会提高性能" class="headerlink" title="为什么虚拟dom会提高性能"></a>为什么虚拟dom会提高性能</h2><blockquote><p>虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能</p></blockquote><p><strong>具体实现步骤如下</strong></p><ul><li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li><li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li><li>把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新</li></ul><h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法?"></a>diff算法?</h2><ul><li>把树形结构按照层级分解，只比较同级元素。</li><li>给列表结构的每个单元添加唯一的key属性，方便比较。</li><li>React 只会匹配相同 class 的 component（这里面的class指的是组件的名字）</li><li>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 - dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</li><li>选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能</li></ul><h2 id="react性能优化方案"><a href="#react性能优化方案" class="headerlink" title="react性能优化方案"></a>react性能优化方案</h2><ul><li>重写<code>shouldComponentUpdate</code>来避免不必要的dom操作</li><li>使用 production 版本的react.js</li><li>使用key来帮助React识别列表中所有子组件的最小变化</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/26/mobile-terminal/"/>
      <url>2020/12/26/mobile-terminal/</url>
      
        <content type="html"><![CDATA[<p><strong>移动端（Android、IOS）怎么做好用户体验?</strong></p><ul><li>清晰的视觉纵线</li><li>信息的分组、极致的减法</li><li>利用选择代替输入</li><li>标签及文字的排布方式</li><li>依靠明文确认密码</li><li>合理的键盘利用</li></ul><p><strong>前端页面有哪三层构成，分别是什么？作用是什么？</strong></p><ul><li>结构层：由 (X)HTML 标记语言负责，解决页面“内容是什么”的问题</li><li>表示层：由 CSS 负责，解决页面“如何显示内容”的问题</li><li>行为层：由 JS 脚本负责，解决页面上“内容应该如何对事件作出反应”的问题</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/26/performance-optimization/"/>
      <url>2020/12/26/performance-optimization/</url>
      
        <content type="html"><![CDATA[<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><hr><p><strong>如何进行网站性能优化</strong></p><ul><li><p>content方面</p><ul><li>减少HTTP请求：合并文件、CSS精灵、inline Image</li><li>减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询</li><li>避免重定向：多余的中间访问</li><li>使Ajax可缓存</li><li>非必须组件延迟加载</li><li>未来所需组件预加载</li><li>减少DOM元素数量</li><li>将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量</li><li>减少iframe数量</li><li>不要404</li></ul></li><li><p>Server方面</p><ul><li>使用CDN</li><li>添加Expires或者Cache-Control响应头</li><li>对组件使用Gzip压缩</li><li>配置ETag</li><li>Flush Buffer Early</li><li>Ajax使用GET进行请求</li><li>避免空src的img标签</li></ul></li><li><p>Cookie方面</p><ul><li>减小cookie大小</li><li>引入资源的域名不要包含cookie</li></ul></li><li><p>css方面</p><ul><li>将样式表放到页面顶部</li><li>不使用CSS表达式</li><li>不使用IE的Filter</li></ul></li><li><p>Javascript方面</p><ul><li>将脚本放到页面底部</li><li>将javascript和css从外部引入</li><li>压缩javascript和css</li><li>删除不需要的脚本</li><li>减少DOM访问</li><li>合理设计事件监听器</li></ul></li><li><p>图片方面</p><ul><li>优化图片：根据实际颜色需要选择色深、压缩</li><li>优化css精灵</li><li>不要在HTML中拉伸图片</li><li>保证favicon.ico小并且可缓存</li></ul></li><li><p>移动方面</p><ul><li>保证组件小于25k</li><li><code>Pack Components into a Multipart Document</code></li></ul></li></ul><p><strong>你有用过哪些前端性能优化的方法？</strong></p><ul><li>减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</li><li> 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</li><li> 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</li><li> 当需要设置的样式很多时设置className而不是直接操作style</li><li> 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作</li><li> 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)</li><li> 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳</li><li> 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢</li></ul><p><strong>谈谈性能优化问题</strong></p><ul><li>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器</li><li>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等</li><li>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载</li><li>请求带宽：压缩文件，开启GZIP</li></ul><p><strong>代码层面的优化</strong></p><ul><li><p>用hash-table来优化查找</p></li><li><p>少用全局变量</p></li><li><p>用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能</p></li><li><p>用setTimeout来避免页面失去响应</p></li><li><p>缓存DOM节点查找的结果</p></li><li><p>避免使用CSS Expression</p></li><li><p>避免全局查询</p></li><li><p>避免使用with(with会创建自己的作用域，会增加作用域链长度)</p></li><li><p>多个变量声明合并</p></li><li><p>避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率</p></li><li><p>尽量避免写在HTML标签中写Style属性</p></li></ul><p><strong>前端性能优化最佳实践？</strong></p><ul><li>性能评级工具（PageSpeed 或 YSlow）</li><li>合理设置 HTTP 缓存：Expires 与 Cache-control</li><li>静态资源打包，开启 Gzip 压缩（节省响应流量）</li><li>CSS3 模拟图像，图标base64（降低请求数）</li><li>模块延迟(defer)加载/异步(async)加载</li><li>Cookie 隔离（节省请求流量）</li><li>localStorage（本地存储）</li><li>使用 CDN 加速（访问最近服务器）</li><li>启用 HTTP/2（多路复用，并行加载）</li><li>前端自动化（gulp/webpack）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/26/other/"/>
      <url>2020/12/26/other/</url>
      
        <content type="html"><![CDATA[<p><strong>如何评价AngularJS和BackboneJS</strong></p><ul><li><p>backbone具有依赖性，依赖underscore.js。Backbone + Underscore + jQuery(or Zepto)就比一个AngularJS 多出了2 次HTTP请求.</p></li><li><p>Backbone的Model没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。AngularJS与此相反，Model直接与UI视图绑定，Model与UI视图的关系，通过directive封装，AngularJS内置的通用directive，就能实现大部分操作了，也就是说，基本不必关心Model与UI视图的关系，直接操作Model就行了，UI视图自动更新</p></li><li><p>AngularJS的directive，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令</p></li></ul><p><strong>谈谈你对重构的理解</strong></p><ul><li><p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI</p></li><li><p>对于传统的网站来说重构通常是：</p><ul><li><p>表格(table)布局改为DIV+CSS</p></li><li><p>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)</p></li><li><p>对于移动平台的优化</p></li><li><p>针对于SEO进行优化</p></li><li><p>深层次的网站重构应该考虑的方面</p></li></ul></li></ul><p><strong>说说你对前端架构师的理解</strong></p><ul><li>负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；带领团队完成研发工具及平台前端部分的设计、研发和维护； 带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训</li></ul><p><strong>什么样的前端代码是好的</strong></p><ul><li>高复用低耦合，这样文件小，好维护，而且好扩展。</li></ul><p><strong>谈谈你对webpack的看法</strong></p><blockquote><p>WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源</p></blockquote><p><strong>页面重构怎么操作？</strong></p><ul><li><p>网站重构：不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。</p></li><li><p>页面重构可以考虑的方面：</p><ul><li>升级第三方依赖</li><li>使用HTML5、CSS3、ES6 新特性</li><li>加入响应式布局</li><li>统一代码风格规范</li><li>减少代码间的耦合</li><li>压缩/合并静态资源</li><li>程序的性能优化</li><li>采用CDN来加速资源加载</li><li>对于JS DOM的优化</li><li>HTTP服务器的文件缓存</li></ul></li></ul><p><strong>列举IE与其他浏览器不一样的特性？</strong></p><ul><li>IE 的渲染引擎是 Trident 与 W3C 标准差异较大：例如盒子模型的怪异模式</li><li>JS 方面有很多独立的方法，例如事件处理不同：绑定/删除事件，阻止冒泡，阻止默认事件等</li><li>CSS 方面也有自己独有的处理方式，例如设置透明，低版本IE中使用滤镜的方式</li></ul><p><strong>是否了解公钥加密和私钥加密？</strong></p><ul><li>私钥用于对数据进行签名，公钥用于对签名进行验证</li><li>网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密</li></ul><p><strong>WEB应用从服务器主动推送Data到客户端有那些方式？</strong></p><ul><li>AJAX 轮询</li><li>html5 服务器推送事件<br><code>(new EventSource(SERVER_URL)).addEventListener("message", func);</code></li><li>html5 Websocket</li></ul><ul><li><code>(new WebSocket(SERVER_URL)).addEventListener("message", func);</code></li></ul><p><strong>你怎么看待 Web App/hybrid App/Native App？（移动端前端 和 Web 前端区别？）</strong></p><ul><li><p>Web App(HTML5)：采用HTML5生存在浏览器中的应用，不需要下载安装</p><ul><li>优点：开发成本低，迭代更新容易，不需用户升级，跨多个平台和终端</li><li>缺点：消息推送不够及时，支持图形和动画效果较差，功能使用限制（相机、GPS等）</li></ul></li><li><p>Hybrid App(混合开发)：UI WebView，需要下载安装</p><ul><li>优点：接近 Native App 的体验，部分支持离线功能</li><li>缺点：性能速度较慢，未知的部署时间，受限于技术尚不成熟</li></ul></li><li><p>Native App(原生开发)：依托于操作系统，有很强的交互，需要用户下载安装使用</p><ul><li>优点：用户体验完美，支持离线工作，可访问本地资源（通讯录，相册）</li><li>缺点：开发成本高（多系统），开发成本高（版本更新），需要应用商店的审核</li></ul></li></ul><p><strong>Web 前端开发的注意事项？</strong></p><ul><li>特别设置 meta 标签 viewport</li><li>百分比布局宽度，结合 box-sizing: border-box;</li><li>使用 rem 作为计算单位。rem 只参照跟节点 html 的字体大小计算</li><li>使用 css3 新特性。弹性盒模型、多列布局、媒体查询等</li><li>多机型、多尺寸、多系统覆盖测试</li></ul><p><strong>在设计 Web APP 时，应当遵循以下几点</strong></p><ul><li>简化不重要的动画/动效/图形文字样式</li><li>少用手势，避免与浏览器手势冲突</li><li>减少页面内容，页面跳转次数，尽量在当前页面显示</li><li>增强 Loading 趣味性，增强页面主次关系</li></ul><p><strong>平时如何管理你的项目？</strong></p><ul><li>规定全局样式、公共脚本</li><li>严格要求代码注释(html/js/css)</li><li>严格要求静态资源存放路径</li><li>Git 提交必须填写说明</li></ul><p><strong>如何设计突发大规模并发架构？</strong></p><ul><li>及时响应(NoSQL缓存)</li><li>数据安全(数据备份)</li><li>负载均衡</li></ul><p><strong>说说最近最流行的一些东西吧？</strong></p><ul><li>ES6、Node、React、Webpack</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何解决跨域问题</title>
      <link href="2020/12/26/cross-domain/"/>
      <url>2020/12/26/cross-domain/</url>
      
        <content type="html"><![CDATA[<h3 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h3><hr><p><strong>JSONP：</strong></p><ul><li>原理是：动态插入<code>script</code>标签，通过<code>script</code>标签引入一个<code>js</code>文件，这个<code>js</code>文件载入成功后会执行我们在<code>url</code>参数中指定的函数，并且会把我们需要的<code>json</code>数据作为参数传入</li><li>由于同源策略的限制，<code>XmlHttpRequest</code>只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过<code>script</code>标签实现跨域请求，然后在服务端输出<code>JSON</code>数据并执行回调函数，从而解决了跨域的数据请求</li><li>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求</li><li><code>JSONP</code>：<code>json+padding</code>（内填充），顾名思义，就是把<code>JSON</code>填充到一个盒子里</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createJs</span>(<span class="params">sUrl</span>)</span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> oScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    oScript.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    oScript.src = sUrl;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(oScript);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">createJs(<span class="string">'jsonp.js'</span>);</span><br><span class="line"></span><br><span class="line">box({</span><br><span class="line">   <span class="string">'name'</span>: <span class="string">'test'</span></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span>(<span class="params">json</span>)</span>{</span><br><span class="line">    alert(json.name);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>CORS</strong></p><ul><li>服务器端对于<code>CORS</code>的支持，主要就是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许<code>Ajax</code>进行跨域的访问</li></ul><p><strong>通过修改document.domain来跨子域</strong></p><ul><li>将子域和主域的<code>document.domain</code>设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用<code>document.domain</code>进行跨域。主域相同的使用<code>document.domain</code></li></ul><p><strong>使用window.name来进行跨域</strong></p><ul><li><code>window</code>对象有个name属性，该属性有个特征：即在一个窗口(<code>window</code>)的生命周期内,窗口载入的所有的页面都是共享一个<code>window.name</code>的，每个页面对window.name都有读写的权限，<code>window.name</code>是持久存在一个窗口载入过的所有页面中的</li></ul><p><strong>使用HTML5中新引进的window.postMessage方法来跨域传送数据</strong></p><ul><li>还有<code>flash</code>、在服务器上设置代理页面等跨域方式。个人认为<code>window.name</code>的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法</li></ul><p><strong>如何解决跨域问题?</strong></p><ul><li><p><code>jsonp</code>、 <code>iframe</code>、<code>window.name</code>、<code>window.postMessage</code>、服务器上设置代理页面</p></li><li><p>如何解决跨域问题?</p><ul><li><code>document.domain + iframe</code>：要求主域名相同 //只能跨子域</li><li><code>JSONP(JSON with Padding)``：</code>response: callback(data)`` //只支持 GET 请求</li><li>跨域资源共享<code>CORS(XHR2)``：</code>Access-Control-Allow` //兼容性 IE10+</li><li>跨文档消息传输(HTML5)：<code>postMessage + onmessage</code>  //兼容性 IE8+</li><li><code>WebSocket(HTML5)：new WebSocket(url) + onmessage</code> //兼容性 IE10+</li><li>服务器端设置代理请求：服务器端不受同源策略限制</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="2020/12/26/data-structure/"/>
      <url>2020/12/26/data-structure/</url>
      
        <content type="html"><![CDATA[<p><strong>栈和队列的区别?</strong></p><ul><li>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。</li><li>队列先进先出，栈先进后出。</li><li>栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除</li></ul><p><strong>栈和堆的区别？</strong></p><ul><li>栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。</li><li>堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。</li><li>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；</li><li>栈（数据结构）：一种先进后出的数据结构</li></ul><p><strong>快速 排序的思想并实现一个快排？</strong></p><p>“快速排序”的思想很简单，整个排序过程只需要三步：</p><ul><li>（1）在数据集之中，找一个基准点</li><li>（2）建立两个数组，分别存储左边和右边的数组</li><li>（3）利用递归进行下次比较</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>{</span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>){</span><br><span class="line">        <span class="keyword">return</span> arr;<span class="comment">//如果数组只有一个数，就直接返回；</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);<span class="comment">//找到中间数的索引值，如果是浮点数，则向下取整</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> numValue = arr.splice(num,<span class="number">1</span>);<span class="comment">//找到中间数的值</span></span><br><span class="line">    <span class="keyword">var</span> left = [];</span><br><span class="line">    <span class="keyword">var</span> right = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++){</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;numValue){</span><br><span class="line">            left.push(arr[i]);<span class="comment">//基准点的左边的数传到左边数组</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">           right.push(arr[i]);<span class="comment">//基准点的右边的数传到右边数组</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat([numValue],quickSort(right));<span class="comment">//递归不断重复比较</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">alert(quickSort([<span class="number">32</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">16</span>,<span class="number">2</span>,<span class="number">87</span>]));<span class="comment">//弹出“2,16,32,37,45,87”</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请你谈谈Cookie的弊端</title>
      <link href="2020/12/26/cookie/"/>
      <url>2020/12/26/cookie/</url>
      
        <content type="html"><![CDATA[<p><strong>请你谈谈Cookie的弊端</strong></p><ul><li><p>cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的</p></li><li><p>第一：每个特定的域名下最多生成20个cookie</p></li><li><p>1.IE6或更低版本最多20个cookie</p></li><li><p>2.IE7和之后的版本最后可以有50个cookie。</p></li><li><p>3.Firefox最多50个cookie</p></li><li><p>4.chrome和Safari没有做硬性限制</p></li></ul><p><strong>请你谈谈Cookie的弊端？</strong></p><ul><li>每个特定的域名下最多生成的 cookie 个数有限制</li><li>IE 和 Opera 会清理近期最少使用的 cookie，Firefox 会随机清理 cookie</li><li>cookie 的最大大约为 4096 字节，为了兼容性，一般设置不超过 4095 字节</li><li>如果 cookie 被人拦截了，就可以取得所有的 session 信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/26/computer-basic-knowledge/"/>
      <url>2020/12/26/computer-basic-knowledge/</url>
      
        <content type="html"><![CDATA[<p><strong>线程与进程的区别</strong></p><ul><li>一个程序至少有一个进程，一个进程至少有一个线程</li><li>线程的划分尺度小于进程，使得多线程程序的并发性高</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存</li><li>线程不能够独立执行，必须应用程序提供多个线程执行控制</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对前端工程师这个职位是怎么样理解的？它的前景会怎么样？</title>
      <link href="2020/12/26/comprehensive/"/>
      <url>2020/12/26/comprehensive/</url>
      
        <content type="html"><![CDATA[<h2 id="对前端工程师这个职位是怎么样理解的？它的前景会怎么样？"><a href="#对前端工程师这个职位是怎么样理解的？它的前景会怎么样？" class="headerlink" title="对前端工程师这个职位是怎么样理解的？它的前景会怎么样？"></a>对前端工程师这个职位是怎么样理解的？它的前景会怎么样？</h2><ul><li>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近<ul><li>实现界面交互</li><li>提升用户体验</li><li>有了<code>Node.js</code>，前端可以实现服务端的一些事情</li></ul></li><li>前端是最贴近用户的程序员，前端的能力就是能让产品从 <code>90</code>分进化到 <code>100</code> 分，甚至更好，</li><li>参与项目，快速高质量完成实现效果图，精确到<code>1px</code></li><li>与团队成员，<code>UI</code>设计，产品经理的沟通；</li><li>做好的页面结构，页面重构和用户体验；</li><li>处理<code>hack</code>，兼容、写出优美的代码格式；</li><li>针对服务器的优化、拥抱最新前端技术。</li></ul><h2 id="平时如何管理你的项目？"><a href="#平时如何管理你的项目？" class="headerlink" title="平时如何管理你的项目？"></a>平时如何管理你的项目？</h2><ul><li>先期团队必须确定好全局样式（<code>globe.css</code>），编码模式(<code>utf-8</code>) 等；</li><li>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</li><li>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</li><li>页面进行标注（例如 页面 模块 开始和结束）；</li><li><code>CSS</code>跟<code>HTML</code> 分文件夹并行存放，命名都得统一（例如<code>style.css</code>）；</li><li><code>JS</code> 分文件夹存放 命名以该JS功能为准的英文翻译</li><li>图片采用整合的 <code>images.png</code> <code>png8</code> 格式文件使用</li><li>尽量整合在一起使用方便将来的管理</li></ul><h2 id="一些开放性题目"><a href="#一些开放性题目" class="headerlink" title="一些开放性题目"></a>一些开放性题目</h2><ul><li>自我介绍：除了基本个人信息以外，面试官更想听的是你与众不同的地方和你的优势</li><li>项目介绍</li><li>如何看待前端开发？</li><li>平时是如何学习前端开发的？</li><li>未来三到五年的规划是怎样的？</li></ul><h2 id="你觉得前端工程的价值体现在哪"><a href="#你觉得前端工程的价值体现在哪" class="headerlink" title="你觉得前端工程的价值体现在哪"></a>你觉得前端工程的价值体现在哪</h2><ul><li>为简化用户使用提供技术支持（交互部分）</li><li>为多个浏览器兼容性提供支持</li><li>为提高用户浏览速度（浏览器性能）提供支持</li><li>为跨平台或者其他基于<code>webkit</code>或其他渲染引擎的应用提供支持</li><li>为展示数据提供支持（数据接口）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/12/26/PS/"/>
      <url>2020/12/26/PS/</url>
      
        <content type="html"><![CDATA[<h3 id="PS相关"><a href="#PS相关" class="headerlink" title="PS相关"></a>PS相关</h3><hr><p><strong>PNG,GIF,JPG的区别及如何选</strong></p><ul><li><p>GIF：</p><ul><li>8位像素，256色</li><li>无损压缩</li><li>支持简单动画</li><li>支持boolean透明</li><li>适合简单动画</li></ul></li><li><p>JPEG：</p><ul><li>颜色限于256</li><li>有损压缩</li><li>可控制压缩质量</li><li>不支持透明</li><li>适合照片</li></ul></li><li><p>PNG：</p><ul><li>有PNG8和truecolor PNG</li><li>PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画</li><li>适合图标、背景、按钮</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="2020/12/26/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%8F%8ABFC/"/>
      <url>2020/12/26/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%8F%8ABFC/</url>
      
        <content type="html"><![CDATA[<h2 id="题目：谈一谈你对CSS盒模型的认识"><a href="#题目：谈一谈你对CSS盒模型的认识" class="headerlink" title="题目：谈一谈你对CSS盒模型的认识"></a>题目：谈一谈你对CSS盒模型的认识</h2><blockquote><p>专业的面试，一定会问 <code>CSS</code> 盒模型。对于这个题目，我们要回答一下几个方面：</p></blockquote><ol><li>基本概念：<code>content</code>、<code>padding</code>、<code>margin</code></li><li>标准盒模型、<code>IE</code>盒模型的区别。不要漏说了<code>IE</code>盒模型，通过这个问题，可以筛选一部分人</li><li><code>CSS</code>如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。</li><li><code>JS</code>如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。</li><li>实例题：根据盒模型解释<strong>边距重叠</strong>。</li></ol><blockquote><p>前四个方面是逐渐递增，第五个方面，却鲜有人知。</p></blockquote><ol start="6"><li><code>BFC</code>（边距重叠解决方案）或<code>IFC</code>。</li></ol><blockquote><p>如果能回答第五条，就会引出第六条。<code>BFC</code>是面试频率较高的。</p></blockquote><p><strong>总结</strong>：以上几点，从上到下，知识点逐渐递增，知识面从理论、<code>CSS</code>、<code>JS</code>，又回到<code>CSS</code>理论</p><p>接下来，我们把上面的六条，依次讲解。</p><p><strong>标准盒模型和IE盒子模型</strong></p><p>标准盒子模型：</p><p><img src="http://img.smyhvae.com/2015-10-03-css-27.jpg"></p><p><code>IE</code>盒子模型：</p><p><img src="http://img.smyhvae.com/2015-10-03-css-30.jpg"></p><p>上图显示：</p><blockquote><p>在 <code>CSS</code> 盒子模型 (<code>Box Model</code>) 规定了元素处理元素的几种方式：</p></blockquote><ul><li><code>width</code>和<code>height</code>：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）。</li><li><code>padding</code>：内边距。</li><li><code>border</code>：边框。</li><li><code>margin</code>：外边距。</li></ul><blockquote><p><code>CSS</code>盒模型和<code>IE</code>盒模型的区别：</p></blockquote><ul><li><p>在<strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p></li><li><p><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+border+padding</strong>的宽度和高度。</p></li></ul><p><strong>CSS如何设置这两种模型</strong></p><p>代码如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置当前盒子为 标准盒模型（默认） */</span></span><br><span class="line">box-sizing: content-box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置当前盒子为 IE盒模型 */</span></span><br><span class="line">box-sizing: border-box;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>备注：盒子默认为标准盒模型。</p></blockquote><p><strong>JS如何设置、获取盒模型对应的宽和高</strong></p><blockquote><p>方式一：通过<code>DOM</code>节点的 <code>style</code> 样式获取</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.style.width/height;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>缺点：通过这种方式，只能获取<strong>行内样式</strong>，不能获取<code>内嵌</code>的样式和<code>外链</code>的样式。</p></blockquote><p>这种方式有局限性，但应该了解。</p><blockquote><p>方式二（通用型）</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.getComputedStyle(element).width/height;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>方式二能兼容 <code>Chrome</code>、火狐。是通用型方式。</p></blockquote><blockquote><p>方式三（IE独有的）</p></blockquote><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.currentStyle.width/height;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。</p></blockquote><blockquote><p>方式四</p></blockquote><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.getBoundingClientRect().width/height;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>此 <code>api</code> 的作用是：获取一个元素的绝对位置。绝对位置是视窗 <code>viewport</code> 左上角的绝对位置。此 <code>api</code> 可以拿到四个属性：<code>left</code>、<code>top</code>、<code>width</code>、<code>height</code>。</p></blockquote><p><strong>总结：</strong></p><blockquote><p>上面的四种方式，要求能说出来区别，以及哪个的通用型更强。</p></blockquote><p><strong>margin塌陷/margin重叠</strong></p><p><strong>标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin</strong>(水平方向的<code>margin</code>是可以叠加的，即水平方向没有塌陷现象)。</p><blockquote><p>PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有<code>margin</code>重叠的现象的。</p></blockquote><blockquote><p>我们来看几个例子。</p></blockquote><p><strong>兄弟元素之间</strong></p><p>如下图所示：</p><p><img src="http://img.smyhvae.com/20170805_0904.png"></p><p><strong>子元素和父元素之间</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        * {</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father</span> {</span></span><br><span class="line">            background: green;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 给儿子设置margin-top为10像素 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.son</span> {</span></span><br><span class="line">            height: 100px;</span><br><span class="line">            margin-top: 10px;</span><br><span class="line">            background: red;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>上面的代码中，儿子的<code>height</code>是 <code>100p</code>x，<code>magin-top</code> 是<code>10px</code>。注意，此时父亲的 <code>height</code> 是<code>100</code>，而不是<code>110</code>。因为儿子和父亲在竖直方向上，共一个<code>margin</code>。</p></blockquote><p>儿子这个盒子：</p><p><img src="http://img.smyhvae.com/20180305_2216.png"></p><p>父亲这个盒子：</p><p><img src="http://img.smyhvae.com/20180305_2217.png"></p><blockquote><p>上方代码中，如果我们给父亲设置一个属性：<code>overflow: hidden</code>，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。</p></blockquote><p><strong>善于使用父亲的padding，而不是儿子的margin</strong></p><blockquote><p>其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。</p></blockquote><p>我们来看一个奇怪的现象。现在有下面这样一个结构：（<code>div</code>中放一个<code>p</code>）</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>上面的结构中，我们尝试通过给儿子<code>p</code>一个<code>margin-top:50px;</code>的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象：</p></blockquote><p><img src="http://img.smyhvae.com/20170806_1537.png"></p><blockquote><p>此时我们给父亲<code>div</code>加一个<code>border</code>属性，就正常了：</p></blockquote><p><img src="http://img.smyhvae.com/20170806_1544.png"></p><blockquote><p>如果父亲没有<code>border</code>，那么儿子的<code>margin</code>实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。</p></blockquote><p><strong>margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。</strong></p><blockquote><p>所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的`margin。</p></blockquote><p><strong>BFC（边距重叠解决方案）</strong></p><blockquote><p><code>BFC（Block Formatting Context）</code>：块级格式化上下文。你可以把它理解成一个独立的区域。</p></blockquote><p>另外还有个概念叫<code>IFC</code>。不过，<code>BFC</code>问得更多。</p><p><strong>BFC 的原理/BFC的布局规则【非常重要】</strong></p><blockquote><p><code>BFC</code> 的原理，其实也就是 <code>BFC</code> 的渲染规则（能说出以下四点就够了）。包括：</p></blockquote><ol><li>BFC <strong>内部的</strong>子元素，在垂直方向，<strong>边距会发生重叠</strong>。</li><li>BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看<code>举例1</code>）</li><li><strong>BFC区域不与旁边的<code>float box</code>区域重叠</strong>。（可以用来清除浮动带来的影响）。（稍后看<code>举例2</code>）</li><li>计算<code>BFC</code>的高度时，浮动的子元素也参与计算。（稍后看<code>举例3</code>）</li></ol><p><strong>如何生成BFC</strong></p><blockquote><p>有以下几种方法：</p></blockquote><ul><li>方法1：<code>overflow</code>: 不为<code>visible</code>，可以让属性是 <code>hidden</code>、<code>auto</code>。【最常用】</li><li>方法2：浮动中：<code>float</code>的属性值不为<code>none</code>。意思是，只要设置了浮动，当前元素就创建了<code>BFC</code>。</li><li>方法3：定位中：只要<code>posiiton</code>的值不是 s<code>tatic</code>或者是<code>relative</code>即可，可以是<code>absolute</code>或<code>fixed</code>，也就生成了一个<code>BFC</code>。</li><li>方法4：<code>display</code>为<code>inline-block</code>, <code>table-cell</code>, <code>table-caption</code>, <code>flex</code>, <code>inline-flex</code></li></ul><p><strong>BFC 的应用</strong></p><p><strong>举例1：</strong>解决 margin 重叠</p><blockquote><p>当父元素和子元素发生 <code>margin</code> 重叠时，解决办法：<strong>给子元素或父元素创建BFC</strong>。</p></blockquote><p>比如说，针对下面这样一个 <code>div</code> 结构：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>上面的<code>div</code>结构中，如果父元素和子元素发生<code>margin</code>重叠，我们可以给子元素创建一个 <code>BFC</code>，就解决了：</p></blockquote><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"son"</span> <span class="attr">style</span>=<span class="string">"overflow: hidden"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>因为<strong>第二条：BFC区域是一个独立的区域，不会影响外面的元素</strong>。</p></blockquote><p><strong>举例2</strong>：BFC区域不与float区域重叠：</p><p>针对下面这样一个div结构；</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> {</span></span><br><span class="line">            background: pink;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.left</span> {</span></span><br><span class="line">            float: left;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: green;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.right</span> {</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span>: 150<span class="selector-tag">px</span>;  <span class="comment">/*右侧标准流里的元素，比左侧浮动的元素要高*/</span></span></span><br><span class="line">            background: red;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"father-layout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">        左侧，生命壹号</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">        右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180306_0825.png"></p><blockquote><p>上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。</p></blockquote><p><strong>如果要解决这个问题，可以将右侧的元素创建BFC</strong>，因为<strong>第三条：BFC区域不与<code>float box</code>区域重叠</strong>。解决办法如下：（将right区域添加overflow属性）</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span> <span class="attr">style</span>=<span class="string">"overflow: hidden"</span>&gt;</span></span><br><span class="line">    右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img src="http://img.smyhvae.com/20180306_0827.png"></p><p>上图表明，解决之后，<code>father-layout</code>的背景色显现出来了，说明问题解决了。</p><p><strong>举例3：</strong>清除浮动</p><p>现在有下面这样的结构：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father</span> {</span></span><br><span class="line">            background: pink;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.son</span> {</span></span><br><span class="line">            float: left;</span><br><span class="line">            background: green;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span></span><br><span class="line">        生命壹号</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180306_0840.png"></p><p>上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓<strong>有高度的盒子，才能关住浮动</strong>。</p><blockquote><p>如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 <code>overflow=hidden</code>属性即可， 增加之后，效果如下：</p></blockquote><p><img src="http://img.smyhvae.com/20180306_0845.png"></p><blockquote><p>为什么父元素成为BFC之后，就有了高度呢？这就回到了<strong>第四条：计算BFC的高度时，浮动元素也参与计算</strong>。意思是，<strong>在计算BFC的高度时，子元素的float box也会参与计算</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="2020/12/26/CSS/"/>
      <url>2020/12/26/CSS/</url>
      
        <content type="html"><![CDATA[<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><hr><p><strong>display: none; 与 visibility: hidden; 的区别</strong></p><ul><li>联系：它们都能让元素不可见</li><li>区别：<ul><li><code>display:none</code>;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility: hidden</code>;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见</li><li><code>display: none</code>;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；<code>visibility:hidden</code>;是继承属性，子孙节点消失由于继承了<code>hidden</code>，通过设置<code>visibility: visible</code>;可以让子孙节点显式</li><li>修改常规流中元素的<code>display</code>通常会造成文档重排。修改<code>visibility</code>属性只会造成本元素的重绘</li><li>读屏器不会读取<code>display: none;</code>元素内容；会读取<code>visibility: hidden</code>元素内容</li></ul></li></ul><p><strong>css hack原理及常用hack</strong></p><ul><li>原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。</li><li>常见的hack有<ul><li>属性hack</li><li>选择器hack</li><li>IE条件注释</li></ul></li></ul><p><strong>link 与 @import 的区别</strong></p><ul><li><code>link</code> 是<code>HTML</code>方式， <code>@import</code> 是<code>CSS</code>方式</li><li><code>link </code>最大限度支持并行下载，<code> @import</code> 过多嵌套导致串行下载，出现FOUC</li><li><code>link</code> 可以通过 <code>rel="alternate stylesheet"</code> 指定候选样式</li><li>浏览器对 <code>link</code> 支持早于<code> @import</code> ，可以使用 <code>@import</code> 对老浏览器隐藏样式</li><li><code>@import</code> 必须在样式规则之前，可以在<code>css</code>文件中引用其他文件</li><li>总体来说：<code>link</code>优于<code>@import</code></li></ul><p><strong>CSS有哪些继承属性</strong></p><ul><li>关于文字排版的属性如：<ul><li><code>font</code><ul><li><code>word-break</code></li><li><code>letter-spacing</code></li><li><code>text-align</code></li><li><code>text-rendering</code></li><li><code>word-spacing</code></li><li><code>white-space</code></li><li><code>text-indent</code></li><li><code>text-transform</code></li><li><code>text-shadow</code></li></ul></li><li><code>line-height</code></li><li><code>color</code></li><li><code>visibility</code></li><li><code>cursor</code></li></ul></li></ul><p><strong>display,float,position的关系</strong></p><ul><li><p>如果 <code>display</code> 为<code>none</code>，那么<code>position</code>和<code>float</code>都不起作用，这种情况下元素不产生框</p></li><li><p>否则，如果<code>position</code>值为<code>absolute</code>或者<code>fixed</code>，框就是绝对定位的，<code>float</code>的计算值为<code>none</code>，<code>display</code>根据下面的表格进行调整</p></li><li><p>否则，如果<code>float</code>不是<code>none</code>，框是浮动的，<code>display</code>根据下表进行调整</p></li><li><p>否则，如果元素是根元素，<code>display</code>根据下表进行调整</p></li><li><p>其他情况下<code>display</code>的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整 <code>display</code></p><p><img src="https://images2018.cnblogs.com/blog/715962/201805/715962-20180513012245079-391725349.png" alt="图片转自网络"></p></li></ul><p><strong>外边距折叠(collapsing margins)</strong></p><ul><li>毗邻的两个或多个 <code>margin</code> 会合并成一个<code>margin</code>，叫做外边距折叠。规则如下：<ul><li>两个或多个毗邻的普通流中的块元素垂直方向上的<code>margin</code>会折叠</li><li>浮动元素或<code>inline-block</code>元素或绝对定位元素的<code>margin</code>不会和垂直方向上的其他元素的margin折叠</li><li>创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠</li><li>元素自身的<code>margin-bottom</code>和<code>margin-top</code>相邻时也会折</li></ul></li></ul><p><strong>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</strong></p><ul><li>有两种， IE 盒子模型、W3C 盒子模型；</li><li>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；</li><li>区  别： IE的content部分把 border 和 padding计算了进去;</li></ul><p><strong>CSS选择符有哪些？哪些属性可以继承？</strong></p><ul><li><p>id选择器（ # myid）</p></li><li><p>类选择器（.myclassname）</p></li><li><p>标签选择器（div, h1, p）</p></li><li><p>相邻选择器（h1 + p）</p></li><li><p>子选择器（ul &gt; li）</p></li><li><p>后代选择器（li a）</p></li><li><p>通配符选择器（ * ）</p></li><li><p>属性选择器（a[rel = “external”]）</p></li><li><p>伪类选择器（a:hover, li:nth-child）</p></li><li><p>可继承的样式： <code>font-size font-family color, UL LI DL DD DT</code></p></li><li><p>不可继承的样式：<code>border padding margin width height </code></p></li></ul><p><strong>CSS优先级算法如何计算？</strong></p><ul><li>优先级就近原则，同权重情况下样式定义最近者为准</li><li>载入样式以最后载入的定位为准</li><li>优先级为: <code>!important &gt;  id &gt; class &gt; tag</code> important 比 内联优先级高</li></ul><p><strong>CSS3新增伪类有那些？</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br><span class="line"></span><br><span class="line">:after          在元素之前添加内容,也可以用来做清除浮动。</span><br><span class="line">:before         在元素之后添加内容</span><br><span class="line">:enabled        </span><br><span class="line">:disabled       控制表单控件的禁用状态。</span><br><span class="line">:checked        单选框或复选框被选中</span><br></pre></td></tr></tbody></table></figure><p><strong>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</strong></p><ul><li>给<code>div</code>设置一个宽度，然后添加<code>margin:0 auto</code>属性</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div{</span><br><span class="line">    width:200px;</span><br><span class="line">    margin:0 auto;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><ul><li>居中一个浮动元素</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//确定容器的宽高 宽500 高 300 的层</span><br><span class="line">//设置层的外边距</span><br><span class="line"></span><br><span class="line"> .div {</span><br><span class="line">      width:500px ; height:300px;//高度可以不设</span><br><span class="line">      margin: -150px 0 0 -250px;</span><br><span class="line">      position:relative;         //相对定位</span><br><span class="line">      background-color:pink;     //方便看效果</span><br><span class="line">      left:50%;</span><br><span class="line">      top:50%;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><ul><li>让绝对定位的div居中</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">width: 1200px;</span><br><span class="line">background: none;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">top: 0;</span><br><span class="line">left: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">right: 0;</span><br></pre></td></tr></tbody></table></figure><p><strong>display有哪些值？说明他们的作用</strong></p><ul><li>block         象块类型元素一样显示。</li><li>none          缺省值。象行内元素类型一样显示。</li><li>inline-block  象行内元素一样显示，但其内容象块类型元素一样显示。</li><li>list-item     象块类型元素一样显示，并添加样式列表标记。</li><li>table         此元素会作为块级表格来显示</li><li>inherit       规定应该从父元素继承 display 属性的值</li></ul><p><strong>position的值relative和absolute定位原点是？</strong></p><ul><li>absolute<ul><li>生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。</li></ul></li><li>fixed （老IE不支持）<ul><li>生成绝对定位的元素，相对于浏览器窗口进行定位。</li></ul></li><li>relative<ul><li>生成相对定位的元素，相对于其正常位置进行定位。</li></ul></li><li>static<ul><li>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right - z-index 声明）。</li></ul></li><li>inherit<ul><li>规定从父元素继承 position 属性的值</li></ul></li></ul><p><strong>CSS3有哪些新特性？</strong></p><ul><li>新增各种CSS选择器  （: not(.input)：所有 class 不是“input”的节点）</li><li>圆角           （border-radius:8px）</li><li>多列布局        （multi-column layout）</li><li>阴影和反射        （Shadow\Reflect）</li><li>文字特效      （text-shadow、）</li><li>文字渲染      （Text-decoration）</li><li>线性渐变      （gradient）</li><li>旋转          （transform）</li><li>增加了旋转,缩放,定位,倾斜,动画，多背景</li><li><code>transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:</code></li></ul><p><strong>用纯CSS创建一个三角形的原理是什么？</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 把上、左、右三条边隐藏掉（颜色设为 transparent）</span><br><span class="line">#demo {</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  border-width: 20px;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-color: transparent transparent red transparent;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>一个满屏 品 字布局 如何设计?</strong></p><ul><li>简单的方式：<ul><li>上面的div宽100%，</li><li>下面的两个div分别宽50%，</li><li>然后用float或者inline使其不换行即可</li></ul></li></ul><p><strong>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</strong></p><ul><li><p>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.</p></li><li><p>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一</p></li><li><p>IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;</p></li><li><p>Firefox下,只能使用getAttribute()获取自定义属性。</p><ul><li>解决方法:统一通过getAttribute()获取自定义属性</li></ul></li><li><p> IE下,even对象有x,y属性,但是没有pageX,pageY属性</p></li><li><p> Firefox下,event对象有pageX,pageY属性,但是没有x,y属性</p></li></ul><p><strong>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</strong></p><ul><li>行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了</li></ul><p><strong>为什么要初始化CSS样式</strong></p><ul><li>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异</li></ul><p><strong>对BFC规范(块级格式化上下文：block formatting context)的理解？</strong></p><ul><li>一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型</li><li>不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响</li></ul><p><strong>css定义的权重</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下/// 例子是演示各种定义的权重值：</span><br><span class="line"></span><br><span class="line">/*权重为1*/</span><br><span class="line">div{</span><br><span class="line">}</span><br><span class="line">/*权重为10*/</span><br><span class="line">.class1{</span><br><span class="line">}</span><br><span class="line">/*权重为100*/</span><br><span class="line">#id1{</span><br><span class="line">}</span><br><span class="line">/*权重为100+1=101*/</span><br><span class="line">#id1 div{</span><br><span class="line">}</span><br><span class="line">/*权重为10+1=11*/</span><br><span class="line">.class1 div{</span><br><span class="line">}</span><br><span class="line">/*权重为10+10+1=21*/</span><br><span class="line">.class1 .class2 div{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</span><br></pre></td></tr></tbody></table></figure><p><strong>display:inline-block 什么时候会显示间隙？(携程)</strong></p><ul><li>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</li></ul><p><strong>谈谈浮动和清除浮动</strong></p><ul><li>浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上</li></ul><p><strong>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</strong></p><ul><li>盒子模型构成：内容(content)、内填充(padding)、 边框(border)、外边距(margin)</li><li>IE8及其以下版本浏览器，未声明 DOCTYPE，内容宽高会包含内填充和边框，称为怪异盒模型(IE盒模型)</li><li>标准(W3C)盒模型：元素宽度 = width + padding + border + margin</li><li>怪异(IE)盒模型：元素宽度 = width + margin</li><li>标准浏览器通过设置 css3 的 box-sizing: border-box 属性，触发“怪异模式”解析计算宽高</li></ul><p><strong>box-sizing 常用的属性有哪些？分别有什么作用？</strong></p><ul><li>box-sizing: content-box;  // 默认的标准(W3C)盒模型元素效果</li><li>box-sizing: border-box;   // 触发怪异(IE)盒模型元素的效果</li><li>box-sizing: inherit;      //  继承父元素 box-sizing 属性的值</li></ul><p><strong>CSS选择器有哪些？</strong></p><ul><li>id选择器        #id</li><li>类选择器        .class</li><li>标签选择器      div, h1, p</li><li>相邻选择器      h1 + p</li><li>子选择器        ul &gt; li</li><li>后代选择器      li a</li><li>通配符选择器    *</li><li>属性选择器      a[rel=’external’]</li><li>伪类选择器      a:hover, li:nth-child</li></ul><p><strong>CSS哪些属性可以继承？哪些属性不可以继承？</strong></p><ul><li>可以继承的样式：font-size、font-family、color、list-style、cursor</li><li>不可继承的样式：width、height、border、padding、margin、background</li></ul><p><strong>CSS如何计算选择器优先？</strong></p><ul><li>相同权重，定义最近者为准：行内样式 &gt; 内部样式 &gt; 外部样式</li><li>含外部载入样式时，后载入样式覆盖其前面的载入的样式和内部样式</li><li>选择器优先级: 行内样式[1000] &gt; id[100] &gt; class[10] &gt; Tag[1]</li><li>在同一组属性设置中，!important 优先级最高，高于行内样式</li></ul><p><strong>CSS3新增伪类有哪些？</strong></p><ul><li><p>:root           选择文档的根元素，等同于 html 元素</p></li><li><p>:empty          选择没有子元素的元素</p></li><li><p>:target         选取当前活动的目标元素</p></li><li><p>:not(selector)  选择除 selector 元素意外的元素</p></li><li><p>:enabled        选择可用的表单元素</p></li><li><p>:disabled       选择禁用的表单元素</p></li><li><p>:checked        选择被选中的表单元素</p></li><li><p>:after          在元素内部最前添加内容</p></li><li><p>:before         在元素内部最后添加内容</p></li><li><p>:nth-child(n)      匹配父元素下指定子元素，在所有子元素中排序第n</p></li><li><p>:nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n，从后向前数</p></li><li><p>:nth-child(odd)</p></li><li><p>:nth-child(even)</p></li><li><p>:nth-child(3n+1)</p></li><li><p>:first-child</p></li><li><p>:last-child</p></li><li><p>:only-child</p></li><li><p>:nth-of-type(n)      匹配父元素下指定子元素，在同类子元素中排序第n</p></li><li><p>:nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n，从后向前数</p></li><li><p>:nth-of-type(odd)</p></li><li><p>:nth-of-type(even)</p></li><li><p>:nth-of-type(3n+1)</p></li><li><p>:first-of-type</p></li><li><p>:last-of-type</p></li><li><p>:only-of-type</p></li><li><p>::selection     选择被用户选取的元素部分</p></li><li><p>:first-line     选择元素中的第一行</p></li><li><p>:first-letter   选择元素中的第一个字符</p></li></ul><p><strong>请列举几种隐藏元素的方法</strong></p><ul><li>visibility: hidden;   这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在</li><li>opacity: 0;           CSS3属性，设置0可以使一个元素完全透明</li><li>position: absolute;   设置一个很大的 left 负值定位，使元素定位在可见区域之外</li><li>display: none;        元素会变得不可见，并且不会再占用文档的空间。</li><li>transform: scale(0);  将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留</li><li><code>&lt;div hidden="hidden"&gt;</code> HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态</li><li>height: 0;            将元素高度设为 0 ，并消除边框</li><li>filter: blur(0);      CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中</li></ul><p><strong>rgba() 和 opacity 的透明效果有什么不同？</strong></p><ul><li>opacity 作用于元素以及元素内的所有内容（包括文字）的透明度</li><li>rgba() 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果</li></ul><p><strong>css 属性 content 有什么作用？</strong></p><ul><li>content 属性专门应用在 before/after 伪元素上，用于插入额外内容或样式</li></ul><p><strong>CSS3有哪些新特性？</strong></p><ul><li>新增选择器     p:nth-child(n){color: rgba(255, 0, 0, 0.75)}</li><li>弹性盒模型     display: flex;</li><li>多列布局       column-count: 5;</li><li>媒体查询       @media (max-width: 480px) {.box: {column-count: 1;}}</li><li>个性化字体     @font-face{font-family: BorderWeb; src:url(BORDERW0.eot);}</li><li>颜色透明度     color: rgba(255, 0, 0, 0.75);</li><li>圆角           border-radius: 5px;</li><li>渐变           background:linear-gradient(red, green, blue);</li><li>阴影           box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3);</li><li>倒影           box-reflect: below 2px;</li><li>文字装饰       text-stroke-color: red;</li><li>文字溢出       text-overflow:ellipsis;</li><li>背景效果       background-size: 100px 100px;</li><li>边框效果       border-image:url(bt_blue.png) 0 10;</li><li>转换<ul><li>旋转          transform: rotate(20deg);</li><li>倾斜          transform: skew(150deg, -10deg);</li><li>位移          transform: translate(20px, 20px);</li><li>缩放          transform: scale(.5);</li></ul></li><li>平滑过渡       transition: all .3s ease-in .1s;</li><li>动画           @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;</li></ul><p><strong>请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？</strong></p><ul><li>Flexbox 用于不同尺寸屏幕中创建可自动扩展和收缩布局</li></ul><p><strong>经常遇到的浏览器的JS兼容性有哪些？解决方法是什么？</strong></p><ul><li>当前样式：getComputedStyle(el, null) VS el.currentStyle</li><li>事件对象：e VS window.event</li><li>鼠标坐标：e.pageX, e.pageY VS window.event.x, window.event.y</li><li>按键码：e.which VS event.keyCode</li><li>文本节点：el.textContent VS el.innerText</li></ul><p><strong>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</strong></p><ul><li>li排列受到中间空白(回车/空格)等的影响，因为空白也属于字符，会被应用样式占据空间，产生间隔</li><li>解决办法：在ul设置设置font-size=0,在li上设置需要的文字大小</li></ul><p><strong>什么是外边距重叠？ 重叠的结果是什么？</strong></p><ul><li><p>外边距重叠就是 margin-collapse</p></li><li><p>相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。<br>这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距</p></li><li><p>折叠结果遵循下列计算规则：</p><ul><li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值</li><li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值</li><li>两个外边距一正一负时，折叠结果是两者的相加的和</li></ul></li></ul><p><strong>请写出多种等高布局</strong></p><ul><li>在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假像</li><li>模仿表格布局等高列效果：兼容性不好，在ie6-7无法正常运行</li><li>css3 flexbox 布局： .container{display: flex; align-items: stretch;}</li></ul><p><strong>css垂直居中的方法有哪些？</strong></p><ul><li>如果是单行文本, line-height 设置成和 height 值</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.vertical {</span><br><span class="line">      height: 100px;</span><br><span class="line">      line-height: 100px;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>已知高度的块级子元素，采用绝对定位和负边距</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.container {</span><br><span class="line">  position: relative;</span><br><span class="line">}</span><br><span class="line">.vertical {</span><br><span class="line">  height: 300px;  /*子元素高度*/</span><br><span class="line">  position: absolute;</span><br><span class="line">  top:50%;  /*父元素高度50%*/</span><br><span class="line">  margin-top: -150px; /*自身高度一半*/</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>未知高度的块级父子元素居中，模拟表格布局</li><li>缺点：IE67不兼容，父级 overflow：hidden 失效</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.container {</span><br><span class="line">      display: table;</span><br><span class="line">    }</span><br><span class="line">    .content {</span><br><span class="line">      display: table-cell;</span><br><span class="line">      vertical-align: middle;</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>新增 inline-block 兄弟元素，设置 vertical-align<ul><li>缺点：需要增加额外标签，IE67不兼容</li></ul></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.container {</span><br><span class="line">  height: 100%;/*定义父级高度，作为参考*/</span><br><span class="line">}</span><br><span class="line">.extra .vertical{</span><br><span class="line">  display: inline-block;  /*行内块显示*/</span><br><span class="line">  vertical-align: middle; /*垂直居中*/</span><br><span class="line">}</span><br><span class="line">.extra {</span><br><span class="line">  height: 100%; /*设置新增元素高度为100%*/</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>绝对定位配合 CSS3 位移</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.vertical {</span><br><span class="line">  position: absolute;</span><br><span class="line">  top:50%;  /*父元素高度50%*/</span><br><span class="line">  transform:translateY(-50%, -50%);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>CSS3弹性盒模型</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container {</span><br><span class="line">  display:flex;</span><br><span class="line">  justify-content: center; /*子元素水平居中*/</span><br><span class="line">  align-items: center; /*子元素垂直居中*/</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>圣杯布局的实现原理？</strong></p><ul><li>要求：三列布局；中间主体内容前置，且宽度自适应；两边内容定宽<ul><li>好处：重要的内容放在文档流前面可以优先渲染</li><li>原理：利用相对定位、浮动、负边距布局，而不添加额外标签</li></ul></li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> {</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">190px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.main</span> {</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.left</span> {</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">150px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">190px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>什么是双飞翼布局？实现原理？</strong></p><ul><li>双飞翼布局：对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局</li><li>原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。</li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> {</span><br><span class="line">    <span class="comment">/*padding-left:150px;*/</span></span><br><span class="line">    <span class="comment">/*padding-right:190px;*/</span></span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.main-wrap</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.main</span> {</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">190px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.left</span> {</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="comment">/*position: relative;*/</span></span><br><span class="line">    <span class="comment">/*left:-150px;*/</span></span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span> {</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">190px</span>;</span><br><span class="line">    <span class="comment">/*position:relative;*/</span></span><br><span class="line">    <span class="comment">/*right:-190px;*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>在CSS样式中常使用 px、em 在表现上有什么区别？</strong></p><ul><li>px 相对于显示器屏幕分辨率，无法用浏览器字体放大功能</li><li>em 值并不是固定的，会继承父级的字体大小： em = 像素值 / 父级font-size</li></ul><p><strong>为什么要初始化CSS样式？</strong></p><ul><li>不同浏览器对有些标签样式的默认值解析不同</li><li>不初始化CSS会造成各现浏览器之间的页面显示差异</li><li>可以使用 reset.css 或 Normalize.css 做 CSS 初始化</li></ul><p><strong>解释下什么是浮动和它的工作原理？</strong></p><ul><li>非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。<br>此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</li><li>工作原理：<ul><li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li><li>浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li></ul></li></ul><p><strong>浮动元素引起的问题？</strong></p><ul><li>父元素的高度无法被撑开，影响与父元素同级的元素</li><li>与浮动元素同级的非浮动元素会跟随其后</li></ul><p><strong>列举几种清除浮动的方式？</strong></p><ul><li>添加额外标签，例如 <code>&lt;div style="clear:both"&gt;&lt;/div&gt;</code></li><li>使用 br 标签和其自身的 clear 属性，例如 <code>&lt;br clear="all" /&gt;</code></li><li>父元素设置 overflow：hidden; 在IE6中还需要触发 hasLayout，例如zoom：1;</li><li>父元素也设置浮动</li><li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout</li></ul><p><strong>清除浮动最佳实践（after伪元素闭合浮动）：</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after{</span><br><span class="line">    content: "\200B";</span><br><span class="line">    display: table; </span><br><span class="line">    height: 0;</span><br><span class="line">    clear: both;</span><br><span class="line">  }</span><br><span class="line">  .clearfix{</span><br><span class="line">    *zoom: 1;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>  <strong>什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC？</strong></p><ul><li>当使用 @import 导入 CSS 时，会导致某些页面在 IE 出现奇怪的现象：<br>没有样式的页面内容显示瞬间闪烁，这种现象称为“文档样式短暂失效”，简称为FOUC</li><li>产生原因：当样式表晚于结构性html加载时，加载到此样式表时，页面将停止之前的渲染。</li><li>等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。</li><li>解决方法：使用 link 标签将样式表放在文档 head</li></ul><p><strong>介绍使用过的 CSS 预处理器？</strong></p><ul><li>CSS 预处理器基本思想：为 CSS 增加了一些编程的特性（变量、逻辑判断、函数等）</li><li>开发者使用这种语言进行进行 Web 页面样式设计，再编译成正常的 CSS 文件使用</li><li>使用 CSS 预处理器，可以使 CSS 更加简洁、适应性更强、可读性更佳，无需考虑兼容性</li><li>最常用的 CSS 预处理器语言包括：Sass（SCSS）和 LESS</li></ul><p><strong>CSS优化、提高性能的方法有哪些？</strong></p><ul><li>多个css合并，尽量减少HTTP请求</li><li>将css文件放在页面最上面</li><li>移除空的css规则</li><li>避免使用CSS表达式</li><li>选择器优化嵌套，尽量避免层级过深</li><li>充分利用css继承属性，减少代码量</li><li>抽象提取公共样式，减少代码量</li><li>属性值为0时，不加单位</li><li>属性值为小于1的小数时，省略小数点前面的0</li><li>css雪碧图</li></ul><p><strong>浏览器是怎样解析CSS选择器的？</strong></p><ul><li>浏览器解析 CSS 选择器的方式是从右到左</li></ul><p><strong>在网页中的应该使用奇数还是偶数的字体？</strong></p><ul><li>在网页中的应该使用“偶数”字体：<ul><li>偶数字号相对更容易和 web 设计的其他部分构成比例关系</li><li>使用奇数号字体时文本段落无法对齐</li><li>宋体的中文网页排布中使用最多的就是 12 和 14</li></ul></li></ul><p><strong>margin和padding分别适合什么场景使用？</strong></p><ul><li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin</li><li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding</li></ul><p><strong>抽离样式模块怎么写，说出思路？</strong></p><ul><li>CSS可以拆分成2部分：公共CSS 和 业务CSS：<ul><li>网站的配色，字体，交互提取出为公共CSS。这部分CSS命名不应涉及具体的业务</li><li>对于业务CSS，需要有统一的命名，使用公用的前缀。可以参考面向对象的CSS</li></ul></li></ul><p><strong>元素竖向的百分比设定是相对于容器的高度吗？</strong></p><ul><li>元素竖向的百分比设定是相对于容器的宽度，而不是高度</li></ul><p><strong>全屏滚动的原理是什么？ 用到了CSS的那些属性？</strong></p><ul><li>原理类似图片轮播原理，超出隐藏部分，滚动时显示</li><li>可能用到的CSS属性：overflow:hidden; transform:translate(100%, 100%); display:none;</li></ul><p><strong>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</strong></p><ul><li>响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本</li><li>基本原理是利用CSS3媒体查询，为不同尺寸的设备适配不同样式</li><li>对于低版本的IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容：</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  screenRespond();</span><br><span class="line">});</span><br><span class="line">screenRespond();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">screenRespond</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="keyword">var</span> screenWidth = $(<span class="built_in">window</span>).width();</span><br><span class="line"><span class="keyword">if</span>(screenWidth &lt;= <span class="number">1800</span>){</span><br><span class="line">  $(<span class="string">"body"</span>).attr(<span class="string">"class"</span>, <span class="string">"w1800"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(screenWidth &lt;= <span class="number">1400</span>){</span><br><span class="line">  $(<span class="string">"body"</span>).attr(<span class="string">"class"</span>, <span class="string">"w1400"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(screenWidth &gt; <span class="number">1800</span>){</span><br><span class="line">  $(<span class="string">"body"</span>).attr(<span class="string">"class"</span>, <span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>什么是视差滚动效果，如何给每页做不同的动画？</strong></p><ul><li><p>视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验</p></li><li><p>一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的</p></li><li><p>实现原理</p><ul><li>以 “页面滚动条” 作为 “视差动画进度条”</li><li>以 “滚轮刻度” 当作 “动画帧度” 去播放动画的</li><li>监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果</li></ul></li></ul><p><strong>a标签上四个伪类的执行顺序是怎么样的？</strong></p><p><code>link &gt; visited &gt; hover &gt; active</code></p><ul><li>L-V-H-A love hate 用喜欢和讨厌两个词来方便记忆</li></ul><p><strong>伪元素和伪类的区别和作用？</strong></p><ul><li>伪元素 – 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。</li><li>它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p::before {content:"第一章：";}</span><br><span class="line">p::after {content:"Hot!";}</span><br><span class="line">p::first-line {background:red;}</span><br><span class="line">p::first-letter {font-size:30px;}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>伪类 – 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:hover {color: #FF00FF}</span><br><span class="line">p:first-child {color: red}</span><br></pre></td></tr></tbody></table></figure><p><strong>::before 和 :after 中双冒号和单冒号有什么区别？</strong></p><ul><li>在 CSS 中伪类一直用 : 表示，如 :hover, :active 等</li><li>伪元素在CSS1中已存在，当时语法是用 : 表示，如 :before 和 :after</li><li>后来在CSS3中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类</li><li>由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素</li><li>综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容IE的老语法</li></ul><p><strong>如何修改Chrome记住密码后自动填充表单的黄色背景？</strong></p><ul><li>产生原因：由于Chrome默认会给自动填充的input表单加上 input:-webkit-autofill 私有属性造成的</li><li>解决方案1：在form标签上直接关闭了表单的自动填充：autocomplete=”off”</li><li>解决方案2：input:-webkit-autofill { background-color: transparent; }</li></ul><p><strong>input [type=search] 搜索框右侧小图标如何美化？</strong></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">"search"</span>]</span><span class="selector-pseudo">::-webkit-search-cancel-button</span>{</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"images/searchicon.png"</span>) no-repeat <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">15px</span> <span class="number">15px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>网站图片文件，如何点击下载？而非点击预览？</strong></p><p><code>&lt;a href="logo.jpg" download&gt;下载&lt;/a&gt;</code><br><code>&lt;a href="logo.jpg" download="网站LOGO" &gt;下载&lt;/a&gt;</code></p><p><strong>iOS safari 如何阻止“橡皮筋效果”？</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="keyword">var</span> stopScrolling = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>{</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, stopScrolling, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'touchmove'</span>, stopScrolling, <span class="literal">false</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p><strong>你对 line-height 是如何理解的？</strong></p><ul><li>line-height 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离</li><li>如果一个标签没有定义 height 属性，那么其最终表现的高度是由 line-height 决定的</li><li>一个容器没有设置高度，那么撑开容器高度的是 line-height 而不是容器内的文字内容</li><li>把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中</li><li>line-height 和 height 都能撑开一个高度，height 会触发 haslayout，而 line-height 不会</li></ul><p><strong>line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）</strong></p><ul><li>带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li><li>纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</li><li>百分比：将计算后的值传递给后代</li></ul><p><strong>设置元素浮动后，该元素的 display 值会如何变化？</strong></p><ul><li>设置元素浮动后，该元素的 display 值自动变成 block</li></ul><p><strong>怎么让Chrome支持小于12px 的文字？</strong></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.shrink</span>{</span><br><span class="line">  <span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(<span class="number">0.8</span>);</span><br><span class="line">  <span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="attribute">display</span>:inline-block;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）</strong></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-font-smoothing</span>: <span class="selector-tag">antialiased</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>font-style 属性 oblique 是什么意思？</strong></p><ul><li>font-style: oblique; 使没有 italic 属性的文字实现倾斜</li></ul><p><strong>如果需要手动写动画，你认为最小时间间隔是多久？</strong></p><ul><li>16.7ms 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔: 1s / 60 * 1000 ＝ 16.7ms</li></ul><p><strong>display:inline-block 什么时候会显示间隙？</strong></p><ul><li>相邻的 inline-block 元素之间有换行或空格分隔的情况下会产生间距</li><li>非 inline-block 水平元素设置为 inline-block 也会有水平间距</li><li>可以借助 vertical-align:top; 消除垂直间隙</li><li>可以在父级加 font-size：0; 在子元素里设置需要的字体大小，消除垂直间隙</li><li>把 li 标签写到同一行可以消除垂直间隙，但代码可读性差</li></ul><p><strong>overflow: scroll 时不能平滑滚动的问题怎么处理？</strong></p><ul><li>监听滚轮事件，然后滚动到一定距离时用 jquery 的 animate 实现平滑效果。</li></ul><p><strong>一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</strong></p><ul><li>方案1：<br> <code>.sub { height: calc(100%-100px); }</code></li><li>方案2：<br> <code>.container { position:relative; }</code><br> <code>.sub { position: absolute; top: 100px; bottom: 0; }</code></li><li>方案3：<br> <code>.container { display:flex; flex-direction:column; }</code><br> <code>.sub { flex:1; }</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax</title>
      <link href="2020/12/26/Ajax/"/>
      <url>2020/12/26/Ajax/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-Ajax-如何创建一个Ajax？"><a href="#什么是-Ajax-如何创建一个Ajax？" class="headerlink" title="什么是 Ajax? 如何创建一个Ajax？"></a>什么是<code> Ajax</code>? 如何创建一个<code>Ajax</code>？</h1><h2 id="AJAX-Asynchronous-Javascript-And-XML-异步-JavaScript-XML-在后台与服务器进行异步数据交换，不用重载整个网页，实现局部刷新。"><a href="#AJAX-Asynchronous-Javascript-And-XML-异步-JavaScript-XML-在后台与服务器进行异步数据交换，不用重载整个网页，实现局部刷新。" class="headerlink" title="AJAX(Asynchronous Javascript And XML) = 异步 JavaScript + XML 在后台与服务器进行异步数据交换，不用重载整个网页，实现局部刷新。"></a><code>AJAX(Asynchronous Javascript And XML) </code>= 异步 <code>JavaScript</code> + <code>XML</code> 在后台与服务器进行异步数据交换，不用重载整个网页，实现局部刷新。</h2><ul><li>创建 <code>ajax</code> 步骤：<ul><li>1.创建 <code>XMLHttpRequest</code> 对象</li><li>2.创建一个新的 <code>HTTP</code> 请求，并指定该 <code>HTTP</code> 请求的类型、验证信息</li><li>3.设置响应 <code>HTTP</code> 请求状态变化的回调函数</li><li>4.发送 <code>HTTP</code> 请求</li><li>5.获取异步调用返回的数据</li><li>6.使用 <code>JavaScript</code> 和 <code>DOM</code> 实现局部刷新</li></ul></li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">"POST"</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; (xhr.status == <span class="number">200</span> || xhr.status == <span class="number">304</span>)) {</span><br><span class="line">        fn.call(<span class="built_in">this</span>, xhr.responseText);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">xhr.send(data);</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http </tag>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matery主题介绍</title>
      <link href="2020/08/06/hello-world/"/>
      <url>2020/08/06/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-With-Matery"><a href="#Hexo-With-Matery" class="headerlink" title="Hexo-With-Matery"></a>Hexo-With-Matery</h1><p>默认主题为Matery的Hexo博客模板</p><h1 id="My-Blog"><a href="#My-Blog" class="headerlink" title="My Blog"></a>My Blog</h1><p><a href="https://www/">My Blog</a></p><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p><a href="https://ga/">DEMO_HERE</a></p><h1 id="特别之处"><a href="#特别之处" class="headerlink" title="特别之处"></a>特别之处</h1><ul><li><input checked="" disabled="" type="checkbox"> 更改默认Hexo主题为<code>Matery</code>，并去除Hexo默认<code>landscape</code>主题。</li><li><input checked="" disabled="" type="checkbox"> 删除<code>Matery</code>主题文件夹下的<code>.git</code>仓库，便于文件同步。</li><li><input checked="" disabled="" type="checkbox"> 自带<code>categories</code>,<code>tags</code>,<code>about</code>,<code>contant</code>,<code>friend</code>页面。</li><li><input checked="" disabled="" type="checkbox"> 自带<code>hexo-prism-plugin</code>代码高亮插件，并默认禁用Hexo官方代码高亮。</li><li><input checked="" disabled="" type="checkbox"> 自带<code>hexo-generator-search</code>搜索插件。</li><li><input checked="" disabled="" type="checkbox"> 自带<code>hexo-wordcount</code>文章字数统计插件。</li><li><input checked="" disabled="" type="checkbox"> 自带<code>hexo-generator-feed</code>RSS订阅插件。</li><li><input checked="" disabled="" type="checkbox"> 自带<code>hexo-abbrlink</code>链接优化插件。</li><li><input checked="" disabled="" type="checkbox"> 页面标题由<code>subtitle</code>改为<code>page-title</code>，更加简洁明了。</li><li><input checked="" disabled="" type="checkbox"> 默认去除<code>Banner图</code>动态背景颜色<code>Rainbow</code>。</li><li><input checked="" disabled="" type="checkbox"> 去除<code>Banner</code>图片每日更新，提高博客辨识度。</li><li><input checked="" disabled="" type="checkbox"> 修改<code>Banner</code>图片默认格式为<code>.jpeg</code>，减小图片体积，加快博客加载。</li><li><input disabled="" type="checkbox"> 修改<code>Banner</code>图片默认格式为更快的<code>.webp</code>。<code>.webp</code>文件在IOS端兼容性不太好。暂时不添加该功能。</li><li><input disabled="" type="checkbox"> 汉化<code>Hexo</code>根目录下的<code>_config.yml</code>配置文件。 （感谢：Neutron做出贡献）</li><li><input disabled="" type="checkbox"> 汉化<code>Matery</code>根目录下的<code>_config.yml</code>配置文件。 （感谢：Neutron做出贡献）</li></ul><h1 id="需要自定义"><a href="#需要自定义" class="headerlink" title="需要自定义"></a>需要自定义</h1><ul><li>添加DaoVoice在线聊天</li><li>添加Tidio在线聊天</li><li>修改社交链接</li><li>修改打赏二维码图片</li><li>文章的配置在<code>hello-world.md</code>中有完整配置。其中尾部有注释的非必填且可删除。<!--## Quick Start</li></ul><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>–&gt;</p>--></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Matery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
